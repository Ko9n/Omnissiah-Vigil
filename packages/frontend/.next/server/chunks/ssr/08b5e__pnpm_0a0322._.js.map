{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/index.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport { Tracer } from './Tracer';\nexport {\n  BasicTracerProvider,\n  EXPORTER_FACTORY,\n  ForceFlushState,\n  PROPAGATOR_FACTORY,\n} from './BasicTracerProvider';\nexport { BatchSpanProcessor, RandomIdGenerator } from './platform';\nexport { ConsoleSpanExporter } from './export/ConsoleSpanExporter';\nexport { InMemorySpanExporter } from './export/InMemorySpanExporter';\nexport { ReadableSpan } from './export/ReadableSpan';\nexport { SimpleSpanProcessor } from './export/SimpleSpanProcessor';\nexport { SpanExporter } from './export/SpanExporter';\nexport { NoopSpanProcessor } from './export/NoopSpanProcessor';\nexport { AlwaysOffSampler } from './sampler/AlwaysOffSampler';\nexport { AlwaysOnSampler } from './sampler/AlwaysOnSampler';\nexport { ParentBasedSampler } from './sampler/ParentBasedSampler';\nexport { TraceIdRatioBasedSampler } from './sampler/TraceIdRatioBasedSampler';\nexport { Sampler, SamplingDecision, SamplingResult } from './Sampler';\nexport { Span } from './Span';\nexport { SpanProcessor } from './SpanProcessor';\nexport { TimedEvent } from './TimedEvent';\nexport {\n  BatchSpanProcessorBrowserConfig,\n  BufferConfig,\n  GeneralLimits,\n  SDKRegistrationConfig,\n  SpanLimits,\n  TracerConfig,\n} from './types';\nexport { IdGenerator } from './IdGenerator';\n"],"names":[],"mappings":"AAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/Sampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  Link,\n  SpanAttributes,\n  SpanKind,\n  TraceState,\n} from '@opentelemetry/api';\n\n/**\n * A sampling decision that determines how a {@link Span} will be recorded\n * and collected.\n */\nexport enum SamplingDecision {\n  /**\n   * `Span.isRecording() === false`, span will not be recorded and all events\n   * and attributes will be dropped.\n   */\n  NOT_RECORD,\n  /**\n   * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}\n   * MUST NOT be set.\n   */\n  RECORD,\n  /**\n   * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}\n   * MUST be set.\n   */\n  RECORD_AND_SAMPLED,\n}\n\n/**\n * A sampling result contains a decision for a {@link Span} and additional\n * attributes the sampler would like to added to the Span.\n */\nexport interface SamplingResult {\n  /**\n   * A sampling decision, refer to {@link SamplingDecision} for details.\n   */\n  decision: SamplingDecision;\n  /**\n   * The list of attributes returned by SamplingResult MUST be immutable.\n   * Caller may call {@link Sampler}.shouldSample any number of times and\n   * can safely cache the returned value.\n   */\n  attributes?: Readonly<SpanAttributes>;\n  /**\n   * A {@link TraceState} that will be associated with the {@link Span} through\n   * the new {@link SpanContext}. Samplers SHOULD return the TraceState from\n   * the passed-in {@link Context} if they do not intend to change it. Leaving\n   * the value undefined will also leave the TraceState unchanged.\n   */\n  traceState?: TraceState;\n}\n\n/**\n * This interface represent a sampler. Sampling is a mechanism to control the\n * noise and overhead introduced by OpenTelemetry by reducing the number of\n * samples of traces collected and sent to the backend.\n */\nexport interface Sampler {\n  /**\n   * Checks whether span needs to be created and tracked.\n   *\n   * @param context Parent Context which may contain a span.\n   * @param traceId of the span to be created. It can be different from the\n   *     traceId in the {@link SpanContext}. Typically in situations when the\n   *     span to be created starts a new trace.\n   * @param spanName of the span to be created.\n   * @param spanKind of the span to be created.\n   * @param attributes Initial set of SpanAttributes for the Span being constructed.\n   * @param links Collection of links that will be associated with the Span to\n   *     be created. Typically useful for batch operations.\n   * @returns a {@link SamplingResult}.\n   */\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: SpanAttributes,\n    links: Link[]\n  ): SamplingResult;\n\n  /** Returns the sampler name or short description with the configuration. */\n  toString(): string;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;IAwBA;;;;;;AAIA,IAAY;AAAZ,CAAA,SAAY,gBAAgB;IAC1B;;;QAIA,gBAAA,CAAA,gBAAA,CAAA,aAAA,GAAA,EAAA,GAAA;IACA;;;QAIA,gBAAA,CAAA,gBAAA,CAAA,SAAA,GAAA,EAAA,GAAA;IACA;;;QAIA,gBAAA,CAAA,gBAAA,CAAA,qBAAA,GAAA,EAAA,GAAA;AACF,CAAC,EAhBW,oBAAgB,CAAhB,mBAAgB,CAAA,CAAA"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/AlwaysOffSampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples no traces. */\nexport class AlwaysOffSampler implements Sampler {\n  shouldSample(): SamplingResult {\n    return {\n      decision: SamplingDecision.NOT_RECORD,\n    };\n  }\n\n  toString(): string {\n    return 'AlwaysOffSampler';\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAkBA,oCAAA,GACA,IAAA,mBAAA;IAAA,SAAA,oBAUA;IATE,iBAAA,SAAA,CAAA,YAAY,GAAZ;QACE,OAAO;YACL,UAAU,+SAAA,CAAA,mBAAgB,CAAC,UAAU;;IAEzC;IAEA,iBAAA,SAAA,CAAA,QAAQ,GAAR;QACE,OAAO;IACT;IACF,OAAA;AAAA"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 126, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/AlwaysOnSampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples all traces. */\nexport class AlwaysOnSampler implements Sampler {\n  shouldSample(): SamplingResult {\n    return {\n      decision: SamplingDecision.RECORD_AND_SAMPLED,\n    };\n  }\n\n  toString(): string {\n    return 'AlwaysOnSampler';\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAkBA,qCAAA,GACA,IAAA,kBAAA;IAAA,SAAA,mBAUA;IATE,gBAAA,SAAA,CAAA,YAAY,GAAZ;QACE,OAAO;YACL,UAAU,+SAAA,CAAA,mBAAgB,CAAC,kBAAkB;;IAEjD;IAEA,gBAAA,SAAA,CAAA,QAAQ,GAAR;QACE,OAAO;IACT;IACF,OAAA;AAAA"}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/enums.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Event name definitions\nexport const ExceptionEventName = 'exception';\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;IAgBA,yBAAyB;;;;AAClB,IAAM,qBAAqB"}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/Span.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  diag,\n  Exception,\n  HrTime,\n  Link,\n  Span as APISpan,\n  SpanAttributes,\n  SpanAttributeValue,\n  SpanContext,\n  SpanKind,\n  SpanStatus,\n  SpanStatusCode,\n  TimeInput,\n} from '@opentelemetry/api';\nimport {\n  addHrTimes,\n  millisToHrTime,\n  getTimeOrigin,\n  hrTime,\n  hrTimeDuration,\n  InstrumentationLibrary,\n  isAttributeValue,\n  isTimeInput,\n  isTimeInputHrTime,\n  otperformance,\n  sanitizeAttributes,\n} from '@opentelemetry/core';\nimport { IResource } from '@opentelemetry/resources';\nimport {\n  SEMATTRS_EXCEPTION_MESSAGE,\n  SEMATTRS_EXCEPTION_STACKTRACE,\n  SEMATTRS_EXCEPTION_TYPE,\n} from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { SpanProcessor } from './SpanProcessor';\nimport { TimedEvent } from './TimedEvent';\nimport { Tracer } from './Tracer';\nimport { SpanLimits } from './types';\n\n/**\n * This class represents a span.\n */\nexport class Span implements APISpan, ReadableSpan {\n  // Below properties are included to implement ReadableSpan for export\n  // purposes but are not intended to be written-to directly.\n  private readonly _spanContext: SpanContext;\n  readonly kind: SpanKind;\n  readonly parentSpanId?: string;\n  readonly attributes: SpanAttributes = {};\n  readonly links: Link[] = [];\n  readonly events: TimedEvent[] = [];\n  readonly startTime: HrTime;\n  readonly resource: IResource;\n  readonly instrumentationLibrary: InstrumentationLibrary;\n\n  private _droppedAttributesCount = 0;\n  private _droppedEventsCount: number = 0;\n  private _droppedLinksCount: number = 0;\n\n  name: string;\n  status: SpanStatus = {\n    code: SpanStatusCode.UNSET,\n  };\n  endTime: HrTime = [0, 0];\n  private _ended = false;\n  private _duration: HrTime = [-1, -1];\n  private readonly _spanProcessor: SpanProcessor;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _attributeValueLengthLimit: number;\n\n  private readonly _performanceStartTime: number;\n  private readonly _performanceOffset: number;\n  private readonly _startTimeProvided: boolean;\n\n  /**\n   * Constructs a new Span instance.\n   *\n   * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.\n   * */\n  constructor(\n    parentTracer: Tracer,\n    context: Context,\n    spanName: string,\n    spanContext: SpanContext,\n    kind: SpanKind,\n    parentSpanId?: string,\n    links: Link[] = [],\n    startTime?: TimeInput,\n    _deprecatedClock?: unknown, // keeping this argument even though it is unused to ensure backwards compatibility\n    attributes?: SpanAttributes\n  ) {\n    this.name = spanName;\n    this._spanContext = spanContext;\n    this.parentSpanId = parentSpanId;\n    this.kind = kind;\n    this.links = links;\n\n    const now = Date.now();\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset =\n      now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = startTime != null;\n\n    this.startTime = this._getTime(startTime ?? now);\n\n    this.resource = parentTracer.resource;\n    this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n    this._spanLimits = parentTracer.getSpanLimits();\n    this._attributeValueLengthLimit =\n      this._spanLimits.attributeValueLengthLimit || 0;\n\n    if (attributes != null) {\n      this.setAttributes(attributes);\n    }\n\n    this._spanProcessor = parentTracer.getActiveSpanProcessor();\n    this._spanProcessor.onStart(this, context);\n  }\n\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  setAttribute(key: string, value?: SpanAttributeValue): this;\n  setAttribute(key: string, value: unknown): this {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n\n    if (\n      Object.keys(this.attributes).length >=\n        this._spanLimits.attributeCountLimit! &&\n      !Object.prototype.hasOwnProperty.call(this.attributes, key)\n    ) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  }\n\n  setAttributes(attributes: SpanAttributes): this {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  addEvent(\n    name: string,\n    attributesOrStartTime?: SpanAttributes | TimeInput,\n    timeStamp?: TimeInput\n  ): this {\n    if (this._isSpanEnded()) return this;\n    if (this._spanLimits.eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n    if (this.events.length >= this._spanLimits.eventCountLimit!) {\n      if (this._droppedEventsCount === 0) {\n        diag.debug('Dropping extra events.');\n      }\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n\n    const attributes = sanitizeAttributes(attributesOrStartTime);\n\n    this.events.push({\n      name,\n      attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0,\n    });\n    return this;\n  }\n\n  addLink(link: Link): this {\n    this.links.push(link);\n    return this;\n  }\n\n  addLinks(links: Link[]): this {\n    this.links.push(...links);\n    return this;\n  }\n\n  setStatus(status: SpanStatus): this {\n    if (this._isSpanEnded()) return this;\n    this.status = { ...status };\n\n    // When using try-catch, the caught \"error\" is of type `any`. When then assigning `any` to `status.message`,\n    // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()\n    // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or\n    // undefined to avoid an incorrect type causing issues downstream.\n    if (this.status.message != null && typeof status.message !== 'string') {\n      diag.warn(\n        `Dropping invalid status.message of type '${typeof status.message}', expected 'string'`\n      );\n      delete this.status.message;\n    }\n\n    return this;\n  }\n\n  updateName(name: string): this {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  }\n\n  end(endTime?: TimeInput): void {\n    if (this._isSpanEnded()) {\n      diag.error(\n        `${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`\n      );\n      return;\n    }\n    this._ended = true;\n\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n\n    if (this._duration[0] < 0) {\n      diag.warn(\n        'Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.',\n        this.startTime,\n        this.endTime\n      );\n      this.endTime = this.startTime.slice() as HrTime;\n      this._duration = [0, 0];\n    }\n\n    if (this._droppedEventsCount > 0) {\n      diag.warn(\n        `Dropped ${this._droppedEventsCount} events because eventCountLimit reached`\n      );\n    }\n\n    this._spanProcessor.onEnd(this);\n  }\n\n  private _getTime(inp?: TimeInput): HrTime {\n    if (typeof inp === 'number' && inp <= otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n\n    const msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  }\n\n  isRecording(): boolean {\n    return this._ended === false;\n  }\n\n  recordException(exception: Exception, time?: TimeInput): void {\n    const attributes: SpanAttributes = {};\n    if (typeof exception === 'string') {\n      attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[SEMATTRS_EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n\n    // these are minimum requirements from spec\n    if (\n      attributes[SEMATTRS_EXCEPTION_TYPE] ||\n      attributes[SEMATTRS_EXCEPTION_MESSAGE]\n    ) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(`Failed to record an exception ${exception}`);\n    }\n  }\n\n  get duration(): HrTime {\n    return this._duration;\n  }\n\n  get ended(): boolean {\n    return this._ended;\n  }\n\n  get droppedAttributesCount(): number {\n    return this._droppedAttributesCount;\n  }\n\n  get droppedEventsCount(): number {\n    return this._droppedEventsCount;\n  }\n\n  get droppedLinksCount(): number {\n    return this._droppedLinksCount;\n  }\n\n  private _isSpanEnded(): boolean {\n    if (this._ended) {\n      diag.warn(\n        `Can not execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`\n      );\n    }\n    return this._ended;\n  }\n\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  private _truncateToLimitUtil(value: string, limit: number): string {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substring(0, limit);\n  }\n\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with truncated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  private _truncateToSize(value: SpanAttributeValue): SpanAttributeValue {\n    const limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n\n    // Array of strings\n    if (Array.isArray(value)) {\n      return (value as []).map(val =>\n        typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val\n      );\n    }\n\n    // Other types, no need to apply value length limit\n    return value;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 578, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 583, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/ParentBasedSampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  isSpanContextValid,\n  Link,\n  SpanAttributes,\n  SpanKind,\n  TraceFlags,\n  trace,\n} from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { AlwaysOffSampler } from './AlwaysOffSampler';\nimport { AlwaysOnSampler } from './AlwaysOnSampler';\nimport { Sampler, SamplingResult } from '../Sampler';\n\n/**\n * A composite sampler that either respects the parent span's sampling decision\n * or delegates to `delegateSampler` for root spans.\n */\nexport class ParentBasedSampler implements Sampler {\n  private _root: Sampler;\n  private _remoteParentSampled: Sampler;\n  private _remoteParentNotSampled: Sampler;\n  private _localParentSampled: Sampler;\n  private _localParentNotSampled: Sampler;\n\n  constructor(config: ParentBasedSamplerConfig) {\n    this._root = config.root;\n\n    if (!this._root) {\n      globalErrorHandler(\n        new Error('ParentBasedSampler must have a root sampler configured')\n      );\n      this._root = new AlwaysOnSampler();\n    }\n\n    this._remoteParentSampled =\n      config.remoteParentSampled ?? new AlwaysOnSampler();\n    this._remoteParentNotSampled =\n      config.remoteParentNotSampled ?? new AlwaysOffSampler();\n    this._localParentSampled =\n      config.localParentSampled ?? new AlwaysOnSampler();\n    this._localParentNotSampled =\n      config.localParentNotSampled ?? new AlwaysOffSampler();\n  }\n\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: SpanAttributes,\n    links: Link[]\n  ): SamplingResult {\n    const parentContext = trace.getSpanContext(context);\n\n    if (!parentContext || !isSpanContextValid(parentContext)) {\n      return this._root.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.isRemote) {\n      if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n        return this._remoteParentSampled.shouldSample(\n          context,\n          traceId,\n          spanName,\n          spanKind,\n          attributes,\n          links\n        );\n      }\n      return this._remoteParentNotSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n      return this._localParentSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    return this._localParentNotSampled.shouldSample(\n      context,\n      traceId,\n      spanName,\n      spanKind,\n      attributes,\n      links\n    );\n  }\n\n  toString(): string {\n    return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;\n  }\n}\n\ninterface ParentBasedSamplerConfig {\n  /** Sampler called for spans with no parent */\n  root: Sampler;\n  /** Sampler called for spans with a remote parent which was sampled. Default AlwaysOn */\n  remoteParentSampled?: Sampler;\n  /** Sampler called for spans with a remote parent which was not sampled. Default AlwaysOff */\n  remoteParentNotSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was sampled. Default AlwaysOn */\n  localParentSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was not sampled. Default AlwaysOff */\n  localParentNotSampled?: Sampler;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;;IAIA,IAAA,qBAAA;IAOE,SAAA,mBAAY,MAAgC;;QAC1C,IAAI,CAAC,KAAK,GAAG,OAAO,IAAI;QAExB,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACf,CAAA,GAAA,4SAAA,CAAA,qBAAkB,AAAlB,EACE,IAAI,MAAM;YAEZ,IAAI,CAAC,KAAK,GAAG,IAAI,kUAAA,CAAA,kBAAe;;QAGlC,IAAI,CAAC,oBAAoB,GACvB,CAAA,KAAA,OAAO,mBAAmB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,kUAAA,CAAA,kBAAe;QACnD,IAAI,CAAC,uBAAuB,GAC1B,CAAA,KAAA,OAAO,sBAAsB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,mUAAA,CAAA,mBAAgB;QACvD,IAAI,CAAC,mBAAmB,GACtB,CAAA,KAAA,OAAO,kBAAkB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,kUAAA,CAAA,kBAAe;QAClD,IAAI,CAAC,sBAAsB,GACzB,CAAA,KAAA,OAAO,qBAAqB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,mUAAA,CAAA,mBAAgB;IACxD;IAEA,mBAAA,SAAA,CAAA,YAAY,GAAZ,SACE,OAAgB,EAChB,OAAe,EACf,QAAgB,EAChB,QAAkB,EAClB,UAA0B,EAC1B,KAAa;QAEb,IAAM,gBAAgB,2DAAA,CAAA,QAAK,CAAC,cAAc,CAAC;QAE3C,IAAI,CAAC,iBAAiB,CAAC,CAAA,GAAA,2DAAA,CAAA,qBAAkB,AAAlB,EAAmB,gBAAgB;YACxD,OAAO,IAAI,CAAC,KAAK,CAAC,YAAY,CAC5B,SACA,SACA,UACA,UACA,YACA;;QAIJ,IAAI,cAAc,QAAQ,EAAE;YAC1B,IAAI,cAAc,UAAU,GAAG,2DAAA,CAAA,aAAU,CAAC,OAAO,EAAE;gBACjD,OAAO,IAAI,CAAC,oBAAoB,CAAC,YAAY,CAC3C,SACA,SACA,UACA,UACA,YACA;;YAGJ,OAAO,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAC9C,SACA,SACA,UACA,UACA,YACA;;QAIJ,IAAI,cAAc,UAAU,GAAG,2DAAA,CAAA,aAAU,CAAC,OAAO,EAAE;YACjD,OAAO,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAC1C,SACA,SACA,UACA,UACA,YACA;;QAIJ,OAAO,IAAI,CAAC,sBAAsB,CAAC,YAAY,CAC7C,SACA,SACA,UACA,UACA,YACA;IAEJ;IAEA,mBAAA,SAAA,CAAA,QAAQ,GAAR;QACE,OAAO,sBAAoB,IAAI,CAAC,KAAK,CAAC,QAAQ,KAAE,2BAAyB,IAAI,CAAC,oBAAoB,CAAC,QAAQ,KAAE,8BAA4B,IAAI,CAAC,uBAAuB,CAAC,QAAQ,KAAE,0BAAwB,IAAI,CAAC,mBAAmB,CAAC,QAAQ,KAAE,6BAA2B,IAAI,CAAC,sBAAsB,CAAC,QAAQ,KAAE;IAC9S;IACF,OAAA;AAAA"}},
    {"offset": {"line": 648, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 653, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/TraceIdRatioBasedSampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isValidTraceId } from '@opentelemetry/api';\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples a given fraction of traces based of trace id deterministically. */\nexport class TraceIdRatioBasedSampler implements Sampler {\n  private _upperBound: number;\n\n  constructor(private readonly _ratio: number = 0) {\n    this._ratio = this._normalize(_ratio);\n    this._upperBound = Math.floor(this._ratio * 0xffffffff);\n  }\n\n  shouldSample(context: unknown, traceId: string): SamplingResult {\n    return {\n      decision:\n        isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound\n          ? SamplingDecision.RECORD_AND_SAMPLED\n          : SamplingDecision.NOT_RECORD,\n    };\n  }\n\n  toString(): string {\n    return `TraceIdRatioBased{${this._ratio}}`;\n  }\n\n  private _normalize(ratio: number): number {\n    if (typeof ratio !== 'number' || isNaN(ratio)) return 0;\n    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n  }\n\n  private _accumulate(traceId: string): number {\n    let accumulation = 0;\n    for (let i = 0; i < traceId.length / 8; i++) {\n      const pos = i * 8;\n      const part = parseInt(traceId.slice(pos, pos + 8), 16);\n      accumulation = (accumulation ^ part) >>> 0;\n    }\n    return accumulation;\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;AAmBA,yFAAA,GACA,IAAA,2BAAA;IAGE,SAAA,yBAA6B,MAAkB;QAAlB,IAAA,WAAA,KAAA,GAAA;YAAA,SAAA;QAAkB;QAAlB,IAAA,CAAA,MAAM,GAAN;QAC3B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC;QAC9B,IAAI,CAAC,WAAW,GAAG,KAAK,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG;IAC9C;IAEA,yBAAA,SAAA,CAAA,YAAY,GAAZ,SAAa,OAAgB,EAAE,OAAe;QAC5C,OAAO;YACL,UACE,CAAA,GAAA,2DAAA,CAAA,iBAAc,AAAd,EAAe,YAAY,IAAI,CAAC,WAAW,CAAC,WAAW,IAAI,CAAC,WAAW,GACnE,+SAAA,CAAA,mBAAgB,CAAC,kBAAkB,GACnC,+SAAA,CAAA,mBAAgB,CAAC,UAAU;;IAErC;IAEA,yBAAA,SAAA,CAAA,QAAQ,GAAR;QACE,OAAO,uBAAqB,IAAI,CAAC,MAAM,GAAA;IACzC;IAEQ,yBAAA,SAAA,CAAA,UAAU,GAAlB,SAAmB,KAAa;QAC9B,IAAI,OAAO,UAAU,YAAY,MAAM,QAAQ,OAAO;QACtD,OAAO,SAAS,IAAI,IAAI,SAAS,IAAI,IAAI;IAC3C;IAEQ,yBAAA,SAAA,CAAA,WAAW,GAAnB,SAAoB,OAAe;QACjC,IAAI,eAAe;QACnB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,GAAG,GAAG,IAAK;YAC3C,IAAM,MAAM,IAAI;YAChB,IAAM,OAAO,SAAS,QAAQ,KAAK,CAAC,KAAK,MAAM,IAAI;YACnD,eAAe,CAAC,eAAe,IAAI,MAAM;;QAE3C,OAAO;IACT;IACF,OAAA;AAAA"}},
    {"offset": {"line": 709, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 714, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/config.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\nimport { getEnv, TracesSamplerValues, ENVIRONMENT } from '@opentelemetry/core';\nimport { Sampler } from './Sampler';\nimport { AlwaysOffSampler } from './sampler/AlwaysOffSampler';\nimport { AlwaysOnSampler } from './sampler/AlwaysOnSampler';\nimport { ParentBasedSampler } from './sampler/ParentBasedSampler';\nimport { TraceIdRatioBasedSampler } from './sampler/TraceIdRatioBasedSampler';\n\nconst FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;\nconst DEFAULT_RATIO = 1;\n\n/**\n * Load default configuration. For fields with primitive values, any user-provided\n * value will override the corresponding default value. For fields with\n * non-primitive values (like `spanLimits`), the user-provided value will be\n * used to extend the default value.\n */\n\n// object needs to be wrapped in this function and called when needed otherwise\n// envs are parsed before tests are ran - causes tests using these envs to fail\nexport function loadDefaultConfig() {\n  const env = getEnv();\n\n  return {\n    sampler: buildSamplerFromEnv(env),\n    forceFlushTimeoutMillis: 30000,\n    generalLimits: {\n      attributeValueLengthLimit: env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      attributeCountLimit: env.OTEL_ATTRIBUTE_COUNT_LIMIT,\n    },\n    spanLimits: {\n      attributeValueLengthLimit: env.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      attributeCountLimit: env.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,\n      linkCountLimit: env.OTEL_SPAN_LINK_COUNT_LIMIT,\n      eventCountLimit: env.OTEL_SPAN_EVENT_COUNT_LIMIT,\n      attributePerEventCountLimit:\n        env.OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,\n      attributePerLinkCountLimit: env.OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,\n    },\n    mergeResourceWithDefaults: true,\n  };\n}\n\n/**\n * Based on environment, builds a sampler, complies with specification.\n * @param environment optional, by default uses getEnv(), but allows passing a value to reuse parsed environment\n */\nexport function buildSamplerFromEnv(\n  environment: Required<ENVIRONMENT> = getEnv()\n): Sampler {\n  switch (environment.OTEL_TRACES_SAMPLER) {\n    case TracesSamplerValues.AlwaysOn:\n      return new AlwaysOnSampler();\n    case TracesSamplerValues.AlwaysOff:\n      return new AlwaysOffSampler();\n    case TracesSamplerValues.ParentBasedAlwaysOn:\n      return new ParentBasedSampler({\n        root: new AlwaysOnSampler(),\n      });\n    case TracesSamplerValues.ParentBasedAlwaysOff:\n      return new ParentBasedSampler({\n        root: new AlwaysOffSampler(),\n      });\n    case TracesSamplerValues.TraceIdRatio:\n      return new TraceIdRatioBasedSampler(\n        getSamplerProbabilityFromEnv(environment)\n      );\n    case TracesSamplerValues.ParentBasedTraceIdRatio:\n      return new ParentBasedSampler({\n        root: new TraceIdRatioBasedSampler(\n          getSamplerProbabilityFromEnv(environment)\n        ),\n      });\n    default:\n      diag.error(\n        `OTEL_TRACES_SAMPLER value \"${environment.OTEL_TRACES_SAMPLER} invalid, defaulting to ${FALLBACK_OTEL_TRACES_SAMPLER}\".`\n      );\n      return new AlwaysOnSampler();\n  }\n}\n\nfunction getSamplerProbabilityFromEnv(\n  environment: Required<ENVIRONMENT>\n): number | undefined {\n  if (\n    environment.OTEL_TRACES_SAMPLER_ARG === undefined ||\n    environment.OTEL_TRACES_SAMPLER_ARG === ''\n  ) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  const probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);\n\n  if (isNaN(probability)) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is invalid, defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  if (probability < 0 || probability > 1) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  return probability;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,IAAM,+BAA+B,yRAAA,CAAA,sBAAmB,CAAC,QAAQ;AACjE,IAAM,gBAAgB;AAWhB,SAAU;IACd,IAAM,MAAM,CAAA,GAAA,uSAAA,CAAA,SAAM,AAAN;IAEZ,OAAO;QACL,SAAS,oBAAoB;QAC7B,yBAAyB;QACzB,eAAe;YACb,2BAA2B,IAAI,iCAAiC;YAChE,qBAAqB,IAAI,0BAA0B;;QAErD,YAAY;YACV,2BAA2B,IAAI,sCAAsC;YACrE,qBAAqB,IAAI,+BAA+B;YACxD,gBAAgB,IAAI,0BAA0B;YAC9C,iBAAiB,IAAI,2BAA2B;YAChD,6BACE,IAAI,yCAAyC;YAC/C,4BAA4B,IAAI,wCAAwC;;QAE1E,2BAA2B;;AAE/B;AAMM,SAAU,oBACd,WAA6C;IAA7C,IAAA,gBAAA,KAAA,GAAA;QAAA,cAAqC,CAAA,GAAA,uSAAA,CAAA,SAAM,AAAN;IAAQ;IAE7C,OAAQ,YAAY,mBAAmB;QACrC,KAAK,yRAAA,CAAA,sBAAmB,CAAC,QAAQ;YAC/B,OAAO,IAAI,kUAAA,CAAA,kBAAe;QAC5B,KAAK,yRAAA,CAAA,sBAAmB,CAAC,SAAS;YAChC,OAAO,IAAI,mUAAA,CAAA,mBAAgB;QAC7B,KAAK,yRAAA,CAAA,sBAAmB,CAAC,mBAAmB;YAC1C,OAAO,IAAI,qUAAA,CAAA,qBAAkB,CAAC;gBAC5B,MAAM,IAAI,kUAAA,CAAA,kBAAe;;QAE7B,KAAK,yRAAA,CAAA,sBAAmB,CAAC,oBAAoB;YAC3C,OAAO,IAAI,qUAAA,CAAA,qBAAkB,CAAC;gBAC5B,MAAM,IAAI,mUAAA,CAAA,mBAAgB;;QAE9B,KAAK,yRAAA,CAAA,sBAAmB,CAAC,YAAY;YACnC,OAAO,IAAI,2UAAA,CAAA,2BAAwB,CACjC,6BAA6B;QAEjC,KAAK,yRAAA,CAAA,sBAAmB,CAAC,uBAAuB;YAC9C,OAAO,IAAI,qUAAA,CAAA,qBAAkB,CAAC;gBAC5B,MAAM,IAAI,2UAAA,CAAA,2BAAwB,CAChC,6BAA6B;;QAGnC;YACE,2DAAA,CAAA,OAAI,CAAC,KAAK,CACR,iCAA8B,YAAY,mBAAmB,GAAA,6BAA2B,+BAA4B;YAEtH,OAAO,IAAI,kUAAA,CAAA,kBAAe;;AAEhC;AAEA,SAAS,6BACP,WAAkC;IAElC,IACE,YAAY,uBAAuB,KAAK,aACxC,YAAY,uBAAuB,KAAK,IACxC;QACA,2DAAA,CAAA,OAAI,CAAC,KAAK,CACR,qDAAmD,gBAAa;QAElE,OAAO;;IAGT,IAAM,cAAc,OAAO,YAAY,uBAAuB;IAE9D,IAAI,MAAM,cAAc;QACtB,2DAAA,CAAA,OAAI,CAAC,KAAK,CACR,6BAA2B,YAAY,uBAAuB,GAAA,kDAAgD,gBAAa;QAE7H,OAAO;;IAGT,IAAI,cAAc,KAAK,cAAc,GAAG;QACtC,2DAAA,CAAA,OAAI,CAAC,KAAK,CACR,6BAA2B,YAAY,uBAAuB,GAAA,gEAA8D,gBAAa;QAE3I,OAAO;;IAGT,OAAO;AACT"}},
    {"offset": {"line": 812, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 817, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/utility.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { buildSamplerFromEnv, loadDefaultConfig } from './config';\nimport { Sampler } from './Sampler';\nimport { SpanLimits, TracerConfig, GeneralLimits } from './types';\nimport {\n  DEFAULT_ATTRIBUTE_COUNT_LIMIT,\n  DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n  getEnvWithoutDefaults,\n} from '@opentelemetry/core';\n\n/**\n * Function to merge Default configuration (as specified in './config') with\n * user provided configurations.\n */\nexport function mergeConfig(userConfig: TracerConfig): TracerConfig & {\n  sampler: Sampler;\n  spanLimits: SpanLimits;\n  generalLimits: GeneralLimits;\n} {\n  const perInstanceDefaults: Partial<TracerConfig> = {\n    sampler: buildSamplerFromEnv(),\n  };\n\n  const DEFAULT_CONFIG = loadDefaultConfig();\n\n  const target = Object.assign(\n    {},\n    DEFAULT_CONFIG,\n    perInstanceDefaults,\n    userConfig\n  );\n\n  target.generalLimits = Object.assign(\n    {},\n    DEFAULT_CONFIG.generalLimits,\n    userConfig.generalLimits || {}\n  );\n\n  target.spanLimits = Object.assign(\n    {},\n    DEFAULT_CONFIG.spanLimits,\n    userConfig.spanLimits || {}\n  );\n\n  return target;\n}\n\n/**\n * When general limits are provided and model specific limits are not,\n * configures the model specific limits by using the values from the general ones.\n * @param userConfig User provided tracer configuration\n */\nexport function reconfigureLimits(userConfig: TracerConfig): TracerConfig {\n  const spanLimits = Object.assign({}, userConfig.spanLimits);\n\n  const parsedEnvConfig = getEnvWithoutDefaults();\n\n  /**\n   * Reassign span attribute count limit to use first non null value defined by user or use default value\n   */\n  spanLimits.attributeCountLimit =\n    userConfig.spanLimits?.attributeCountLimit ??\n    userConfig.generalLimits?.attributeCountLimit ??\n    parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT ??\n    parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT ??\n    DEFAULT_ATTRIBUTE_COUNT_LIMIT;\n\n  /**\n   * Reassign span attribute value length limit to use first non null value defined by user or use default value\n   */\n  spanLimits.attributeValueLengthLimit =\n    userConfig.spanLimits?.attributeValueLengthLimit ??\n    userConfig.generalLimits?.attributeValueLengthLimit ??\n    parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT ??\n    parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT ??\n    DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;\n\n  return Object.assign({}, userConfig, { spanLimits });\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA6BM,SAAU,YAAY,UAAwB;IAKlD,IAAM,sBAA6C;QACjD,SAAS,CAAA,GAAA,8SAAA,CAAA,sBAAmB,AAAnB;;IAGX,IAAM,iBAAiB,CAAA,GAAA,8SAAA,CAAA,oBAAiB,AAAjB;IAEvB,IAAM,SAAS,OAAO,MAAM,CAC1B,CAAA,GACA,gBACA,qBACA;IAGF,OAAO,aAAa,GAAG,OAAO,MAAM,CAClC,CAAA,GACA,eAAe,aAAa,EAC5B,WAAW,aAAa,IAAI,CAAA;IAG9B,OAAO,UAAU,GAAG,OAAO,MAAM,CAC/B,CAAA,GACA,eAAe,UAAU,EACzB,WAAW,UAAU,IAAI,CAAA;IAG3B,OAAO;AACT;AAOM,SAAU,kBAAkB,UAAwB;;IACxD,IAAM,aAAa,OAAO,MAAM,CAAC,CAAA,GAAI,WAAW,UAAU;IAE1D,IAAM,kBAAkB,CAAA,GAAA,uSAAA,CAAA,wBAAqB,AAArB;IAExB;;QAGA,WAAW,mBAAmB,GAC5B,CAAA,KAAA,CAAA,KAAA,CAAA,KAAA,CAAA,KAAA,CAAA,KAAA,WAAW,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,mBAAmB,MAAA,QAAA,OAAA,KAAA,IAAA,KAC1C,CAAA,KAAA,WAAW,aAAa,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,mBAAmB,MAAA,QAAA,OAAA,KAAA,IAAA,KAC7C,gBAAgB,+BAA+B,MAAA,QAAA,OAAA,KAAA,IAAA,KAC/C,gBAAgB,0BAA0B,MAAA,QAAA,OAAA,KAAA,IAAA,KAC1C,4RAAA,CAAA,gCAA6B;IAE/B;;QAGA,WAAW,yBAAyB,GAClC,CAAA,KAAA,CAAA,KAAA,CAAA,KAAA,CAAA,KAAA,CAAA,KAAA,WAAW,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,yBAAyB,MAAA,QAAA,OAAA,KAAA,IAAA,KAChD,CAAA,KAAA,WAAW,aAAa,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,yBAAyB,MAAA,QAAA,OAAA,KAAA,IAAA,KACnD,gBAAgB,sCAAsC,MAAA,QAAA,OAAA,KAAA,IAAA,KACtD,gBAAgB,iCAAiC,MAAA,QAAA,OAAA,KAAA,IAAA,KACjD,4RAAA,CAAA,uCAAoC;IAEtC,OAAO,OAAO,MAAM,CAAC,CAAA,GAAI,YAAY;QAAE,YAAU;IAAA;AACnD"}},
    {"offset": {"line": 865, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 870, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/platform/node/RandomIdGenerator.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IdGenerator } from '../../IdGenerator';\n\nconst SPAN_ID_BYTES = 8;\nconst TRACE_ID_BYTES = 16;\n\nexport class RandomIdGenerator implements IdGenerator {\n  /**\n   * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex\n   * characters corresponding to 128 bits.\n   */\n  generateTraceId = getIdGenerator(TRACE_ID_BYTES);\n\n  /**\n   * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex\n   * characters corresponding to 64 bits.\n   */\n  generateSpanId = getIdGenerator(SPAN_ID_BYTES);\n}\n\nconst SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);\nfunction getIdGenerator(bytes: number): () => string {\n  return function generateId() {\n    for (let i = 0; i < bytes / 4; i++) {\n      // unsigned right shift drops decimal part of the number\n      // it is required because if a number between 2**32 and 2**32 - 1 is generated, an out of range error is thrown by writeUInt32BE\n      SHARED_BUFFER.writeUInt32BE((Math.random() * 2 ** 32) >>> 0, i * 4);\n    }\n\n    // If buffer is all 0, set the last byte to 1 to guarantee a valid w3c id is generated\n    for (let i = 0; i < bytes; i++) {\n      if (SHARED_BUFFER[i] > 0) {\n        break;\n      } else if (i === bytes - 1) {\n        SHARED_BUFFER[bytes - 1] = 1;\n      }\n    }\n\n    return SHARED_BUFFER.toString('hex', 0, bytes);\n  };\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAkBA,IAAM,gBAAgB;AACtB,IAAM,iBAAiB;AAEvB,IAAA,oBAAA;IAAA,SAAA;QACE;;;YAIA,IAAA,CAAA,eAAe,GAAG,eAAe;QAEjC;;;YAIA,IAAA,CAAA,cAAc,GAAG,eAAe;IAClC;IAAA,OAAA;AAAA;;AAEA,IAAM,gBAAgB,OAAO,WAAW,CAAC;AACzC,SAAS,eAAe,KAAa;IACnC,OAAO,SAAS;QACd,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,GAAG,IAAK;YAClC,wDAAwD;YACxD,gIAAgI;YAChI,cAAc,aAAa,CAAC,AAAC,KAAK,MAAM,KAAK,KAAA,GAAA,CAAA,GAAK,QAAQ,GAAG,IAAI;;QAGnE,sFAAsF;QACtF,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;YAC9B,IAAI,aAAa,CAAC,EAAE,GAAG,GAAG;gBACxB;mBACK,IAAI,MAAM,QAAQ,GAAG;gBAC1B,aAAa,CAAC,QAAQ,EAAE,GAAG;;;QAI/B,OAAO,cAAc,QAAQ,CAAC,OAAO,GAAG;IAC1C;AACF"}},
    {"offset": {"line": 922, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 927, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/Tracer.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  InstrumentationLibrary,\n  sanitizeAttributes,\n  isTracingSuppressed,\n} from '@opentelemetry/core';\nimport { IResource } from '@opentelemetry/resources';\nimport { BasicTracerProvider } from './BasicTracerProvider';\nimport { Span } from './Span';\nimport { GeneralLimits, SpanLimits, TracerConfig } from './types';\nimport { mergeConfig } from './utility';\nimport { SpanProcessor } from './SpanProcessor';\nimport { Sampler } from './Sampler';\nimport { IdGenerator } from './IdGenerator';\nimport { RandomIdGenerator } from './platform';\n\n/**\n * This class represents a basic tracer.\n */\nexport class Tracer implements api.Tracer {\n  private readonly _sampler: Sampler;\n  private readonly _generalLimits: GeneralLimits;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _idGenerator: IdGenerator;\n  readonly resource: IResource;\n  readonly instrumentationLibrary: InstrumentationLibrary;\n\n  /**\n   * Constructs a new Tracer instance.\n   */\n  constructor(\n    instrumentationLibrary: InstrumentationLibrary,\n    config: TracerConfig,\n    private _tracerProvider: BasicTracerProvider\n  ) {\n    const localConfig = mergeConfig(config);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config.idGenerator || new RandomIdGenerator();\n    this.resource = _tracerProvider.resource;\n    this.instrumentationLibrary = instrumentationLibrary;\n  }\n\n  /**\n   * Starts a new Span or returns the default NoopSpan based on the sampling\n   * decision.\n   */\n  startSpan(\n    name: string,\n    options: api.SpanOptions = {},\n    context = api.context.active()\n  ): api.Span {\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context);\n    }\n    const parentSpan = api.trace.getSpan(context);\n\n    if (isTracingSuppressed(context)) {\n      api.diag.debug('Instrumentation suppressed, returning Noop Span');\n      const nonRecordingSpan = api.trace.wrapSpanContext(\n        api.INVALID_SPAN_CONTEXT\n      );\n      return nonRecordingSpan;\n    }\n\n    const parentSpanContext = parentSpan?.spanContext();\n    const spanId = this._idGenerator.generateSpanId();\n    let traceId;\n    let traceState;\n    let parentSpanId;\n    if (\n      !parentSpanContext ||\n      !api.trace.isSpanContextValid(parentSpanContext)\n    ) {\n      // New root span.\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      // New child span.\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      parentSpanId = parentSpanContext.spanId;\n    }\n\n    const spanKind = options.kind ?? api.SpanKind.INTERNAL;\n    const links = (options.links ?? []).map(link => {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes),\n      };\n    });\n    const attributes = sanitizeAttributes(options.attributes);\n    // make sampling decision\n    const samplingResult = this._sampler.shouldSample(\n      context,\n      traceId,\n      name,\n      spanKind,\n      attributes,\n      links\n    );\n\n    traceState = samplingResult.traceState ?? traceState;\n\n    const traceFlags =\n      samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n        ? api.TraceFlags.SAMPLED\n        : api.TraceFlags.NONE;\n    const spanContext = { traceId, spanId, traceFlags, traceState };\n    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n      api.diag.debug(\n        'Recording is off, propagating context in a non-recording span'\n      );\n      const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);\n      return nonRecordingSpan;\n    }\n\n    // Set initial span attributes. The attributes object may have been mutated\n    // by the sampler, so we sanitize the merged attributes before setting them.\n    const initAttributes = sanitizeAttributes(\n      Object.assign(attributes, samplingResult.attributes)\n    );\n\n    const span = new Span(\n      this,\n      context,\n      name,\n      spanContext,\n      spanKind,\n      parentSpanId,\n      links,\n      options.startTime,\n      undefined,\n      initAttributes\n    );\n    return span;\n  }\n\n  /**\n   * Starts a new {@link Span} and calls the given function passing it the\n   * created span as first argument.\n   * Additionally the new span gets set in context and this context is activated\n   * for the duration of the function call.\n   *\n   * @param name The name of the span\n   * @param [options] SpanOptions used for span creation\n   * @param [context] Context to use to extract parent\n   * @param fn function called in the context of the span and receives the newly created span as an argument\n   * @returns return value of fn\n   * @example\n   *   const something = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       span.setStatus({code: SpanStatusCode.OK});\n   *       return something;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     } finally {\n   *       span.end();\n   *     }\n   *   });\n   * @example\n   *   const span = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       return span;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     }\n   *   });\n   *   do some more work\n   *   span.end();\n   */\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    ctx: api.Context,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | api.SpanOptions,\n    arg3?: F | api.Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: api.SpanOptions | undefined;\n    let ctx: api.Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as api.SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as api.SpanOptions | undefined;\n      ctx = arg3 as api.Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? api.context.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = api.trace.setSpan(parentContext, span);\n\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  }\n\n  /** Returns the active {@link GeneralLimits}. */\n  getGeneralLimits(): GeneralLimits {\n    return this._generalLimits;\n  }\n\n  /** Returns the active {@link SpanLimits}. */\n  getSpanLimits(): SpanLimits {\n    return this._spanLimits;\n  }\n\n  getActiveSpanProcessor(): SpanProcessor {\n    return this._tracerProvider.getActiveSpanProcessor();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1069, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1074, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/MultiSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { Span } from './Span';\nimport { SpanProcessor } from './SpanProcessor';\n\n/**\n * Implementation of the {@link SpanProcessor} that simply forwards all\n * received events to a list of {@link SpanProcessor}s.\n */\nexport class MultiSpanProcessor implements SpanProcessor {\n  constructor(private readonly _spanProcessors: SpanProcessor[]) {}\n\n  forceFlush(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.forceFlush());\n    }\n    return new Promise(resolve => {\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(error => {\n          globalErrorHandler(\n            error || new Error('MultiSpanProcessor: forceFlush failed')\n          );\n          resolve();\n        });\n    });\n  }\n\n  onStart(span: Span, context: Context): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onStart(span, context);\n    }\n  }\n\n  onEnd(span: ReadableSpan): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onEnd(span);\n    }\n  }\n\n  shutdown(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.shutdown());\n    }\n    return new Promise((resolve, reject) => {\n      Promise.all(promises).then(() => {\n        resolve();\n      }, reject);\n    });\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;IAIA,IAAA,qBAAA;IACE,SAAA,mBAA6B,eAAgC;QAAhC,IAAA,CAAA,eAAe,GAAf;IAAmC;IAEhE,mBAAA,SAAA,CAAA,UAAU,GAAV;;QACE,IAAM,WAA4B,EAAE;;YAEpC,IAA4B,IAAA,KAAA,SAAA,IAAI,CAAC,eAAe,GAAA,KAAA,GAAA,IAAA,IAAA,CAAA,GAAA,IAAA,EAAA,KAAA,GAAA,IAAA,GAAE;gBAA7C,IAAM,gBAAa,GAAA,KAAA;gBACtB,SAAS,IAAI,CAAC,cAAc,UAAU;;;;;;;;;;;;;QAExC,OAAO,IAAI,QAAQ,SAAA,OAAO;YACxB,QAAQ,GAAG,CAAC,UACT,IAAI,CAAC;gBACJ;YACF,GACC,KAAK,CAAC,SAAA,KAAK;gBACV,CAAA,GAAA,4SAAA,CAAA,qBAAkB,AAAlB,EACE,SAAS,IAAI,MAAM;gBAErB;YACF;QACJ;IACF;IAEA,mBAAA,SAAA,CAAA,OAAO,GAAP,SAAQ,IAAU,EAAE,OAAgB;;;YAClC,IAA4B,IAAA,KAAA,SAAA,IAAI,CAAC,eAAe,GAAA,KAAA,GAAA,IAAA,IAAA,CAAA,GAAA,IAAA,EAAA,KAAA,GAAA,IAAA,GAAE;gBAA7C,IAAM,gBAAa,GAAA,KAAA;gBACtB,cAAc,OAAO,CAAC,MAAM;;;;;;;;;;;;;IAEhC;IAEA,mBAAA,SAAA,CAAA,KAAK,GAAL,SAAM,IAAkB;;;YACtB,IAA4B,IAAA,KAAA,SAAA,IAAI,CAAC,eAAe,GAAA,KAAA,GAAA,IAAA,IAAA,CAAA,GAAA,IAAA,EAAA,KAAA,GAAA,IAAA,GAAE;gBAA7C,IAAM,gBAAa,GAAA,KAAA;gBACtB,cAAc,KAAK,CAAC;;;;;;;;;;;;;IAExB;IAEA,mBAAA,SAAA,CAAA,QAAQ,GAAR;;QACE,IAAM,WAA4B,EAAE;;YAEpC,IAA4B,IAAA,KAAA,SAAA,IAAI,CAAC,eAAe,GAAA,KAAA,GAAA,IAAA,IAAA,CAAA,GAAA,IAAA,EAAA,KAAA,GAAA,IAAA,GAAE;gBAA7C,IAAM,gBAAa,GAAA,KAAA;gBACtB,SAAS,IAAI,CAAC,cAAc,QAAQ;;;;;;;;;;;;;QAEtC,OAAO,IAAI,QAAQ,SAAC,OAAO,EAAE,MAAM;YACjC,QAAQ,GAAG,CAAC,UAAU,IAAI,CAAC;gBACzB;YACF,GAAG;QACL;IACF;IACF,OAAA;AAAA"}},
    {"offset": {"line": 1210, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1215, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/NoopSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { ReadableSpan } from './ReadableSpan';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\n\n/** No-op implementation of SpanProcessor */\nexport class NoopSpanProcessor implements SpanProcessor {\n  onStart(_span: Span, _context: Context): void {}\n  onEnd(_span: ReadableSpan): void {}\n  shutdown(): Promise<void> {\n    return Promise.resolve();\n  }\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;IAqBA,0CAAA;;;AACA,IAAA,oBAAA;IAAA,SAAA,qBASA;IARE,kBAAA,SAAA,CAAA,OAAO,GAAP,SAAQ,KAAW,EAAE,QAAiB,GAAS;IAC/C,kBAAA,SAAA,CAAA,KAAK,GAAL,SAAM,KAAmB,GAAS;IAClC,kBAAA,SAAA,CAAA,QAAQ,GAAR;QACE,OAAO,QAAQ,OAAO;IACxB;IACA,kBAAA,SAAA,CAAA,UAAU,GAAV;QACE,OAAO,QAAQ,OAAO;IACxB;IACF,OAAA;AAAA"}},
    {"offset": {"line": 1246, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1251, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/BatchSpanProcessorBase.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { context, Context, diag, TraceFlags } from '@opentelemetry/api';\nimport {\n  BindOnceFuture,\n  ExportResultCode,\n  getEnv,\n  globalErrorHandler,\n  suppressTracing,\n  unrefTimer,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { BufferConfig } from '../types';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\n\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nexport abstract class BatchSpanProcessorBase<T extends BufferConfig>\n  implements SpanProcessor\n{\n  private readonly _maxExportBatchSize: number;\n  private readonly _maxQueueSize: number;\n  private readonly _scheduledDelayMillis: number;\n  private readonly _exportTimeoutMillis: number;\n\n  private _isExporting = false;\n  private _finishedSpans: ReadableSpan[] = [];\n  private _timer: NodeJS.Timeout | undefined;\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _droppedSpansCount: number = 0;\n\n  constructor(\n    private readonly _exporter: SpanExporter,\n    config?: T\n  ) {\n    const env = getEnv();\n    this._maxExportBatchSize =\n      typeof config?.maxExportBatchSize === 'number'\n        ? config.maxExportBatchSize\n        : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n    this._maxQueueSize =\n      typeof config?.maxQueueSize === 'number'\n        ? config.maxQueueSize\n        : env.OTEL_BSP_MAX_QUEUE_SIZE;\n    this._scheduledDelayMillis =\n      typeof config?.scheduledDelayMillis === 'number'\n        ? config.scheduledDelayMillis\n        : env.OTEL_BSP_SCHEDULE_DELAY;\n    this._exportTimeoutMillis =\n      typeof config?.exportTimeoutMillis === 'number'\n        ? config.exportTimeoutMillis\n        : env.OTEL_BSP_EXPORT_TIMEOUT;\n\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn(\n        'BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'\n      );\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n\n  forceFlush(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  }\n\n  // does nothing.\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    this._addToBuffer(span);\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown() {\n    return Promise.resolve()\n      .then(() => {\n        return this.onShutdown();\n      })\n      .then(() => {\n        return this._flushAll();\n      })\n      .then(() => {\n        return this._exporter.shutdown();\n      });\n  }\n\n  /** Add a span in the buffer. */\n  private _addToBuffer(span: ReadableSpan) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n\n      if (this._droppedSpansCount === 0) {\n        diag.debug('maxQueueSize reached, dropping spans');\n      }\n      this._droppedSpansCount++;\n\n      return;\n    }\n\n    if (this._droppedSpansCount > 0) {\n      // some spans were dropped, log once with count of spans dropped\n      diag.warn(\n        `Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`\n      );\n      this._droppedSpansCount = 0;\n    }\n\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  }\n\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  private _flushAll(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      // calculate number of batches\n      const count = Math.ceil(\n        this._finishedSpans.length / this._maxExportBatchSize\n      );\n      for (let i = 0, j = count; i < j; i++) {\n        promises.push(this._flushOneBatch());\n      }\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n\n  private _flushOneBatch(): Promise<void> {\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, this._exportTimeoutMillis);\n      // prevent downstream exporter calls from generating spans\n      context.with(suppressTracing(context.active()), () => {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside the execution of this callback.\n        let spans: ReadableSpan[];\n        if (this._finishedSpans.length <= this._maxExportBatchSize) {\n          spans = this._finishedSpans;\n          this._finishedSpans = [];\n        } else {\n          spans = this._finishedSpans.splice(0, this._maxExportBatchSize);\n        }\n\n        const doExport = () =>\n          this._exporter.export(spans, result => {\n            clearTimeout(timer);\n            if (result.code === ExportResultCode.SUCCESS) {\n              resolve();\n            } else {\n              reject(\n                result.error ??\n                  new Error('BatchSpanProcessor: span export failed')\n              );\n            }\n          });\n\n        let pendingResources: Array<Promise<void>> | null = null;\n        for (let i = 0, len = spans.length; i < len; i++) {\n          const span = spans[i];\n          if (\n            span.resource.asyncAttributesPending &&\n            span.resource.waitForAsyncAttributes\n          ) {\n            pendingResources ??= [];\n            pendingResources.push(span.resource.waitForAsyncAttributes());\n          }\n        }\n\n        // Avoid scheduling a promise to make the behavior more predictable and easier to test\n        if (pendingResources === null) {\n          doExport();\n        } else {\n          Promise.all(pendingResources).then(doExport, err => {\n            globalErrorHandler(err);\n            reject(err);\n          });\n        }\n      });\n    });\n  }\n\n  private _maybeStartTimer() {\n    if (this._isExporting) return;\n    const flush = () => {\n      this._isExporting = true;\n      this._flushOneBatch()\n        .finally(() => {\n          this._isExporting = false;\n          if (this._finishedSpans.length > 0) {\n            this._clearTimer();\n            this._maybeStartTimer();\n          }\n        })\n        .catch(e => {\n          this._isExporting = false;\n          globalErrorHandler(e);\n        });\n    };\n    // we only wait if the queue doesn't have enough elements yet\n    if (this._finishedSpans.length >= this._maxExportBatchSize) {\n      return flush();\n    }\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  }\n\n  private _clearTimer() {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  }\n\n  protected abstract onShutdown(): void;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1453, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1458, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/platform/node/export/BatchSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BatchSpanProcessorBase } from '../../../export/BatchSpanProcessorBase';\nimport { BufferConfig } from '../../../types';\n\nexport class BatchSpanProcessor extends BatchSpanProcessorBase<BufferConfig> {\n  protected onShutdown(): void {}\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA,IAAA,qBAAA,SAAA,MAAA;IAAwC,UAAA,oBAAA;IAAxC,SAAA;;IAEA;IADY,mBAAA,SAAA,CAAA,UAAU,GAApB,YAA8B;IAChC,OAAA;AAAA,EAFwC,wUAAA,CAAA,yBAAsB"}},
    {"offset": {"line": 1508, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1513, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/BasicTracerProvider.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  context,\n  diag,\n  propagation,\n  TextMapPropagator,\n  trace,\n  TracerProvider,\n} from '@opentelemetry/api';\nimport {\n  CompositePropagator,\n  W3CBaggagePropagator,\n  W3CTraceContextPropagator,\n  getEnv,\n  merge,\n} from '@opentelemetry/core';\nimport { IResource, Resource } from '@opentelemetry/resources';\nimport { SpanProcessor } from './SpanProcessor';\nimport { Tracer } from './Tracer';\nimport { loadDefaultConfig } from './config';\nimport { MultiSpanProcessor } from './MultiSpanProcessor';\nimport { NoopSpanProcessor } from './export/NoopSpanProcessor';\nimport { SDKRegistrationConfig, TracerConfig } from './types';\nimport { SpanExporter } from './export/SpanExporter';\nimport { BatchSpanProcessor } from './platform';\nimport { reconfigureLimits } from './utility';\n\nexport type PROPAGATOR_FACTORY = () => TextMapPropagator;\nexport type EXPORTER_FACTORY = () => SpanExporter;\n\nexport enum ForceFlushState {\n  'resolved',\n  'timeout',\n  'error',\n  'unresolved',\n}\n\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\nexport class BasicTracerProvider implements TracerProvider {\n  protected static readonly _registeredPropagators = new Map<\n    string,\n    PROPAGATOR_FACTORY\n  >([\n    ['tracecontext', () => new W3CTraceContextPropagator()],\n    ['baggage', () => new W3CBaggagePropagator()],\n  ]);\n\n  protected static readonly _registeredExporters = new Map<\n    string,\n    EXPORTER_FACTORY\n  >();\n\n  private readonly _config: TracerConfig;\n  private readonly _registeredSpanProcessors: SpanProcessor[] = [];\n  private readonly _tracers: Map<string, Tracer> = new Map();\n\n  activeSpanProcessor: SpanProcessor;\n  readonly resource: IResource;\n\n  constructor(config: TracerConfig = {}) {\n    const mergedConfig = merge(\n      {},\n      loadDefaultConfig(),\n      reconfigureLimits(config)\n    );\n    this.resource = mergedConfig.resource ?? Resource.empty();\n\n    if (mergedConfig.mergeResourceWithDefaults) {\n      this.resource = Resource.default().merge(this.resource);\n    }\n\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this.resource,\n    });\n\n    if (config.spanProcessors?.length) {\n      this._registeredSpanProcessors = [...config.spanProcessors];\n      this.activeSpanProcessor = new MultiSpanProcessor(\n        this._registeredSpanProcessors\n      );\n    } else {\n      const defaultExporter = this._buildExporterFromEnv();\n      if (defaultExporter !== undefined) {\n        const batchProcessor = new BatchSpanProcessor(defaultExporter);\n        this.activeSpanProcessor = batchProcessor;\n      } else {\n        this.activeSpanProcessor = new NoopSpanProcessor();\n      }\n    }\n  }\n\n  getTracer(\n    name: string,\n    version?: string,\n    options?: { schemaUrl?: string }\n  ): Tracer {\n    const key = `${name}@${version || ''}:${options?.schemaUrl || ''}`;\n    if (!this._tracers.has(key)) {\n      this._tracers.set(\n        key,\n        new Tracer(\n          { name, version, schemaUrl: options?.schemaUrl },\n          this._config,\n          this\n        )\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tracers.get(key)!;\n  }\n\n  /**\n   * @deprecated please use {@link TracerConfig} spanProcessors property\n   * Adds a new {@link SpanProcessor} to this tracer.\n   * @param spanProcessor the new SpanProcessor to be added.\n   */\n  addSpanProcessor(spanProcessor: SpanProcessor): void {\n    if (this._registeredSpanProcessors.length === 0) {\n      // since we might have enabled by default a batchProcessor, we disable it\n      // before adding the new one\n      this.activeSpanProcessor\n        .shutdown()\n        .catch(err =>\n          diag.error(\n            'Error while trying to shutdown current span processor',\n            err\n          )\n        );\n    }\n    this._registeredSpanProcessors.push(spanProcessor);\n    this.activeSpanProcessor = new MultiSpanProcessor(\n      this._registeredSpanProcessors\n    );\n  }\n\n  getActiveSpanProcessor(): SpanProcessor {\n    return this.activeSpanProcessor;\n  }\n\n  /**\n   * Register this TracerProvider for use with the OpenTelemetry API.\n   * Undefined values may be replaced with defaults, and\n   * null values will be skipped.\n   *\n   * @param config Configuration object for SDK registration\n   */\n  register(config: SDKRegistrationConfig = {}): void {\n    trace.setGlobalTracerProvider(this);\n    if (config.propagator === undefined) {\n      config.propagator = this._buildPropagatorFromEnv();\n    }\n\n    if (config.contextManager) {\n      context.setGlobalContextManager(config.contextManager);\n    }\n\n    if (config.propagator) {\n      propagation.setGlobalPropagator(config.propagator);\n    }\n  }\n\n  forceFlush(): Promise<void> {\n    const timeout = this._config.forceFlushTimeoutMillis;\n    const promises = this._registeredSpanProcessors.map(\n      (spanProcessor: SpanProcessor) => {\n        return new Promise(resolve => {\n          let state: ForceFlushState;\n          const timeoutInterval = setTimeout(() => {\n            resolve(\n              new Error(\n                `Span processor did not completed within timeout period of ${timeout} ms`\n              )\n            );\n            state = ForceFlushState.timeout;\n          }, timeout);\n\n          spanProcessor\n            .forceFlush()\n            .then(() => {\n              clearTimeout(timeoutInterval);\n              if (state !== ForceFlushState.timeout) {\n                state = ForceFlushState.resolved;\n                resolve(state);\n              }\n            })\n            .catch(error => {\n              clearTimeout(timeoutInterval);\n              state = ForceFlushState.error;\n              resolve(error);\n            });\n        });\n      }\n    );\n\n    return new Promise<void>((resolve, reject) => {\n      Promise.all(promises)\n        .then(results => {\n          const errors = results.filter(\n            result => result !== ForceFlushState.resolved\n          );\n          if (errors.length > 0) {\n            reject(errors);\n          } else {\n            resolve();\n          }\n        })\n        .catch(error => reject([error]));\n    });\n  }\n\n  shutdown(): Promise<void> {\n    return this.activeSpanProcessor.shutdown();\n  }\n\n  /**\n   * TS cannot yet infer the type of this.constructor:\n   * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146\n   * There is no need to override either of the getters in your child class.\n   * The type of the registered component maps should be the same across all\n   * classes in the inheritance tree.\n   */\n  protected _getPropagator(name: string): TextMapPropagator | undefined {\n    return (\n      this.constructor as typeof BasicTracerProvider\n    )._registeredPropagators.get(name)?.();\n  }\n\n  protected _getSpanExporter(name: string): SpanExporter | undefined {\n    return (\n      this.constructor as typeof BasicTracerProvider\n    )._registeredExporters.get(name)?.();\n  }\n\n  protected _buildPropagatorFromEnv(): TextMapPropagator | undefined {\n    // per spec, propagators from env must be deduplicated\n    const uniquePropagatorNames = Array.from(\n      new Set(getEnv().OTEL_PROPAGATORS)\n    );\n\n    const propagators = uniquePropagatorNames.map(name => {\n      const propagator = this._getPropagator(name);\n      if (!propagator) {\n        diag.warn(\n          `Propagator \"${name}\" requested through environment variable is unavailable.`\n        );\n      }\n\n      return propagator;\n    });\n    const validPropagators = propagators.reduce<TextMapPropagator[]>(\n      (list, item) => {\n        if (item) {\n          list.push(item);\n        }\n        return list;\n      },\n      []\n    );\n\n    if (validPropagators.length === 0) {\n      return;\n    } else if (uniquePropagatorNames.length === 1) {\n      return validPropagators[0];\n    } else {\n      return new CompositePropagator({\n        propagators: validPropagators,\n      });\n    }\n  }\n\n  protected _buildExporterFromEnv(): SpanExporter | undefined {\n    const exporterName = getEnv().OTEL_TRACES_EXPORTER;\n    if (exporterName === 'none' || exporterName === '') return;\n    const exporter = this._getSpanExporter(exporterName);\n    if (!exporter) {\n      diag.error(\n        `Exporter \"${exporterName}\" requested through environment variable is unavailable.`\n      );\n    }\n    return exporter;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1782, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1787, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/ConsoleSpanExporter.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanExporter } from './SpanExporter';\nimport { ReadableSpan } from './ReadableSpan';\nimport {\n  ExportResult,\n  ExportResultCode,\n  hrTimeToMicroseconds,\n} from '@opentelemetry/core';\n\n/**\n * This is implementation of {@link SpanExporter} that prints spans to the\n * console. This class can be used for diagnostic purposes.\n *\n * NOTE: This {@link SpanExporter} is intended for diagnostics use only, output rendered to the console may change at any time.\n */\n\n/* eslint-disable no-console */\nexport class ConsoleSpanExporter implements SpanExporter {\n  /**\n   * Export spans.\n   * @param spans\n   * @param resultCallback\n   */\n  export(\n    spans: ReadableSpan[],\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    return this._sendSpans(spans, resultCallback);\n  }\n\n  /**\n   * Shutdown the exporter.\n   */\n  shutdown(): Promise<void> {\n    this._sendSpans([]);\n    return this.forceFlush();\n  }\n\n  /**\n   * Exports any pending spans in exporter\n   */\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  /**\n   * converts span info into more readable format\n   * @param span\n   */\n  private _exportInfo(span: ReadableSpan) {\n    return {\n      resource: {\n        attributes: span.resource.attributes,\n      },\n      instrumentationScope: span.instrumentationLibrary,\n      traceId: span.spanContext().traceId,\n      parentId: span.parentSpanId,\n      traceState: span.spanContext().traceState?.serialize(),\n      name: span.name,\n      id: span.spanContext().spanId,\n      kind: span.kind,\n      timestamp: hrTimeToMicroseconds(span.startTime),\n      duration: hrTimeToMicroseconds(span.duration),\n      attributes: span.attributes,\n      status: span.status,\n      events: span.events,\n      links: span.links,\n    };\n  }\n\n  /**\n   * Showing spans in console\n   * @param spans\n   * @param done\n   */\n  private _sendSpans(\n    spans: ReadableSpan[],\n    done?: (result: ExportResult) => void\n  ): void {\n    for (const span of spans) {\n      console.dir(this._exportInfo(span), { depth: 3 });\n    }\n    if (done) {\n      return done({ code: ExportResultCode.SUCCESS });\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;IAOA,6BAAA,GACA,IAAA,sBAAA;IAAA,SAAA,uBAqEA;IApEE;;;;QAKA,oBAAA,SAAA,CAAA,MAAM,GAAN,SACE,KAAqB,EACrB,cAA8C;QAE9C,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO;IAChC;IAEA;;QAGA,oBAAA,SAAA,CAAA,QAAQ,GAAR;QACE,IAAI,CAAC,UAAU,CAAC,EAAE;QAClB,OAAO,IAAI,CAAC,UAAU;IACxB;IAEA;;QAGA,oBAAA,SAAA,CAAA,UAAU,GAAV;QACE,OAAO,QAAQ,OAAO;IACxB;IAEA;;;QAIQ,oBAAA,SAAA,CAAA,WAAW,GAAnB,SAAoB,IAAkB;;QACpC,OAAO;YACL,UAAU;gBACR,YAAY,KAAK,QAAQ,CAAC,UAAU;;YAEtC,sBAAsB,KAAK,sBAAsB;YACjD,SAAS,KAAK,WAAW,GAAG,OAAO;YACnC,UAAU,KAAK,YAAY;YAC3B,YAAY,CAAA,KAAA,KAAK,WAAW,GAAG,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,SAAS;YACpD,MAAM,KAAK,IAAI;YACf,IAAI,KAAK,WAAW,GAAG,MAAM;YAC7B,MAAM,KAAK,IAAI;YACf,WAAW,CAAA,GAAA,sRAAA,CAAA,uBAAoB,AAApB,EAAqB,KAAK,SAAS;YAC9C,UAAU,CAAA,GAAA,sRAAA,CAAA,uBAAoB,AAApB,EAAqB,KAAK,QAAQ;YAC5C,YAAY,KAAK,UAAU;YAC3B,QAAQ,KAAK,MAAM;YACnB,QAAQ,KAAK,MAAM;YACnB,OAAO,KAAK,KAAK;;IAErB;IAEA;;;;QAKQ,oBAAA,SAAA,CAAA,UAAU,GAAlB,SACE,KAAqB,EACrB,IAAqC;;;YAErC,IAAmB,IAAA,UAAA,SAAA,QAAK,YAAA,QAAA,IAAA,IAAA,CAAA,UAAA,IAAA,EAAA,YAAA,QAAA,IAAA,GAAE;gBAArB,IAAM,OAAI,UAAA,KAAA;gBACb,QAAQ,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO;oBAAE,OAAO;gBAAC;;;;;;;;;;;;;QAEhD,IAAI,MAAM;YACR,OAAO,KAAK;gBAAE,MAAM,oRAAA,CAAA,mBAAgB,CAAC,OAAO;YAAA;;IAEhD;IACF,OAAA;AAAA"}},
    {"offset": {"line": 1905, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1910, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/InMemorySpanExporter.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanExporter } from './SpanExporter';\nimport { ReadableSpan } from './ReadableSpan';\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core';\n\n/**\n * This class can be used for testing purposes. It stores the exported spans\n * in a list in memory that can be retrieved using the `getFinishedSpans()`\n * method.\n */\nexport class InMemorySpanExporter implements SpanExporter {\n  private _finishedSpans: ReadableSpan[] = [];\n  /**\n   * Indicates if the exporter has been \"shutdown.\"\n   * When false, exported spans will not be stored in-memory.\n   */\n  protected _stopped = false;\n\n  export(\n    spans: ReadableSpan[],\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    if (this._stopped)\n      return resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Exporter has been stopped'),\n      });\n    this._finishedSpans.push(...spans);\n\n    setTimeout(() => resultCallback({ code: ExportResultCode.SUCCESS }), 0);\n  }\n\n  shutdown(): Promise<void> {\n    this._stopped = true;\n    this._finishedSpans = [];\n    return this.forceFlush();\n  }\n\n  /**\n   * Exports any pending spans in the exporter\n   */\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  reset(): void {\n    this._finishedSpans = [];\n  }\n\n  getFinishedSpans(): ReadableSpan[] {\n    return this._finishedSpans;\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;IAKA,IAAA,uBAAA;IAAA,SAAA;QACU,IAAA,CAAA,cAAc,GAAmB,EAAE;QAC3C;;;YAIU,IAAA,CAAA,QAAQ,GAAG;IAoCvB;IAlCE,qBAAA,SAAA,CAAA,MAAM,GAAN,SACE,KAAqB,EACrB,cAA8C;;QAE9C,IAAI,IAAI,CAAC,QAAQ,EACf,OAAO,eAAe;YACpB,MAAM,oRAAA,CAAA,mBAAgB,CAAC,MAAM;YAC7B,OAAO,IAAI,MAAM;;QAErB,CAAA,KAAA,IAAI,CAAC,cAAc,EAAC,IAAI,CAAA,KAAA,CAAA,IAAA,cAAA,EAAA,EAAA,OAAI,QAAK;QAEjC,WAAW;YAAM,OAAA,eAAe;gBAAE,MAAM,oRAAA,CAAA,mBAAgB,CAAC,OAAO;YAAA;QAA/C,GAAoD;IACvE;IAEA,qBAAA,SAAA,CAAA,QAAQ,GAAR;QACE,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,cAAc,GAAG,EAAE;QACxB,OAAO,IAAI,CAAC,UAAU;IACxB;IAEA;;QAGA,qBAAA,SAAA,CAAA,UAAU,GAAV;QACE,OAAO,QAAQ,OAAO;IACxB;IAEA,qBAAA,SAAA,CAAA,KAAK,GAAL;QACE,IAAI,CAAC,cAAc,GAAG,EAAE;IAC1B;IAEA,qBAAA,SAAA,CAAA,gBAAgB,GAAhB;QACE,OAAO,IAAI,CAAC,cAAc;IAC5B;IACF,OAAA;AAAA"}},
    {"offset": {"line": 2003, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2008, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/SimpleSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, TraceFlags } from '@opentelemetry/api';\nimport {\n  internal,\n  ExportResultCode,\n  globalErrorHandler,\n  BindOnceFuture,\n  ExportResult,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\nimport { Resource } from '@opentelemetry/resources';\n\n/**\n * An implementation of the {@link SpanProcessor} that converts the {@link Span}\n * to {@link ReadableSpan} and passes it to the configured exporter.\n *\n * Only spans that are sampled are converted.\n *\n * NOTE: This {@link SpanProcessor} exports every ended span individually instead of batching spans together, which causes significant performance overhead with most exporters. For production use, please consider using the {@link BatchSpanProcessor} instead.\n */\nexport class SimpleSpanProcessor implements SpanProcessor {\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _unresolvedExports: Set<Promise<void>>;\n\n  constructor(private readonly _exporter: SpanExporter) {\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    this._unresolvedExports = new Set<Promise<void>>();\n  }\n\n  async forceFlush(): Promise<void> {\n    // await unresolved resources before resolving\n    await Promise.all(Array.from(this._unresolvedExports));\n    if (this._exporter.forceFlush) {\n      await this._exporter.forceFlush();\n    }\n  }\n\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    const doExport = () =>\n      internal\n        ._export(this._exporter, [span])\n        .then((result: ExportResult) => {\n          if (result.code !== ExportResultCode.SUCCESS) {\n            globalErrorHandler(\n              result.error ??\n                new Error(\n                  `SimpleSpanProcessor: span export failed (status ${result})`\n                )\n            );\n          }\n        })\n        .catch(error => {\n          globalErrorHandler(error);\n        });\n\n    // Avoid scheduling a promise to make the behavior more predictable and easier to test\n    if (span.resource.asyncAttributesPending) {\n      const exportPromise = (span.resource as Resource)\n        .waitForAsyncAttributes?.()\n        .then(\n          () => {\n            if (exportPromise != null) {\n              this._unresolvedExports.delete(exportPromise);\n            }\n            return doExport();\n          },\n          err => globalErrorHandler(err)\n        );\n\n      // store the unresolved exports\n      if (exportPromise != null) {\n        this._unresolvedExports.add(exportPromise);\n      }\n    } else {\n      void doExport();\n    }\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown(): Promise<void> {\n    return this._exporter.shutdown();\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;;;;;;IAQA,IAAA,sBAAA;IAIE,SAAA,oBAA6B,SAAuB;QAAvB,IAAA,CAAA,SAAS,GAAT;QAC3B,IAAI,CAAC,aAAa,GAAG,IAAI,yRAAA,CAAA,iBAAc,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI;QAC5D,IAAI,CAAC,kBAAkB,GAAG,IAAI;IAChC;IAEM,oBAAA,SAAA,CAAA,UAAU,GAAhB;;;;;wBACE,8CAA8C;wBAC9C,OAAA;4BAAA,EAAA,OAAA;4BAAM,QAAQ,GAAG,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,kBAAkB;yBAAE;;wBADtD,8CAA8C;wBAC9C,GAAA,IAAA;6BACI,IAAI,CAAC,SAAS,CAAC,UAAU,EAAzB,OAAA;4BAAA,EAAA,OAAA;4BAAA;yBAAA;wBACF,OAAA;4BAAA,EAAA,OAAA;4BAAM,IAAI,CAAC,SAAS,CAAC,UAAU;yBAAE;;wBAAjC,GAAA,IAAA;;;;;;;;;;IAIJ,oBAAA,SAAA,CAAA,OAAO,GAAP,SAAQ,KAAW,EAAE,cAAuB,GAAS;IAErD,oBAAA,SAAA,CAAA,KAAK,GAAL,SAAM,IAAkB;QAAxB,IAAA,QAAA,IAAA;;QACE,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE;YAC/B;;QAGF,IAAI,CAAC,KAAK,WAAW,GAAG,UAAU,GAAG,2DAAA,CAAA,aAAU,CAAC,OAAO,MAAM,GAAG;YAC9D;;QAGF,IAAM,WAAW;YACf,OAAA,6RAAA,CAAA,WAAQ,CACL,OAAO,CAAC,MAAK,SAAS,EAAE;gBAAC;aAAK,EAC9B,IAAI,CAAC,SAAC,MAAoB;;gBACzB,IAAI,OAAO,IAAI,KAAK,oRAAA,CAAA,mBAAgB,CAAC,OAAO,EAAE;oBAC5C,CAAA,GAAA,4SAAA,CAAA,qBAAkB,AAAlB,EACE,CAAA,KAAA,OAAO,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KACV,IAAI,MACF,qDAAmD,SAAM;;YAInE,GACC,KAAK,CAAC,SAAA,KAAK;gBACV,CAAA,GAAA,4SAAA,CAAA,qBAAkB,AAAlB,EAAmB;YACrB;QAdF;QAgBF,sFAAsF;QACtF,IAAI,KAAK,QAAQ,CAAC,sBAAsB,EAAE;YACxC,IAAM,kBAAgB,CAAA,KAAA,CAAA,KAAC,KAAK,QAAqB,EAC9C,sBAAsB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAA,IAAA,CAAA,IACtB,IAAI,CACH;gBACE,IAAI,mBAAiB,MAAM;oBACzB,MAAK,kBAAkB,CAAC,MAAM,CAAC;;gBAEjC,OAAO;YACT,GACA,SAAA,GAAG;gBAAI,OAAA,CAAA,GAAA,4SAAA,CAAA,qBAAkB,AAAlB,EAAmB;YAAnB;YAGX,+BAA+B;YAC/B,IAAI,mBAAiB,MAAM;gBACzB,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC;;eAEzB;YACL,KAAK;;IAET;IAEA,oBAAA,SAAA,CAAA,QAAQ,GAAR;QACE,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI;IAChC;IAEQ,oBAAA,SAAA,CAAA,SAAS,GAAjB;QACE,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ;IAChC;IACF,OAAA;AAAA"}},
    {"offset": {"line": 2250, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2318, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/index.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport { BasicTracerProvider } from './BasicTracerProvider';\nexport { BatchSpanProcessor, RandomIdGenerator } from './platform';\nexport { ConsoleSpanExporter } from './export/ConsoleSpanExporter';\nexport { InMemorySpanExporter } from './export/InMemorySpanExporter';\nexport { ReadableSpan } from './export/ReadableSpan';\nexport { SimpleSpanProcessor } from './export/SimpleSpanProcessor';\nexport { SpanExporter } from './export/SpanExporter';\nexport { NoopSpanProcessor } from './export/NoopSpanProcessor';\nexport { AlwaysOffSampler } from './sampler/AlwaysOffSampler';\nexport { AlwaysOnSampler } from './sampler/AlwaysOnSampler';\nexport { ParentBasedSampler } from './sampler/ParentBasedSampler';\nexport { TraceIdRatioBasedSampler } from './sampler/TraceIdRatioBasedSampler';\nexport { Sampler, SamplingDecision, SamplingResult } from './Sampler';\nexport { Span } from './Span';\nexport { SpanProcessor } from './SpanProcessor';\nexport { TimedEvent } from './TimedEvent';\nexport {\n  BatchSpanProcessorBrowserConfig,\n  BufferConfig,\n  GeneralLimits,\n  SDKRegistrationConfig,\n  SpanLimits,\n  TracerConfig,\n} from './types';\nexport { IdGenerator } from './IdGenerator';\n"],"names":[],"mappings":"AAAA"}},
    {"offset": {"line": 2345, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2358, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/Sampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  Link,\n  Attributes,\n  SpanKind,\n  TraceState,\n} from '@opentelemetry/api';\n\n/**\n * A sampling decision that determines how a {@link Span} will be recorded\n * and collected.\n */\nexport enum SamplingDecision {\n  /**\n   * `Span.isRecording() === false`, span will not be recorded and all events\n   * and attributes will be dropped.\n   */\n  NOT_RECORD,\n  /**\n   * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}\n   * MUST NOT be set.\n   */\n  RECORD,\n  /**\n   * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}\n   * MUST be set.\n   */\n  RECORD_AND_SAMPLED,\n}\n\n/**\n * A sampling result contains a decision for a {@link Span} and additional\n * attributes the sampler would like to added to the Span.\n */\nexport interface SamplingResult {\n  /**\n   * A sampling decision, refer to {@link SamplingDecision} for details.\n   */\n  decision: SamplingDecision;\n  /**\n   * The list of attributes returned by SamplingResult MUST be immutable.\n   * Caller may call {@link Sampler}.shouldSample any number of times and\n   * can safely cache the returned value.\n   */\n  attributes?: Readonly<Attributes>;\n  /**\n   * A {@link TraceState} that will be associated with the {@link Span} through\n   * the new {@link SpanContext}. Samplers SHOULD return the TraceState from\n   * the passed-in {@link Context} if they do not intend to change it. Leaving\n   * the value undefined will also leave the TraceState unchanged.\n   */\n  traceState?: TraceState;\n}\n\n/**\n * This interface represent a sampler. Sampling is a mechanism to control the\n * noise and overhead introduced by OpenTelemetry by reducing the number of\n * samples of traces collected and sent to the backend.\n */\nexport interface Sampler {\n  /**\n   * Checks whether span needs to be created and tracked.\n   *\n   * @param context Parent Context which may contain a span.\n   * @param traceId of the span to be created. It can be different from the\n   *     traceId in the {@link SpanContext}. Typically in situations when the\n   *     span to be created starts a new trace.\n   * @param spanName of the span to be created.\n   * @param spanKind of the span to be created.\n   * @param attributes Initial set of Attributes for the Span being constructed.\n   * @param links Collection of links that will be associated with the Span to\n   *     be created. Typically useful for batch operations.\n   * @returns a {@link SamplingResult}.\n   */\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: Attributes,\n    links: Link[]\n  ): SamplingResult;\n\n  /** Returns the sampler name or short description with the configuration. */\n  toString(): string;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;IAwBA;;;;;;AAIA,IAAY;AAAZ,CAAA,SAAY,gBAAgB;IAC1B;;;QAIA,gBAAA,CAAA,gBAAA,CAAA,aAAA,GAAA,EAAA,GAAA;IACA;;;QAIA,gBAAA,CAAA,gBAAA,CAAA,SAAA,GAAA,EAAA,GAAA;IACA;;;QAIA,gBAAA,CAAA,gBAAA,CAAA,qBAAA,GAAA,EAAA,GAAA;AACF,CAAC,EAhBW,oBAAgB,CAAhB,mBAAgB,CAAA,CAAA"}},
    {"offset": {"line": 2393, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2398, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/AlwaysOffSampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples no traces. */\nexport class AlwaysOffSampler implements Sampler {\n  shouldSample(): SamplingResult {\n    return {\n      decision: SamplingDecision.NOT_RECORD,\n    };\n  }\n\n  toString(): string {\n    return 'AlwaysOffSampler';\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAmBM,MAAO;IACX,eAAY;QACV,OAAO;YACL,UAAU,8SAAA,CAAA,mBAAgB,CAAC,UAAU;;IAEzC;IAEA,WAAQ;QACN,OAAO;IACT"}},
    {"offset": {"line": 2428, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2433, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/AlwaysOnSampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples all traces. */\nexport class AlwaysOnSampler implements Sampler {\n  shouldSample(): SamplingResult {\n    return {\n      decision: SamplingDecision.RECORD_AND_SAMPLED,\n    };\n  }\n\n  toString(): string {\n    return 'AlwaysOnSampler';\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAmBM,MAAO;IACX,eAAY;QACV,OAAO;YACL,UAAU,8SAAA,CAAA,mBAAgB,CAAC,kBAAkB;;IAEjD;IAEA,WAAQ;QACN,OAAO;IACT"}},
    {"offset": {"line": 2463, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2468, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/enums.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Event name definitions\nexport const ExceptionEventName = 'exception';\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;IAgBA,yBAAyB;;;;AAClB,MAAM,qBAAqB"}},
    {"offset": {"line": 2487, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2492, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/Span.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  diag,\n  Exception,\n  HrTime,\n  Link,\n  Span as APISpan,\n  Attributes,\n  AttributeValue,\n  SpanContext,\n  SpanKind,\n  SpanStatus,\n  SpanStatusCode,\n  TimeInput,\n} from '@opentelemetry/api';\nimport {\n  addHrTimes,\n  millisToHrTime,\n  getTimeOrigin,\n  hrTime,\n  hrTimeDuration,\n  InstrumentationScope,\n  isAttributeValue,\n  isTimeInput,\n  isTimeInputHrTime,\n  otperformance,\n  sanitizeAttributes,\n} from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport {\n  ATTR_EXCEPTION_MESSAGE,\n  ATTR_EXCEPTION_STACKTRACE,\n  ATTR_EXCEPTION_TYPE,\n} from '@opentelemetry/semantic-conventions';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { ExceptionEventName } from './enums';\nimport { SpanProcessor } from './SpanProcessor';\nimport { TimedEvent } from './TimedEvent';\nimport { SpanLimits } from './types';\n\n/**\n * This type provides the properties of @link{ReadableSpan} at the same time\n * of the Span API\n */\nexport type Span = APISpan & ReadableSpan;\n\ninterface SpanOptions {\n  resource: Resource;\n  scope: InstrumentationScope;\n  context: Context;\n  spanContext: SpanContext;\n  name: string;\n  kind: SpanKind;\n  parentSpanContext?: SpanContext;\n  links?: Link[];\n  startTime?: TimeInput;\n  attributes?: Attributes;\n  spanLimits: SpanLimits;\n  spanProcessor: SpanProcessor;\n}\n\n/**\n * This class represents a span.\n */\nexport class SpanImpl implements Span {\n  // Below properties are included to implement ReadableSpan for export\n  // purposes but are not intended to be written-to directly.\n  private readonly _spanContext: SpanContext;\n  readonly kind: SpanKind;\n  readonly parentSpanContext?: SpanContext;\n  readonly attributes: Attributes = {};\n  readonly links: Link[] = [];\n  readonly events: TimedEvent[] = [];\n  readonly startTime: HrTime;\n  readonly resource: Resource;\n  readonly instrumentationScope: InstrumentationScope;\n\n  private _droppedAttributesCount = 0;\n  private _droppedEventsCount: number = 0;\n  private _droppedLinksCount: number = 0;\n\n  name: string;\n  status: SpanStatus = {\n    code: SpanStatusCode.UNSET,\n  };\n  endTime: HrTime = [0, 0];\n  private _ended = false;\n  private _duration: HrTime = [-1, -1];\n  private readonly _spanProcessor: SpanProcessor;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _attributeValueLengthLimit: number;\n\n  private readonly _performanceStartTime: number;\n  private readonly _performanceOffset: number;\n  private readonly _startTimeProvided: boolean;\n\n  /**\n   * Constructs a new SpanImpl instance.\n   */\n  constructor(opts: SpanOptions) {\n    const now = Date.now();\n\n    this._spanContext = opts.spanContext;\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset =\n      now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = opts.startTime != null;\n    this._spanLimits = opts.spanLimits;\n    this._attributeValueLengthLimit =\n      this._spanLimits.attributeValueLengthLimit || 0;\n    this._spanProcessor = opts.spanProcessor;\n\n    this.name = opts.name;\n    this.parentSpanContext = opts.parentSpanContext;\n    this.kind = opts.kind;\n    this.links = opts.links || [];\n    this.startTime = this._getTime(opts.startTime ?? now);\n    this.resource = opts.resource;\n    this.instrumentationScope = opts.scope;\n\n    if (opts.attributes != null) {\n      this.setAttributes(opts.attributes);\n    }\n\n    this._spanProcessor.onStart(this, opts.context);\n  }\n\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  setAttribute(key: string, value?: AttributeValue): this;\n  setAttribute(key: string, value: unknown): this {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n\n    const { attributeCountLimit } = this._spanLimits;\n\n    if (\n      attributeCountLimit !== undefined &&\n      Object.keys(this.attributes).length >= attributeCountLimit &&\n      !Object.prototype.hasOwnProperty.call(this.attributes, key)\n    ) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  }\n\n  setAttributes(attributes: Attributes): this {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  addEvent(\n    name: string,\n    attributesOrStartTime?: Attributes | TimeInput,\n    timeStamp?: TimeInput\n  ): this {\n    if (this._isSpanEnded()) return this;\n\n    const { eventCountLimit } = this._spanLimits;\n\n    if (eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n\n    if (\n      eventCountLimit !== undefined &&\n      this.events.length >= eventCountLimit\n    ) {\n      if (this._droppedEventsCount === 0) {\n        diag.debug('Dropping extra events.');\n      }\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n\n    const attributes = sanitizeAttributes(attributesOrStartTime);\n\n    this.events.push({\n      name,\n      attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0,\n    });\n    return this;\n  }\n\n  addLink(link: Link): this {\n    this.links.push(link);\n    return this;\n  }\n\n  addLinks(links: Link[]): this {\n    this.links.push(...links);\n    return this;\n  }\n\n  setStatus(status: SpanStatus): this {\n    if (this._isSpanEnded()) return this;\n    this.status = { ...status };\n\n    // When using try-catch, the caught \"error\" is of type `any`. When then assigning `any` to `status.message`,\n    // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()\n    // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or\n    // undefined to avoid an incorrect type causing issues downstream.\n    if (this.status.message != null && typeof status.message !== 'string') {\n      diag.warn(\n        `Dropping invalid status.message of type '${typeof status.message}', expected 'string'`\n      );\n      delete this.status.message;\n    }\n\n    return this;\n  }\n\n  updateName(name: string): this {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  }\n\n  end(endTime?: TimeInput): void {\n    if (this._isSpanEnded()) {\n      diag.error(\n        `${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`\n      );\n      return;\n    }\n    this._ended = true;\n\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n\n    if (this._duration[0] < 0) {\n      diag.warn(\n        'Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.',\n        this.startTime,\n        this.endTime\n      );\n      this.endTime = this.startTime.slice() as HrTime;\n      this._duration = [0, 0];\n    }\n\n    if (this._droppedEventsCount > 0) {\n      diag.warn(\n        `Dropped ${this._droppedEventsCount} events because eventCountLimit reached`\n      );\n    }\n\n    this._spanProcessor.onEnd(this);\n  }\n\n  private _getTime(inp?: TimeInput): HrTime {\n    if (typeof inp === 'number' && inp <= otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n\n    const msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  }\n\n  isRecording(): boolean {\n    return this._ended === false;\n  }\n\n  recordException(exception: Exception, time?: TimeInput): void {\n    const attributes: Attributes = {};\n    if (typeof exception === 'string') {\n      attributes[ATTR_EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[ATTR_EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[ATTR_EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[ATTR_EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[ATTR_EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n\n    // these are minimum requirements from spec\n    if (attributes[ATTR_EXCEPTION_TYPE] || attributes[ATTR_EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(`Failed to record an exception ${exception}`);\n    }\n  }\n\n  get duration(): HrTime {\n    return this._duration;\n  }\n\n  get ended(): boolean {\n    return this._ended;\n  }\n\n  get droppedAttributesCount(): number {\n    return this._droppedAttributesCount;\n  }\n\n  get droppedEventsCount(): number {\n    return this._droppedEventsCount;\n  }\n\n  get droppedLinksCount(): number {\n    return this._droppedLinksCount;\n  }\n\n  private _isSpanEnded(): boolean {\n    if (this._ended) {\n      const error = new Error(\n        `Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`\n      );\n\n      diag.warn(\n        `Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`,\n        error\n      );\n    }\n    return this._ended;\n  }\n\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  private _truncateToLimitUtil(value: string, limit: number): string {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substring(0, limit);\n  }\n\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with truncated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  private _truncateToSize(value: AttributeValue): AttributeValue {\n    const limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n\n    // Array of strings\n    if (Array.isArray(value)) {\n      return (value as []).map(val =>\n        typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val\n      );\n    }\n\n    // Other types, no need to apply value length limit\n    return value;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2801, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2806, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/ParentBasedSampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  isSpanContextValid,\n  Link,\n  Attributes,\n  SpanKind,\n  TraceFlags,\n  trace,\n} from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { AlwaysOffSampler } from './AlwaysOffSampler';\nimport { AlwaysOnSampler } from './AlwaysOnSampler';\nimport { Sampler, SamplingResult } from '../Sampler';\n\n/**\n * A composite sampler that either respects the parent span's sampling decision\n * or delegates to `delegateSampler` for root spans.\n */\nexport class ParentBasedSampler implements Sampler {\n  private _root: Sampler;\n  private _remoteParentSampled: Sampler;\n  private _remoteParentNotSampled: Sampler;\n  private _localParentSampled: Sampler;\n  private _localParentNotSampled: Sampler;\n\n  constructor(config: ParentBasedSamplerConfig) {\n    this._root = config.root;\n\n    if (!this._root) {\n      globalErrorHandler(\n        new Error('ParentBasedSampler must have a root sampler configured')\n      );\n      this._root = new AlwaysOnSampler();\n    }\n\n    this._remoteParentSampled =\n      config.remoteParentSampled ?? new AlwaysOnSampler();\n    this._remoteParentNotSampled =\n      config.remoteParentNotSampled ?? new AlwaysOffSampler();\n    this._localParentSampled =\n      config.localParentSampled ?? new AlwaysOnSampler();\n    this._localParentNotSampled =\n      config.localParentNotSampled ?? new AlwaysOffSampler();\n  }\n\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: Attributes,\n    links: Link[]\n  ): SamplingResult {\n    const parentContext = trace.getSpanContext(context);\n\n    if (!parentContext || !isSpanContextValid(parentContext)) {\n      return this._root.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.isRemote) {\n      if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n        return this._remoteParentSampled.shouldSample(\n          context,\n          traceId,\n          spanName,\n          spanKind,\n          attributes,\n          links\n        );\n      }\n      return this._remoteParentNotSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n      return this._localParentSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    return this._localParentNotSampled.shouldSample(\n      context,\n      traceId,\n      spanName,\n      spanKind,\n      attributes,\n      links\n    );\n  }\n\n  toString(): string {\n    return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;\n  }\n}\n\ninterface ParentBasedSamplerConfig {\n  /** Sampler called for spans with no parent */\n  root: Sampler;\n  /** Sampler called for spans with a remote parent which was sampled. Default AlwaysOn */\n  remoteParentSampled?: Sampler;\n  /** Sampler called for spans with a remote parent which was not sampled. Default AlwaysOff */\n  remoteParentNotSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was sampled. Default AlwaysOn */\n  localParentSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was not sampled. Default AlwaysOff */\n  localParentNotSampled?: Sampler;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCM,MAAO;IACH,MAAe;IACf,qBAA8B;IAC9B,wBAAiC;IACjC,oBAA6B;IAC7B,uBAAgC;IAExC,YAAY,MAAgC,CAAA;QAC1C,IAAI,CAAC,KAAK,GAAG,OAAO,IAAI;QAExB,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACf,CAAA,GAAA,2SAAA,CAAA,qBAAkB,AAAlB,EACE,IAAI,MAAM;YAEZ,IAAI,CAAC,KAAK,GAAG,IAAI,iUAAA,CAAA,kBAAe;;QAGlC,IAAI,CAAC,oBAAoB,GACvB,OAAO,mBAAmB,IAAI,IAAI,iUAAA,CAAA,kBAAe;QACnD,IAAI,CAAC,uBAAuB,GAC1B,OAAO,sBAAsB,IAAI,IAAI,kUAAA,CAAA,mBAAgB;QACvD,IAAI,CAAC,mBAAmB,GACtB,OAAO,kBAAkB,IAAI,IAAI,iUAAA,CAAA,kBAAe;QAClD,IAAI,CAAC,sBAAsB,GACzB,OAAO,qBAAqB,IAAI,IAAI,kUAAA,CAAA,mBAAgB;IACxD;IAEA,aACE,OAAgB,EAChB,OAAe,EACf,QAAgB,EAChB,QAAkB,EAClB,UAAsB,EACtB,KAAa,EAAA;QAEb,MAAM,gBAAgB,2DAAA,CAAA,QAAK,CAAC,cAAc,CAAC;QAE3C,IAAI,CAAC,iBAAiB,CAAC,CAAA,GAAA,2DAAA,CAAA,qBAAkB,AAAlB,EAAmB,gBAAgB;YACxD,OAAO,IAAI,CAAC,KAAK,CAAC,YAAY,CAC5B,SACA,SACA,UACA,UACA,YACA;;QAIJ,IAAI,cAAc,QAAQ,EAAE;YAC1B,IAAI,cAAc,UAAU,GAAG,2DAAA,CAAA,aAAU,CAAC,OAAO,EAAE;gBACjD,OAAO,IAAI,CAAC,oBAAoB,CAAC,YAAY,CAC3C,SACA,SACA,UACA,UACA,YACA;;YAGJ,OAAO,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAC9C,SACA,SACA,UACA,UACA,YACA;;QAIJ,IAAI,cAAc,UAAU,GAAG,2DAAA,CAAA,aAAU,CAAC,OAAO,EAAE;YACjD,OAAO,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAC1C,SACA,SACA,UACA,UACA,YACA;;QAIJ,OAAO,IAAI,CAAC,sBAAsB,CAAC,YAAY,CAC7C,SACA,SACA,UACA,UACA,YACA;IAEJ;IAEA,WAAQ;QACN,OAAO,CAAA,iBAAA,EAAoB,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAE,sBAAA,EAAyB,IAAI,CAAC,oBAAoB,CAAC,QAAQ,GAAE,yBAAA,EAA4B,IAAI,CAAC,uBAAuB,CAAC,QAAQ,GAAE,qBAAA,EAAwB,IAAI,CAAC,mBAAmB,CAAC,QAAQ,GAAE,wBAAA,EAA2B,IAAI,CAAC,sBAAsB,CAAC,QAAQ,GAAE,CAAA,CAAG;IACjT"}},
    {"offset": {"line": 2869, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2874, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/TraceIdRatioBasedSampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isValidTraceId } from '@opentelemetry/api';\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples a given fraction of traces based of trace id deterministically. */\nexport class TraceIdRatioBasedSampler implements Sampler {\n  private _upperBound: number;\n\n  constructor(private readonly _ratio: number = 0) {\n    this._ratio = this._normalize(_ratio);\n    this._upperBound = Math.floor(this._ratio * 0xffffffff);\n  }\n\n  shouldSample(context: unknown, traceId: string): SamplingResult {\n    return {\n      decision:\n        isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound\n          ? SamplingDecision.RECORD_AND_SAMPLED\n          : SamplingDecision.NOT_RECORD,\n    };\n  }\n\n  toString(): string {\n    return `TraceIdRatioBased{${this._ratio}}`;\n  }\n\n  private _normalize(ratio: number): number {\n    if (typeof ratio !== 'number' || isNaN(ratio)) return 0;\n    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n  }\n\n  private _accumulate(traceId: string): number {\n    let accumulation = 0;\n    for (let i = 0; i < traceId.length / 8; i++) {\n      const pos = i * 8;\n      const part = parseInt(traceId.slice(pos, pos + 8), 16);\n      accumulation = (accumulation ^ part) >>> 0;\n    }\n    return accumulation;\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;AAoBM,MAAO;IAGkB,OAAA;IAFrB,YAAoB;IAE5B,YAA6B,SAAiB,CAAC,CAAA;QAAlB,IAAA,CAAA,MAAM,GAAN;QAC3B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC;QAC9B,IAAI,CAAC,WAAW,GAAG,KAAK,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG;IAC9C;IAEA,aAAa,OAAgB,EAAE,OAAe,EAAA;QAC5C,OAAO;YACL,UACE,CAAA,GAAA,2DAAA,CAAA,iBAAc,AAAd,EAAe,YAAY,IAAI,CAAC,WAAW,CAAC,WAAW,IAAI,CAAC,WAAW,GACnE,8SAAA,CAAA,mBAAgB,CAAC,kBAAkB,GACnC,8SAAA,CAAA,mBAAgB,CAAC,UAAU;;IAErC;IAEA,WAAQ;QACN,OAAO,CAAA,kBAAA,EAAqB,IAAI,CAAC,MAAM,CAAA,CAAA,CAAG;IAC5C;IAEQ,WAAW,KAAa,EAAA;QAC9B,IAAI,OAAO,UAAU,YAAY,MAAM,QAAQ,OAAO;QACtD,OAAO,SAAS,IAAI,IAAI,SAAS,IAAI,IAAI;IAC3C;IAEQ,YAAY,OAAe,EAAA;QACjC,IAAI,eAAe;QACnB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,GAAG,GAAG,IAAK;YAC3C,MAAM,MAAM,IAAI;YAChB,MAAM,OAAO,SAAS,QAAQ,KAAK,CAAC,KAAK,MAAM,IAAI;YACnD,eAAe,CAAC,eAAe,IAAI,MAAM;;QAE3C,OAAO;IACT"}},
    {"offset": {"line": 2926, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2931, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/config.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\nimport { getNumberFromEnv, getStringFromEnv } from '@opentelemetry/core';\nimport { Sampler } from './Sampler';\nimport { AlwaysOffSampler } from './sampler/AlwaysOffSampler';\nimport { AlwaysOnSampler } from './sampler/AlwaysOnSampler';\nimport { ParentBasedSampler } from './sampler/ParentBasedSampler';\nimport { TraceIdRatioBasedSampler } from './sampler/TraceIdRatioBasedSampler';\n\nconst enum TracesSamplerValues {\n  AlwaysOff = 'always_off',\n  AlwaysOn = 'always_on',\n  ParentBasedAlwaysOff = 'parentbased_always_off',\n  ParentBasedAlwaysOn = 'parentbased_always_on',\n  ParentBasedTraceIdRatio = 'parentbased_traceidratio',\n  TraceIdRatio = 'traceidratio',\n}\n\nconst DEFAULT_RATIO = 1;\n\n/**\n * Load default configuration. For fields with primitive values, any user-provided\n * value will override the corresponding default value. For fields with\n * non-primitive values (like `spanLimits`), the user-provided value will be\n * used to extend the default value.\n */\n\n// object needs to be wrapped in this function and called when needed otherwise\n// envs are parsed before tests are ran - causes tests using these envs to fail\nexport function loadDefaultConfig() {\n  return {\n    sampler: buildSamplerFromEnv(),\n    forceFlushTimeoutMillis: 30000,\n    generalLimits: {\n      attributeValueLengthLimit:\n        getNumberFromEnv('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT') ?? Infinity,\n      attributeCountLimit:\n        getNumberFromEnv('OTEL_ATTRIBUTE_COUNT_LIMIT') ?? 128,\n    },\n    spanLimits: {\n      attributeValueLengthLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT') ?? Infinity,\n      attributeCountLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT') ?? 128,\n      linkCountLimit: getNumberFromEnv('OTEL_SPAN_LINK_COUNT_LIMIT') ?? 128,\n      eventCountLimit: getNumberFromEnv('OTEL_SPAN_EVENT_COUNT_LIMIT') ?? 128,\n      attributePerEventCountLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT') ?? 128,\n      attributePerLinkCountLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT') ?? 128,\n    },\n  };\n}\n\n/**\n * Based on environment, builds a sampler, complies with specification.\n */\nexport function buildSamplerFromEnv(): Sampler {\n  const sampler =\n    getStringFromEnv('OTEL_TRACES_SAMPLER') ??\n    TracesSamplerValues.ParentBasedAlwaysOn;\n  switch (sampler) {\n    case TracesSamplerValues.AlwaysOn:\n      return new AlwaysOnSampler();\n    case TracesSamplerValues.AlwaysOff:\n      return new AlwaysOffSampler();\n    case TracesSamplerValues.ParentBasedAlwaysOn:\n      return new ParentBasedSampler({\n        root: new AlwaysOnSampler(),\n      });\n    case TracesSamplerValues.ParentBasedAlwaysOff:\n      return new ParentBasedSampler({\n        root: new AlwaysOffSampler(),\n      });\n    case TracesSamplerValues.TraceIdRatio:\n      return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv());\n    case TracesSamplerValues.ParentBasedTraceIdRatio:\n      return new ParentBasedSampler({\n        root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv()),\n      });\n    default:\n      diag.error(\n        `OTEL_TRACES_SAMPLER value \"${sampler}\" invalid, defaulting to \"${TracesSamplerValues.ParentBasedAlwaysOn}\".`\n      );\n      return new ParentBasedSampler({\n        root: new AlwaysOnSampler(),\n      });\n  }\n}\n\nfunction getSamplerProbabilityFromEnv(): number | undefined {\n  const probability = getNumberFromEnv('OTEL_TRACES_SAMPLER_ARG');\n  if (probability == null) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  if (probability < 0 || probability > 1) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG=${probability} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  return probability;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,MAAM,gBAAgB;AAWhB,SAAU;IACd,OAAO;QACL,SAAS;QACT,yBAAyB;QACzB,eAAe;YACb,2BACE,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,wCAAwC;YAC3D,qBACE,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,iCAAiC;;QAEtD,YAAY;YACV,2BACE,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,6CAA6C;YAChE,qBACE,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,sCAAsC;YACzD,gBAAgB,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,iCAAiC;YAClE,iBAAiB,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,kCAAkC;YACpE,6BACE,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,gDAAgD;YACnE,4BACE,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,+CAA+C;;;AAGxE;AAKM,SAAU;IACd,MAAM,UACJ,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB;IAEnB,OAAQ;QACN,KAAA,YAAA,gCAAA;YACE,OAAO,IAAI,iUAAA,CAAA,kBAAe;QAC5B,KAAA,aAAA,iCAAA;YACE,OAAO,IAAI,kUAAA,CAAA,mBAAgB;QAC7B,KAAA,wBAAA,2CAAA;YACE,OAAO,IAAI,oUAAA,CAAA,qBAAkB,CAAC;gBAC5B,MAAM,IAAI,iUAAA,CAAA,kBAAe;;QAE7B,KAAA,yBAAA,4CAAA;YACE,OAAO,IAAI,oUAAA,CAAA,qBAAkB,CAAC;gBAC5B,MAAM,IAAI,kUAAA,CAAA,mBAAgB;;QAE9B,KAAA,eAAA,oCAAA;YACE,OAAO,IAAI,0UAAA,CAAA,2BAAwB,CAAC;QACtC,KAAA,2BAAA,+CAAA;YACE,OAAO,IAAI,oUAAA,CAAA,qBAAkB,CAAC;gBAC5B,MAAM,IAAI,0UAAA,CAAA,2BAAwB,CAAC;;QAEvC;YACE,2DAAA,CAAA,OAAI,CAAC,KAAK,CACR,CAAA,2BAAA,EAA8B,QAAO,0BAAA,EAA6B,wBAAA,2CAAA,IAAuC,EAAA,CAAI;YAE/G,OAAO,IAAI,oUAAA,CAAA,qBAAkB,CAAC;gBAC5B,MAAM,IAAI,iUAAA,CAAA,kBAAe;;;AAGjC;AAEA,SAAS;IACP,MAAM,cAAc,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB;IACrC,IAAI,eAAe,MAAM;QACvB,2DAAA,CAAA,OAAI,CAAC,KAAK,CACR,CAAA,gDAAA,EAAmD,cAAa,CAAA,CAAG;QAErE,OAAO;;IAGT,IAAI,cAAc,KAAK,cAAc,GAAG;QACtC,2DAAA,CAAA,OAAI,CAAC,KAAK,CACR,CAAA,wBAAA,EAA2B,YAAW,2DAAA,EAA8D,cAAa,CAAA,CAAG;QAEtH,OAAO;;IAGT,OAAO;AACT"}},
    {"offset": {"line": 3021, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3026, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/utility.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { buildSamplerFromEnv, loadDefaultConfig } from './config';\nimport { Sampler } from './Sampler';\nimport { SpanLimits, TracerConfig, GeneralLimits } from './types';\nimport { getNumberFromEnv } from '@opentelemetry/core';\n\nexport const DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;\nexport const DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;\n\n/**\n * Function to merge Default configuration (as specified in './config') with\n * user provided configurations.\n */\nexport function mergeConfig(userConfig: TracerConfig): TracerConfig & {\n  sampler: Sampler;\n  spanLimits: SpanLimits;\n  generalLimits: GeneralLimits;\n} {\n  const perInstanceDefaults: Partial<TracerConfig> = {\n    sampler: buildSamplerFromEnv(),\n  };\n\n  const DEFAULT_CONFIG = loadDefaultConfig();\n\n  const target = Object.assign(\n    {},\n    DEFAULT_CONFIG,\n    perInstanceDefaults,\n    userConfig\n  );\n\n  target.generalLimits = Object.assign(\n    {},\n    DEFAULT_CONFIG.generalLimits,\n    userConfig.generalLimits || {}\n  );\n\n  target.spanLimits = Object.assign(\n    {},\n    DEFAULT_CONFIG.spanLimits,\n    userConfig.spanLimits || {}\n  );\n\n  return target;\n}\n\n/**\n * When general limits are provided and model specific limits are not,\n * configures the model specific limits by using the values from the general ones.\n * @param userConfig User provided tracer configuration\n */\nexport function reconfigureLimits(userConfig: TracerConfig): TracerConfig {\n  const spanLimits = Object.assign({}, userConfig.spanLimits);\n\n  /**\n   * Reassign span attribute count limit to use first non null value defined by user or use default value\n   */\n  spanLimits.attributeCountLimit =\n    userConfig.spanLimits?.attributeCountLimit ??\n    userConfig.generalLimits?.attributeCountLimit ??\n    getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT') ??\n    getNumberFromEnv('OTEL_ATTRIBUTE_COUNT_LIMIT') ??\n    DEFAULT_ATTRIBUTE_COUNT_LIMIT;\n\n  /**\n   * Reassign span attribute value length limit to use first non null value defined by user or use default value\n   */\n  spanLimits.attributeValueLengthLimit =\n    userConfig.spanLimits?.attributeValueLengthLimit ??\n    userConfig.generalLimits?.attributeValueLengthLimit ??\n    getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n    getNumberFromEnv('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n    DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;\n\n  return Object.assign({}, userConfig, { spanLimits });\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAqBO,MAAM,gCAAgC;AACtC,MAAM,uCAAuC;AAM9C,SAAU,YAAY,UAAwB;IAKlD,MAAM,sBAA6C;QACjD,SAAS,CAAA,GAAA,6SAAA,CAAA,sBAAmB,AAAnB;;IAGX,MAAM,iBAAiB,CAAA,GAAA,6SAAA,CAAA,oBAAiB,AAAjB;IAEvB,MAAM,SAAS,OAAO,MAAM,CAC1B,CAAA,GACA,gBACA,qBACA;IAGF,OAAO,aAAa,GAAG,OAAO,MAAM,CAClC,CAAA,GACA,eAAe,aAAa,EAC5B,WAAW,aAAa,IAAI,CAAA;IAG9B,OAAO,UAAU,GAAG,OAAO,MAAM,CAC/B,CAAA,GACA,eAAe,UAAU,EACzB,WAAW,UAAU,IAAI,CAAA;IAG3B,OAAO;AACT;AAOM,SAAU,kBAAkB,UAAwB;IACxD,MAAM,aAAa,OAAO,MAAM,CAAC,CAAA,GAAI,WAAW,UAAU;IAE1D;;QAGA,WAAW,mBAAmB,GAC5B,WAAW,UAAU,EAAE,uBACvB,WAAW,aAAa,EAAE,uBAC1B,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,sCACjB,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,iCACjB;IAEF;;QAGA,WAAW,yBAAyB,GAClC,WAAW,UAAU,EAAE,6BACvB,WAAW,aAAa,EAAE,6BAC1B,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,6CACjB,CAAA,GAAA,sSAAA,CAAA,mBAAgB,AAAhB,EAAiB,wCACjB;IAEF,OAAO,OAAO,MAAM,CAAC,CAAA,GAAI,YAAY;QAAE;IAAU;AACnD"}},
    {"offset": {"line": 3075, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3080, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/platform/node/RandomIdGenerator.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IdGenerator } from '../../IdGenerator';\n\nconst SPAN_ID_BYTES = 8;\nconst TRACE_ID_BYTES = 16;\n\nexport class RandomIdGenerator implements IdGenerator {\n  /**\n   * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex\n   * characters corresponding to 128 bits.\n   */\n  generateTraceId = getIdGenerator(TRACE_ID_BYTES);\n\n  /**\n   * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex\n   * characters corresponding to 64 bits.\n   */\n  generateSpanId = getIdGenerator(SPAN_ID_BYTES);\n}\n\nconst SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);\nfunction getIdGenerator(bytes: number): () => string {\n  return function generateId() {\n    for (let i = 0; i < bytes / 4; i++) {\n      // unsigned right shift drops decimal part of the number\n      // it is required because if a number between 2**32 and 2**32 - 1 is generated, an out of range error is thrown by writeUInt32BE\n      SHARED_BUFFER.writeUInt32BE((Math.random() * 2 ** 32) >>> 0, i * 4);\n    }\n\n    // If buffer is all 0, set the last byte to 1 to guarantee a valid w3c id is generated\n    for (let i = 0; i < bytes; i++) {\n      if (SHARED_BUFFER[i] > 0) {\n        break;\n      } else if (i === bytes - 1) {\n        SHARED_BUFFER[bytes - 1] = 1;\n      }\n    }\n\n    return SHARED_BUFFER.toString('hex', 0, bytes);\n  };\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAkBA,MAAM,gBAAgB;AACtB,MAAM,iBAAiB;AAEjB,MAAO;IACX;;;QAIA,kBAAkB,eAAe,gBAAgB;IAEjD;;;QAIA,iBAAiB,eAAe,eAAe;;AAGjD,MAAM,gBAAgB,OAAO,WAAW,CAAC;AACzC,SAAS,eAAe,KAAa;IACnC,OAAO,SAAS;QACd,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,GAAG,IAAK;YAClC,wDAAwD;YACxD,gIAAgI;YAChI,cAAc,aAAa,CAAC,AAAC,KAAK,MAAM,KAAK,KAAK,OAAQ,GAAG,IAAI;;QAGnE,sFAAsF;QACtF,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;YAC9B,IAAI,aAAa,CAAC,EAAE,GAAG,GAAG;gBACxB;mBACK,IAAI,MAAM,QAAQ,GAAG;gBAC1B,aAAa,CAAC,QAAQ,EAAE,GAAG;;;QAI/B,OAAO,cAAc,QAAQ,CAAC,OAAO,GAAG;IAC1C;AACF"}},
    {"offset": {"line": 3128, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3133, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/Tracer.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  InstrumentationScope,\n  sanitizeAttributes,\n  isTracingSuppressed,\n} from '@opentelemetry/core';\nimport { SpanImpl } from './Span';\nimport { GeneralLimits, SpanLimits, TracerConfig } from './types';\nimport { mergeConfig } from './utility';\nimport { SpanProcessor } from './SpanProcessor';\nimport { Sampler } from './Sampler';\nimport { IdGenerator } from './IdGenerator';\nimport { RandomIdGenerator } from './platform';\nimport { Resource } from '@opentelemetry/resources';\n\n/**\n * This class represents a basic tracer.\n */\nexport class Tracer implements api.Tracer {\n  private readonly _sampler: Sampler;\n  private readonly _generalLimits: GeneralLimits;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _idGenerator: IdGenerator;\n  readonly instrumentationScope: InstrumentationScope;\n\n  private readonly _resource: Resource;\n  private readonly _spanProcessor: SpanProcessor;\n\n  /**\n   * Constructs a new Tracer instance.\n   */\n  constructor(\n    instrumentationScope: InstrumentationScope,\n    config: TracerConfig,\n    resource: Resource,\n    spanProcessor: SpanProcessor\n  ) {\n    const localConfig = mergeConfig(config);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config.idGenerator || new RandomIdGenerator();\n    this._resource = resource;\n    this._spanProcessor = spanProcessor;\n    this.instrumentationScope = instrumentationScope;\n  }\n\n  /**\n   * Starts a new Span or returns the default NoopSpan based on the sampling\n   * decision.\n   */\n  startSpan(\n    name: string,\n    options: api.SpanOptions = {},\n    context = api.context.active()\n  ): api.Span {\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context);\n    }\n    const parentSpan = api.trace.getSpan(context);\n\n    if (isTracingSuppressed(context)) {\n      api.diag.debug('Instrumentation suppressed, returning Noop Span');\n      const nonRecordingSpan = api.trace.wrapSpanContext(\n        api.INVALID_SPAN_CONTEXT\n      );\n      return nonRecordingSpan;\n    }\n\n    const parentSpanContext = parentSpan?.spanContext();\n    const spanId = this._idGenerator.generateSpanId();\n    let validParentSpanContext;\n    let traceId;\n    let traceState;\n    if (\n      !parentSpanContext ||\n      !api.trace.isSpanContextValid(parentSpanContext)\n    ) {\n      // New root span.\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      // New child span.\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      validParentSpanContext = parentSpanContext;\n    }\n\n    const spanKind = options.kind ?? api.SpanKind.INTERNAL;\n    const links = (options.links ?? []).map(link => {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes),\n      };\n    });\n    const attributes = sanitizeAttributes(options.attributes);\n    // make sampling decision\n    const samplingResult = this._sampler.shouldSample(\n      context,\n      traceId,\n      name,\n      spanKind,\n      attributes,\n      links\n    );\n\n    traceState = samplingResult.traceState ?? traceState;\n\n    const traceFlags =\n      samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n        ? api.TraceFlags.SAMPLED\n        : api.TraceFlags.NONE;\n    const spanContext = { traceId, spanId, traceFlags, traceState };\n    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n      api.diag.debug(\n        'Recording is off, propagating context in a non-recording span'\n      );\n      const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);\n      return nonRecordingSpan;\n    }\n\n    // Set initial span attributes. The attributes object may have been mutated\n    // by the sampler, so we sanitize the merged attributes before setting them.\n    const initAttributes = sanitizeAttributes(\n      Object.assign(attributes, samplingResult.attributes)\n    );\n\n    const span = new SpanImpl({\n      resource: this._resource,\n      scope: this.instrumentationScope,\n      context,\n      spanContext,\n      name,\n      kind: spanKind,\n      links,\n      parentSpanContext: validParentSpanContext,\n      attributes: initAttributes,\n      startTime: options.startTime,\n      spanProcessor: this._spanProcessor,\n      spanLimits: this._spanLimits,\n    });\n    return span;\n  }\n\n  /**\n   * Starts a new {@link Span} and calls the given function passing it the\n   * created span as first argument.\n   * Additionally the new span gets set in context and this context is activated\n   * for the duration of the function call.\n   *\n   * @param name The name of the span\n   * @param [options] SpanOptions used for span creation\n   * @param [context] Context to use to extract parent\n   * @param fn function called in the context of the span and receives the newly created span as an argument\n   * @returns return value of fn\n   * @example\n   *   const something = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       span.setStatus({code: SpanStatusCode.OK});\n   *       return something;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     } finally {\n   *       span.end();\n   *     }\n   *   });\n   * @example\n   *   const span = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       return span;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     }\n   *   });\n   *   do some more work\n   *   span.end();\n   */\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    ctx: api.Context,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | api.SpanOptions,\n    arg3?: F | api.Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: api.SpanOptions | undefined;\n    let ctx: api.Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as api.SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as api.SpanOptions | undefined;\n      ctx = arg3 as api.Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? api.context.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = api.trace.setSpan(parentContext, span);\n\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  }\n\n  /** Returns the active {@link GeneralLimits}. */\n  getGeneralLimits(): GeneralLimits {\n    return this._generalLimits;\n  }\n\n  /** Returns the active {@link SpanLimits}. */\n  getSpanLimits(): SpanLimits {\n    return this._spanLimits;\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCM,MAAO;IACM,SAAkB;IAClB,eAA8B;IAC9B,YAAwB;IACxB,aAA0B;IAClC,qBAA2C;IAEnC,UAAoB;IACpB,eAA8B;IAE/C;;QAGA,YACE,oBAA0C,EAC1C,MAAoB,EACpB,QAAkB,EAClB,aAA4B,CAAA;QAE5B,MAAM,cAAc,CAAA,GAAA,8SAAA,CAAA,cAAW,AAAX,EAAY;QAChC,IAAI,CAAC,QAAQ,GAAG,YAAY,OAAO;QACnC,IAAI,CAAC,cAAc,GAAG,YAAY,aAAa;QAC/C,IAAI,CAAC,WAAW,GAAG,YAAY,UAAU;QACzC,IAAI,CAAC,YAAY,GAAG,OAAO,WAAW,IAAI,IAAI,4UAAA,CAAA,oBAAiB;QAC/D,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,oBAAoB,GAAG;IAC9B;IAEA;;;QAIA,UACE,IAAY,EACZ,UAA2B,CAAA,CAAE,EAC7B,UAAU,4DAAI,OAAO,CAAC,MAAM,EAAE,EAAA;QAE9B,wEAAwE;QACxE,IAAI,QAAQ,IAAI,EAAE;YAChB,UAAU,4DAAI,KAAK,CAAC,UAAU,CAAC;;QAEjC,MAAM,aAAa,4DAAI,KAAK,CAAC,OAAO,CAAC;QAErC,IAAI,CAAA,GAAA,mSAAA,CAAA,sBAAmB,AAAnB,EAAoB,UAAU;YAChC,4DAAI,IAAI,CAAC,KAAK,CAAC;YACf,MAAM,mBAAmB,4DAAI,KAAK,CAAC,eAAe,CAChD,4DAAI,oBAAoB;YAE1B,OAAO;;QAGT,MAAM,oBAAoB,YAAY;QACtC,MAAM,SAAS,IAAI,CAAC,YAAY,CAAC,cAAc;QAC/C,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IACE,CAAC,qBACD,CAAC,4DAAI,KAAK,CAAC,kBAAkB,CAAC,oBAC9B;YACA,iBAAiB;YACjB,UAAU,IAAI,CAAC,YAAY,CAAC,eAAe;eACtC;YACL,kBAAkB;YAClB,UAAU,kBAAkB,OAAO;YACnC,aAAa,kBAAkB,UAAU;YACzC,yBAAyB;;QAG3B,MAAM,WAAW,QAAQ,IAAI,IAAI,4DAAI,QAAQ,CAAC,QAAQ;QACtD,MAAM,QAAQ,CAAC,QAAQ,KAAK,IAAI,EAAE,EAAE,GAAG,CAAC,CAAA;YACtC,OAAO;gBACL,SAAS,KAAK,OAAO;gBACrB,YAAY,CAAA,GAAA,2RAAA,CAAA,qBAAkB,AAAlB,EAAmB,KAAK,UAAU;;QAElD;QACA,MAAM,aAAa,CAAA,GAAA,2RAAA,CAAA,qBAAkB,AAAlB,EAAmB,QAAQ,UAAU;QACxD,yBAAyB;QACzB,MAAM,iBAAiB,IAAI,CAAC,QAAQ,CAAC,YAAY,CAC/C,SACA,SACA,MACA,UACA,YACA;QAGF,aAAa,eAAe,UAAU,IAAI;QAE1C,MAAM,aACJ,eAAe,QAAQ,KAAK,4DAAI,gBAAgB,CAAC,kBAAkB,GAC/D,4DAAI,UAAU,CAAC,OAAO,GACtB,4DAAI,UAAU,CAAC,IAAI;QACzB,MAAM,cAAc;YAAE;YAAS;YAAQ;YAAY;QAAU;QAC7D,IAAI,eAAe,QAAQ,KAAK,4DAAI,gBAAgB,CAAC,UAAU,EAAE;YAC/D,4DAAI,IAAI,CAAC,KAAK,CACZ;YAEF,MAAM,mBAAmB,4DAAI,KAAK,CAAC,eAAe,CAAC;YACnD,OAAO;;QAGT,2EAA2E;QAC3E,4EAA4E;QAC5E,MAAM,iBAAiB,CAAA,GAAA,2RAAA,CAAA,qBAAkB,AAAlB,EACrB,OAAO,MAAM,CAAC,YAAY,eAAe,UAAU;QAGrD,MAAM,OAAO,IAAI,2SAAA,CAAA,WAAQ,CAAC;YACxB,UAAU,IAAI,CAAC,SAAS;YACxB,OAAO,IAAI,CAAC,oBAAoB;YAChC;YACA;YACA;YACA,MAAM;YACN;YACA,mBAAmB;YACnB,YAAY;YACZ,WAAW,QAAQ,SAAS;YAC5B,eAAe,IAAI,CAAC,cAAc;YAClC,YAAY,IAAI,CAAC,WAAW;;QAE9B,OAAO;IACT;IA4DA,gBACE,IAAY,EACZ,IAA0B,EAC1B,IAAsB,EACtB,IAAQ,EAAA;QAER,IAAI;QACJ,IAAI;QACJ,IAAI;QAEJ,IAAI,UAAU,MAAM,GAAG,GAAG;YACxB;eACK,IAAI,UAAU,MAAM,KAAK,GAAG;YACjC,KAAK;eACA,IAAI,UAAU,MAAM,KAAK,GAAG;YACjC,OAAO;YACP,KAAK;eACA;YACL,OAAO;YACP,MAAM;YACN,KAAK;;QAGP,MAAM,gBAAgB,OAAO,4DAAI,OAAO,CAAC,MAAM;QAC/C,MAAM,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,MAAM;QACxC,MAAM,qBAAqB,4DAAI,KAAK,CAAC,OAAO,CAAC,eAAe;QAE5D,OAAO,4DAAI,OAAO,CAAC,IAAI,CAAC,oBAAoB,IAAI,WAAW;IAC7D;IAEA,8CAAA,GACA,mBAAgB;QACd,OAAO,IAAI,CAAC,cAAc;IAC5B;IAEA,2CAAA,GACA,gBAAa;QACX,OAAO,IAAI,CAAC,WAAW;IACzB"}},
    {"offset": {"line": 3280, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3285, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/MultiSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { Span } from './Span';\nimport { SpanProcessor } from './SpanProcessor';\n\n/**\n * Implementation of the {@link SpanProcessor} that simply forwards all\n * received events to a list of {@link SpanProcessor}s.\n */\nexport class MultiSpanProcessor implements SpanProcessor {\n  constructor(private readonly _spanProcessors: SpanProcessor[]) {}\n\n  forceFlush(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.forceFlush());\n    }\n    return new Promise(resolve => {\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(error => {\n          globalErrorHandler(\n            error || new Error('MultiSpanProcessor: forceFlush failed')\n          );\n          resolve();\n        });\n    });\n  }\n\n  onStart(span: Span, context: Context): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onStart(span, context);\n    }\n  }\n\n  onEnd(span: ReadableSpan): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onEnd(span);\n    }\n  }\n\n  shutdown(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.shutdown());\n    }\n    return new Promise((resolve, reject) => {\n      Promise.all(promises).then(() => {\n        resolve();\n      }, reject);\n    });\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AA0BM,MAAO;IACkB,gBAAA;IAA7B,YAA6B,eAAgC,CAAA;QAAhC,IAAA,CAAA,eAAe,GAAf;IAAmC;IAEhE,aAAU;QACR,MAAM,WAA4B,EAAE;QAEpC,KAAK,MAAM,iBAAiB,IAAI,CAAC,eAAe,CAAE;YAChD,SAAS,IAAI,CAAC,cAAc,UAAU;;QAExC,OAAO,IAAI,QAAQ,CAAA;YACjB,QAAQ,GAAG,CAAC,UACT,IAAI,CAAC;gBACJ;YACF,GACC,KAAK,CAAC,CAAA;gBACL,CAAA,GAAA,2SAAA,CAAA,qBAAkB,AAAlB,EACE,SAAS,IAAI,MAAM;gBAErB;YACF;QACJ;IACF;IAEA,QAAQ,IAAU,EAAE,OAAgB,EAAA;QAClC,KAAK,MAAM,iBAAiB,IAAI,CAAC,eAAe,CAAE;YAChD,cAAc,OAAO,CAAC,MAAM;;IAEhC;IAEA,MAAM,IAAkB,EAAA;QACtB,KAAK,MAAM,iBAAiB,IAAI,CAAC,eAAe,CAAE;YAChD,cAAc,KAAK,CAAC;;IAExB;IAEA,WAAQ;QACN,MAAM,WAA4B,EAAE;QAEpC,KAAK,MAAM,iBAAiB,IAAI,CAAC,eAAe,CAAE;YAChD,SAAS,IAAI,CAAC,cAAc,QAAQ;;QAEtC,OAAO,IAAI,QAAQ,CAAC,SAAS;YAC3B,QAAQ,GAAG,CAAC,UAAU,IAAI,CAAC;gBACzB;YACF,GAAG;QACL;IACF"}},
    {"offset": {"line": 3346, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3351, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/BasicTracerProvider.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TracerProvider, Tracer as ApiTracer } from '@opentelemetry/api';\nimport { merge } from '@opentelemetry/core';\nimport { defaultResource, Resource } from '@opentelemetry/resources';\nimport { SpanProcessor } from './SpanProcessor';\nimport { Tracer } from './Tracer';\nimport { loadDefaultConfig } from './config';\nimport { MultiSpanProcessor } from './MultiSpanProcessor';\nimport { TracerConfig } from './types';\nimport { reconfigureLimits } from './utility';\n\nexport enum ForceFlushState {\n  'resolved',\n  'timeout',\n  'error',\n  'unresolved',\n}\n\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\nexport class BasicTracerProvider implements TracerProvider {\n  private readonly _config: TracerConfig;\n  private readonly _tracers: Map<string, Tracer> = new Map();\n  private readonly _resource: Resource;\n  private readonly _activeSpanProcessor: MultiSpanProcessor;\n\n  constructor(config: TracerConfig = {}) {\n    const mergedConfig = merge(\n      {},\n      loadDefaultConfig(),\n      reconfigureLimits(config)\n    );\n    this._resource = mergedConfig.resource ?? defaultResource();\n\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this._resource,\n    });\n\n    const spanProcessors: SpanProcessor[] = [];\n\n    if (config.spanProcessors?.length) {\n      spanProcessors.push(...config.spanProcessors);\n    }\n\n    this._activeSpanProcessor = new MultiSpanProcessor(spanProcessors);\n  }\n\n  getTracer(\n    name: string,\n    version?: string,\n    options?: { schemaUrl?: string }\n  ): ApiTracer {\n    const key = `${name}@${version || ''}:${options?.schemaUrl || ''}`;\n    if (!this._tracers.has(key)) {\n      this._tracers.set(\n        key,\n        new Tracer(\n          { name, version, schemaUrl: options?.schemaUrl },\n          this._config,\n          this._resource,\n          this._activeSpanProcessor\n        )\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tracers.get(key)!;\n  }\n\n  forceFlush(): Promise<void> {\n    const timeout = this._config.forceFlushTimeoutMillis;\n    const promises = this._activeSpanProcessor['_spanProcessors'].map(\n      (spanProcessor: SpanProcessor) => {\n        return new Promise(resolve => {\n          let state: ForceFlushState;\n          const timeoutInterval = setTimeout(() => {\n            resolve(\n              new Error(\n                `Span processor did not completed within timeout period of ${timeout} ms`\n              )\n            );\n            state = ForceFlushState.timeout;\n          }, timeout);\n\n          spanProcessor\n            .forceFlush()\n            .then(() => {\n              clearTimeout(timeoutInterval);\n              if (state !== ForceFlushState.timeout) {\n                state = ForceFlushState.resolved;\n                resolve(state);\n              }\n            })\n            .catch(error => {\n              clearTimeout(timeoutInterval);\n              state = ForceFlushState.error;\n              resolve(error);\n            });\n        });\n      }\n    );\n\n    return new Promise<void>((resolve, reject) => {\n      Promise.all(promises)\n        .then(results => {\n          const errors = results.filter(\n            result => result !== ForceFlushState.resolved\n          );\n          if (errors.length > 0) {\n            reject(errors);\n          } else {\n            resolve();\n          }\n        })\n        .catch(error => reject([error]));\n    });\n  }\n\n  shutdown(): Promise<void> {\n    return this._activeSpanProcessor.shutdown();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3457, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3462, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/BatchSpanProcessorBase.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { context, Context, diag, TraceFlags } from '@opentelemetry/api';\nimport {\n  BindOnceFuture,\n  ExportResultCode,\n  getNumberFromEnv,\n  globalErrorHandler,\n  suppressTracing,\n  unrefTimer,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { BufferConfig } from '../types';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\n\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nexport abstract class BatchSpanProcessorBase<T extends BufferConfig>\n  implements SpanProcessor\n{\n  private readonly _maxExportBatchSize: number;\n  private readonly _maxQueueSize: number;\n  private readonly _scheduledDelayMillis: number;\n  private readonly _exportTimeoutMillis: number;\n\n  private _isExporting = false;\n  private _finishedSpans: ReadableSpan[] = [];\n  private _timer: NodeJS.Timeout | undefined;\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _droppedSpansCount: number = 0;\n\n  constructor(\n    private readonly _exporter: SpanExporter,\n    config?: T\n  ) {\n    this._maxExportBatchSize =\n      typeof config?.maxExportBatchSize === 'number'\n        ? config.maxExportBatchSize\n        : (getNumberFromEnv('OTEL_BSP_MAX_EXPORT_BATCH_SIZE') ?? 512);\n    this._maxQueueSize =\n      typeof config?.maxQueueSize === 'number'\n        ? config.maxQueueSize\n        : (getNumberFromEnv('OTEL_BSP_MAX_QUEUE_SIZE') ?? 2048);\n    this._scheduledDelayMillis =\n      typeof config?.scheduledDelayMillis === 'number'\n        ? config.scheduledDelayMillis\n        : (getNumberFromEnv('OTEL_BSP_SCHEDULE_DELAY') ?? 5000);\n    this._exportTimeoutMillis =\n      typeof config?.exportTimeoutMillis === 'number'\n        ? config.exportTimeoutMillis\n        : (getNumberFromEnv('OTEL_BSP_EXPORT_TIMEOUT') ?? 30000);\n\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn(\n        'BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'\n      );\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n\n  forceFlush(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  }\n\n  // does nothing.\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    this._addToBuffer(span);\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown() {\n    return Promise.resolve()\n      .then(() => {\n        return this.onShutdown();\n      })\n      .then(() => {\n        return this._flushAll();\n      })\n      .then(() => {\n        return this._exporter.shutdown();\n      });\n  }\n\n  /** Add a span in the buffer. */\n  private _addToBuffer(span: ReadableSpan) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n\n      if (this._droppedSpansCount === 0) {\n        diag.debug('maxQueueSize reached, dropping spans');\n      }\n      this._droppedSpansCount++;\n\n      return;\n    }\n\n    if (this._droppedSpansCount > 0) {\n      // some spans were dropped, log once with count of spans dropped\n      diag.warn(\n        `Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`\n      );\n      this._droppedSpansCount = 0;\n    }\n\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  }\n\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  private _flushAll(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      // calculate number of batches\n      const count = Math.ceil(\n        this._finishedSpans.length / this._maxExportBatchSize\n      );\n      for (let i = 0, j = count; i < j; i++) {\n        promises.push(this._flushOneBatch());\n      }\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n\n  private _flushOneBatch(): Promise<void> {\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, this._exportTimeoutMillis);\n      // prevent downstream exporter calls from generating spans\n      context.with(suppressTracing(context.active()), () => {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside the execution of this callback.\n        let spans: ReadableSpan[];\n        if (this._finishedSpans.length <= this._maxExportBatchSize) {\n          spans = this._finishedSpans;\n          this._finishedSpans = [];\n        } else {\n          spans = this._finishedSpans.splice(0, this._maxExportBatchSize);\n        }\n\n        const doExport = () =>\n          this._exporter.export(spans, result => {\n            clearTimeout(timer);\n            if (result.code === ExportResultCode.SUCCESS) {\n              resolve();\n            } else {\n              reject(\n                result.error ??\n                  new Error('BatchSpanProcessor: span export failed')\n              );\n            }\n          });\n\n        let pendingResources: Array<Promise<void>> | null = null;\n        for (let i = 0, len = spans.length; i < len; i++) {\n          const span = spans[i];\n          if (\n            span.resource.asyncAttributesPending &&\n            span.resource.waitForAsyncAttributes\n          ) {\n            pendingResources ??= [];\n            pendingResources.push(span.resource.waitForAsyncAttributes());\n          }\n        }\n\n        // Avoid scheduling a promise to make the behavior more predictable and easier to test\n        if (pendingResources === null) {\n          doExport();\n        } else {\n          Promise.all(pendingResources).then(doExport, err => {\n            globalErrorHandler(err);\n            reject(err);\n          });\n        }\n      });\n    });\n  }\n\n  private _maybeStartTimer() {\n    if (this._isExporting) return;\n    const flush = () => {\n      this._isExporting = true;\n      this._flushOneBatch()\n        .finally(() => {\n          this._isExporting = false;\n          if (this._finishedSpans.length > 0) {\n            this._clearTimer();\n            this._maybeStartTimer();\n          }\n        })\n        .catch(e => {\n          this._isExporting = false;\n          globalErrorHandler(e);\n        });\n    };\n    // we only wait if the queue doesn't have enough elements yet\n    if (this._finishedSpans.length >= this._maxExportBatchSize) {\n      return flush();\n    }\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  }\n\n  private _clearTimer() {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  }\n\n  protected abstract onShutdown(): void;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3655, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3660, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/platform/node/export/BatchSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BatchSpanProcessorBase } from '../../../export/BatchSpanProcessorBase';\nimport { BufferConfig } from '../../../types';\n\nexport class BatchSpanProcessor extends BatchSpanProcessorBase<BufferConfig> {\n  protected onShutdown(): void {}\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAmBM,MAAO,2BAA2B,uUAAA,CAAA,yBAAoC;IAChE,aAAU,CAAU"}},
    {"offset": {"line": 3683, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3688, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/ConsoleSpanExporter.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanExporter } from './SpanExporter';\nimport { ReadableSpan } from './ReadableSpan';\nimport {\n  ExportResult,\n  ExportResultCode,\n  hrTimeToMicroseconds,\n} from '@opentelemetry/core';\n\n/**\n * This is implementation of {@link SpanExporter} that prints spans to the\n * console. This class can be used for diagnostic purposes.\n *\n * NOTE: This {@link SpanExporter} is intended for diagnostics use only, output rendered to the console may change at any time.\n */\n\n/* eslint-disable no-console */\nexport class ConsoleSpanExporter implements SpanExporter {\n  /**\n   * Export spans.\n   * @param spans\n   * @param resultCallback\n   */\n  export(\n    spans: ReadableSpan[],\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    return this._sendSpans(spans, resultCallback);\n  }\n\n  /**\n   * Shutdown the exporter.\n   */\n  shutdown(): Promise<void> {\n    this._sendSpans([]);\n    return this.forceFlush();\n  }\n\n  /**\n   * Exports any pending spans in exporter\n   */\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  /**\n   * converts span info into more readable format\n   * @param span\n   */\n  private _exportInfo(span: ReadableSpan) {\n    return {\n      resource: {\n        attributes: span.resource.attributes,\n      },\n      instrumentationScope: span.instrumentationScope,\n      traceId: span.spanContext().traceId,\n      parentSpanContext: span.parentSpanContext,\n      traceState: span.spanContext().traceState?.serialize(),\n      name: span.name,\n      id: span.spanContext().spanId,\n      kind: span.kind,\n      timestamp: hrTimeToMicroseconds(span.startTime),\n      duration: hrTimeToMicroseconds(span.duration),\n      attributes: span.attributes,\n      status: span.status,\n      events: span.events,\n      links: span.links,\n    };\n  }\n\n  /**\n   * Showing spans in console\n   * @param spans\n   * @param done\n   */\n  private _sendSpans(\n    spans: ReadableSpan[],\n    done?: (result: ExportResult) => void\n  ): void {\n    for (const span of spans) {\n      console.dir(this._exportInfo(span), { depth: 3 });\n    }\n    if (done) {\n      return done({ code: ExportResultCode.SUCCESS });\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;AAgCM,MAAO;IACX;;;;QAKA,OACE,KAAqB,EACrB,cAA8C,EAAA;QAE9C,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO;IAChC;IAEA;;QAGA,WAAQ;QACN,IAAI,CAAC,UAAU,CAAC,EAAE;QAClB,OAAO,IAAI,CAAC,UAAU;IACxB;IAEA;;QAGA,aAAU;QACR,OAAO,QAAQ,OAAO;IACxB;IAEA;;;QAIQ,YAAY,IAAkB,EAAA;QACpC,OAAO;YACL,UAAU;gBACR,YAAY,KAAK,QAAQ,CAAC,UAAU;;YAEtC,sBAAsB,KAAK,oBAAoB;YAC/C,SAAS,KAAK,WAAW,GAAG,OAAO;YACnC,mBAAmB,KAAK,iBAAiB;YACzC,YAAY,KAAK,WAAW,GAAG,UAAU,EAAE;YAC3C,MAAM,KAAK,IAAI;YACf,IAAI,KAAK,WAAW,GAAG,MAAM;YAC7B,MAAM,KAAK,IAAI;YACf,WAAW,CAAA,GAAA,qRAAA,CAAA,uBAAoB,AAApB,EAAqB,KAAK,SAAS;YAC9C,UAAU,CAAA,GAAA,qRAAA,CAAA,uBAAoB,AAApB,EAAqB,KAAK,QAAQ;YAC5C,YAAY,KAAK,UAAU;YAC3B,QAAQ,KAAK,MAAM;YACnB,QAAQ,KAAK,MAAM;YACnB,OAAO,KAAK,KAAK;;IAErB;IAEA;;;;QAKQ,WACN,KAAqB,EACrB,IAAqC,EAAA;QAErC,KAAK,MAAM,QAAQ,MAAO;YACxB,QAAQ,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO;gBAAE,OAAO;YAAC;;QAEhD,IAAI,MAAM;YACR,OAAO,KAAK;gBAAE,MAAM,mRAAA,CAAA,mBAAgB,CAAC,OAAO;YAAA;;IAEhD"}},
    {"offset": {"line": 3768, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3773, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/InMemorySpanExporter.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanExporter } from './SpanExporter';\nimport { ReadableSpan } from './ReadableSpan';\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core';\n\n/**\n * This class can be used for testing purposes. It stores the exported spans\n * in a list in memory that can be retrieved using the `getFinishedSpans()`\n * method.\n */\nexport class InMemorySpanExporter implements SpanExporter {\n  private _finishedSpans: ReadableSpan[] = [];\n  /**\n   * Indicates if the exporter has been \"shutdown.\"\n   * When false, exported spans will not be stored in-memory.\n   */\n  protected _stopped = false;\n\n  export(\n    spans: ReadableSpan[],\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    if (this._stopped)\n      return resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Exporter has been stopped'),\n      });\n    this._finishedSpans.push(...spans);\n\n    setTimeout(() => resultCallback({ code: ExportResultCode.SUCCESS }), 0);\n  }\n\n  shutdown(): Promise<void> {\n    this._stopped = true;\n    this._finishedSpans = [];\n    return this.forceFlush();\n  }\n\n  /**\n   * Exports any pending spans in the exporter\n   */\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  reset(): void {\n    this._finishedSpans = [];\n  }\n\n  getFinishedSpans(): ReadableSpan[] {\n    return this._finishedSpans;\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAyBM,MAAO;IACH,iBAAiC,EAAE,CAAC;IAC5C;;;QAIU,WAAW,MAAM;IAE3B,OACE,KAAqB,EACrB,cAA8C,EAAA;QAE9C,IAAI,IAAI,CAAC,QAAQ,EACf,OAAO,eAAe;YACpB,MAAM,mRAAA,CAAA,mBAAgB,CAAC,MAAM;YAC7B,OAAO,IAAI,MAAM;;QAErB,IAAI,CAAC,cAAc,CAAC,IAAI,IAAI;QAE5B,WAAW,IAAM,eAAe;gBAAE,MAAM,mRAAA,CAAA,mBAAgB,CAAC,OAAO;YAAA,IAAK;IACvE;IAEA,WAAQ;QACN,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,cAAc,GAAG,EAAE;QACxB,OAAO,IAAI,CAAC,UAAU;IACxB;IAEA;;QAGA,aAAU;QACR,OAAO,QAAQ,OAAO;IACxB;IAEA,QAAK;QACH,IAAI,CAAC,cAAc,GAAG,EAAE;IAC1B;IAEA,mBAAgB;QACd,OAAO,IAAI,CAAC,cAAc;IAC5B"}},
    {"offset": {"line": 3826, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3831, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/NoopSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { ReadableSpan } from './ReadableSpan';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\n\n/** No-op implementation of SpanProcessor */\nexport class NoopSpanProcessor implements SpanProcessor {\n  onStart(_span: Span, _context: Context): void {}\n  onEnd(_span: ReadableSpan): void {}\n  shutdown(): Promise<void> {\n    return Promise.resolve();\n  }\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;IAqBA,0CAAA;;;AACM,MAAO;IACX,QAAQ,KAAW,EAAE,QAAiB,EAAA,CAAS;IAC/C,MAAM,KAAmB,EAAA,CAAS;IAClC,WAAQ;QACN,OAAO,QAAQ,OAAO;IACxB;IACA,aAAU;QACR,OAAO,QAAQ,OAAO;IACxB"}},
    {"offset": {"line": 3858, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3863, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@opentelemetry+sdk-trace-base@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/SimpleSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, TraceFlags } from '@opentelemetry/api';\nimport {\n  internal,\n  ExportResultCode,\n  globalErrorHandler,\n  BindOnceFuture,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\n\n/**\n * An implementation of the {@link SpanProcessor} that converts the {@link Span}\n * to {@link ReadableSpan} and passes it to the configured exporter.\n *\n * Only spans that are sampled are converted.\n *\n * NOTE: This {@link SpanProcessor} exports every ended span individually instead of batching spans together, which causes significant performance overhead with most exporters. For production use, please consider using the {@link BatchSpanProcessor} instead.\n */\nexport class SimpleSpanProcessor implements SpanProcessor {\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _pendingExports: Set<Promise<void>>;\n\n  constructor(private readonly _exporter: SpanExporter) {\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    this._pendingExports = new Set<Promise<void>>();\n  }\n\n  async forceFlush(): Promise<void> {\n    await Promise.all(Array.from(this._pendingExports));\n    if (this._exporter.forceFlush) {\n      await this._exporter.forceFlush();\n    }\n  }\n\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    const pendingExport = this._doExport(span).catch(err =>\n      globalErrorHandler(err)\n    );\n    // Enqueue this export to the pending list so it can be flushed by the user.\n    this._pendingExports.add(pendingExport);\n    pendingExport.finally(() => this._pendingExports.delete(pendingExport));\n  }\n\n  private async _doExport(span: ReadableSpan): Promise<void> {\n    if (span.resource.asyncAttributesPending) {\n      // Ensure resource is fully resolved before exporting.\n      await span.resource.waitForAsyncAttributes?.();\n    }\n\n    const result = await internal._export(this._exporter, [span]);\n    if (result.code !== ExportResultCode.SUCCESS) {\n      throw (\n        result.error ??\n        new Error(`SimpleSpanProcessor: span export failed (status ${result})`)\n      );\n    }\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown(): Promise<void> {\n    return this._exporter.shutdown();\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAoCM,MAAO;IAIkB,UAAA;IAHrB,cAAoC;IACpC,gBAAoC;IAE5C,YAA6B,SAAuB,CAAA;QAAvB,IAAA,CAAA,SAAS,GAAT;QAC3B,IAAI,CAAC,aAAa,GAAG,IAAI,wRAAA,CAAA,iBAAc,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI;QAC5D,IAAI,CAAC,eAAe,GAAG,IAAI;IAC7B;IAEA,MAAM,aAAU;QACd,MAAM,QAAQ,GAAG,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,eAAe;QACjD,IAAI,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE;YAC7B,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU;;IAEnC;IAEA,QAAQ,KAAW,EAAE,cAAuB,EAAA,CAAS;IAErD,MAAM,IAAkB,EAAA;QACtB,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE;YAC/B;;QAGF,IAAI,CAAC,KAAK,WAAW,GAAG,UAAU,GAAG,2DAAA,CAAA,aAAU,CAAC,OAAO,MAAM,GAAG;YAC9D;;QAGF,MAAM,gBAAgB,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,CAAA,MAC/C,CAAA,GAAA,2SAAA,CAAA,qBAAkB,AAAlB,EAAmB;QAErB,4EAA4E;QAC5E,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC;QACzB,cAAc,OAAO,CAAC,IAAM,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC;IAC1D;IAEQ,MAAM,UAAU,IAAkB,EAAA;QACxC,IAAI,KAAK,QAAQ,CAAC,sBAAsB,EAAE;YACxC,sDAAsD;YACtD,MAAM,KAAK,QAAQ,CAAC,sBAAsB;;QAG5C,MAAM,SAAS,MAAM,4RAAA,CAAA,WAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE;YAAC;SAAK;QAC5D,IAAI,OAAO,IAAI,KAAK,mRAAA,CAAA,mBAAgB,CAAC,OAAO,EAAE;YAC5C,MACE,OAAO,KAAK,IACZ,IAAI,MAAM,CAAA,gDAAA,EAAmD,OAAM,CAAA,CAAG;;IAG5E;IAEA,WAAQ;QACN,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI;IAChC;IAEQ,YAAS;QACf,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ;IAChC"}},
    {"offset": {"line": 3935, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}