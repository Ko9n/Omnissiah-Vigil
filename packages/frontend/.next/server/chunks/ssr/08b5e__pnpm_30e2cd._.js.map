{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/semanticAttributes.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/getParentSpanId.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/spanTypes.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/getRequestSpanData.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/custom/client.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/getSpanKind.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/constants.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/contextData.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/isSentryRequest.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/getSamplingDecision.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/parseSpanDescription.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/enhanceDscWithOpenTelemetryRootSpanName.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/getActiveSpan.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/debug-build.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/makeTraceState.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/setupCheck.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/propagator.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/trace.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/suppressTracing.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/setupEventContextTrace.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/getTraceData.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/asyncContextStrategy.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/contextManager.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/groupSpansWithParents.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/utils/mapStatus.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/spanExporter.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/spanProcessor.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@1.30_o5xloretc4oxncwjv67h3aqgxy/node_modules/@sentry/opentelemetry/src/sampler.ts"],"sourcesContent":["/** If this attribute is true, it means that the parent is a remote span. */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = 'sentry.parentIsRemote';\n\n// These are not standardized yet, but used by the graphql instrumentation\nexport const SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = 'sentry.graphql.operation';\n","import type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\n\n/**\n * Get the parent span id from a span.\n * In OTel v1, the parent span id is accessed as `parentSpanId`\n * In OTel v2, the parent span id is accessed as `spanId` on the `parentSpanContext`\n */\nexport function getParentSpanId(span: ReadableSpan): string | undefined {\n  if ('parentSpanId' in span) {\n    return span.parentSpanId as string | undefined;\n  } else if ('parentSpanContext' in span) {\n    return (span.parentSpanContext as { spanId?: string } | undefined)?.spanId;\n  }\n\n  return undefined;\n}\n","import type { SpanKind, SpanStatus } from '@opentelemetry/api';\nimport type { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base';\nimport type { AbstractSpan } from '../types';\nimport { getParentSpanId } from './getParentSpanId';\n\n/**\n * Check if a given span has attributes.\n * This is necessary because the base `Span` type does not have attributes,\n * so in places where we are passed a generic span, we need to check if we want to access them.\n */\nexport function spanHasAttributes<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { attributes: ReadableSpan['attributes'] } {\n  const castSpan = span as ReadableSpan;\n  return !!castSpan.attributes && typeof castSpan.attributes === 'object';\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasKind<SpanType extends AbstractSpan>(span: SpanType): span is SpanType & { kind: SpanKind } {\n  const castSpan = span as ReadableSpan;\n  return typeof castSpan.kind === 'number';\n}\n\n/**\n * Check if a given span has a status.\n * This is necessary because the base `Span` type does not have a status,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasStatus<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { status: SpanStatus } {\n  const castSpan = span as ReadableSpan;\n  return !!castSpan.status;\n}\n\n/**\n * Check if a given span has a name.\n * This is necessary because the base `Span` type does not have a name,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasName<SpanType extends AbstractSpan>(span: SpanType): span is SpanType & { name: string } {\n  const castSpan = span as ReadableSpan;\n  return !!castSpan.name;\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasParentId<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { parentSpanId: string } {\n  const castSpan = span as ReadableSpan;\n  return !!getParentSpanId(castSpan);\n}\n\n/**\n * Check if a given span has events.\n * This is necessary because the base `Span` type does not have events,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasEvents<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { events: TimedEvent[] } {\n  const castSpan = span as ReadableSpan;\n  return Array.isArray(castSpan.events);\n}\n","import type { Span } from '@opentelemetry/api';\nimport type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport {\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_URL_FULL,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_URL,\n} from '@opentelemetry/semantic-conventions';\nimport type { SanitizedRequestData } from '@sentry/core';\nimport { getSanitizedUrlString, parseUrl } from '@sentry/core';\nimport { spanHasAttributes } from './spanTypes';\n\n/**\n * Get sanitizied request data from an OTEL span.\n */\nexport function getRequestSpanData(span: Span | ReadableSpan): Partial<SanitizedRequestData> {\n  // The base `Span` type has no `attributes`, so we need to guard here against that\n  if (!spanHasAttributes(span)) {\n    return {};\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeUrlAttribute = (span.attributes[ATTR_URL_FULL] || span.attributes[SEMATTRS_HTTP_URL]) as\n    | string\n    | undefined;\n\n  const data: Partial<SanitizedRequestData> = {\n    url: maybeUrlAttribute,\n    // eslint-disable-next-line deprecation/deprecation\n    'http.method': (span.attributes[ATTR_HTTP_REQUEST_METHOD] || span.attributes[SEMATTRS_HTTP_METHOD]) as\n      | string\n      | undefined,\n  };\n\n  // Default to GET if URL is set but method is not\n  if (!data['http.method'] && data.url) {\n    data['http.method'] = 'GET';\n  }\n\n  try {\n    if (typeof maybeUrlAttribute === 'string') {\n      const url = parseUrl(maybeUrlAttribute);\n\n      data.url = getSanitizedUrlString(url);\n\n      if (url.search) {\n        data['http.query'] = url.search;\n      }\n      if (url.hash) {\n        data['http.fragment'] = url.hash;\n      }\n    }\n  } catch {\n    // ignore\n  }\n\n  return data;\n}\n","import type { Tracer } from '@opentelemetry/api';\nimport { trace } from '@opentelemetry/api';\nimport type { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport type { Client } from '@sentry/core';\nimport { SDK_VERSION } from '@sentry/core';\nimport type { OpenTelemetryClient as OpenTelemetryClientInterface } from '../types';\n\n// Typescript complains if we do not use `...args: any[]` for the mixin, with:\n// A mixin class must have a constructor with a single rest parameter of type 'any[]'.ts(2545)\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Wrap an Client class with things we need for OpenTelemetry support.\n * Make sure that the Client class passed in is non-abstract!\n *\n * Usage:\n * const OpenTelemetryClient = getWrappedClientClass(NodeClient);\n * const client = new OpenTelemetryClient(options);\n */\nexport function wrapClientClass<\n  ClassConstructor extends new (...args: any[]) => Client,\n  WrappedClassConstructor extends new (...args: any[]) => Client & OpenTelemetryClientInterface,\n>(ClientClass: ClassConstructor): WrappedClassConstructor {\n  // @ts-expect-error We just assume that this is non-abstract, if you pass in an abstract class this would make it non-abstract\n  class OpenTelemetryClient extends ClientClass implements OpenTelemetryClientInterface {\n    public traceProvider: BasicTracerProvider | undefined;\n    private _tracer: Tracer | undefined;\n\n    public constructor(...args: any[]) {\n      super(...args);\n    }\n\n    /** Get the OTEL tracer. */\n    public get tracer(): Tracer {\n      if (this._tracer) {\n        return this._tracer;\n      }\n\n      const name = '@sentry/opentelemetry';\n      const version = SDK_VERSION;\n      const tracer = trace.getTracer(name, version);\n      this._tracer = tracer;\n\n      return tracer;\n    }\n\n    /**\n     * @inheritDoc\n     */\n    public async flush(timeout?: number): Promise<boolean> {\n      const provider = this.traceProvider;\n      await provider?.forceFlush();\n      return super.flush(timeout);\n    }\n  }\n\n  return OpenTelemetryClient as unknown as WrappedClassConstructor;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n","import { SpanKind } from '@opentelemetry/api';\nimport type { AbstractSpan } from '../types';\nimport { spanHasKind } from './spanTypes';\n\n/**\n * Get the span kind from a span.\n * For whatever reason, this is not public API on the generic \"Span\" type,\n * so we need to check if we actually have a `SDKTraceBaseSpan` where we can fetch this from.\n * Otherwise, we fall back to `SpanKind.INTERNAL`.\n */\nexport function getSpanKind(span: AbstractSpan): SpanKind {\n  if (spanHasKind(span)) {\n    return span.kind;\n  }\n\n  return SpanKind.INTERNAL;\n}\n","import { createContextKey } from '@opentelemetry/api';\n\nexport const SENTRY_TRACE_HEADER = 'sentry-trace';\nexport const SENTRY_BAGGAGE_HEADER = 'baggage';\n\nexport const SENTRY_TRACE_STATE_DSC = 'sentry.dsc';\nexport const SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = 'sentry.sampled_not_recording';\nexport const SENTRY_TRACE_STATE_URL = 'sentry.url';\nexport const SENTRY_TRACE_STATE_SAMPLE_RAND = 'sentry.sample_rand';\nexport const SENTRY_TRACE_STATE_SAMPLE_RATE = 'sentry.sample_rate';\n\nexport const SENTRY_SCOPES_CONTEXT_KEY = createContextKey('sentry_scopes');\n\nexport const SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = createContextKey('sentry_fork_isolation_scope');\n\nexport const SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = createContextKey('sentry_fork_set_scope');\n\nexport const SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = createContextKey('sentry_fork_set_isolation_scope');\n","import type { Context } from '@opentelemetry/api';\nimport type { Scope } from '@sentry/core';\nimport { addNonEnumerableProperty } from '@sentry/core';\nimport { SENTRY_SCOPES_CONTEXT_KEY } from '../constants';\nimport type { CurrentScopes } from '../types';\n\nconst SCOPE_CONTEXT_FIELD = '_scopeContext';\n\n/**\n * Try to get the current scopes from the given OTEL context.\n * This requires a Context Manager that was wrapped with getWrappedContextManager.\n */\nexport function getScopesFromContext(context: Context): CurrentScopes | undefined {\n  return context.getValue(SENTRY_SCOPES_CONTEXT_KEY) as CurrentScopes | undefined;\n}\n\n/**\n * Set the current scopes on an OTEL context.\n * This will return a forked context with the Propagation Context set.\n */\nexport function setScopesOnContext(context: Context, scopes: CurrentScopes): Context {\n  return context.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);\n}\n\n/**\n * Set the context on the scope so we can later look it up.\n * We need this to get the context from the scope in the `trace` functions.\n */\nexport function setContextOnScope(scope: Scope, context: Context): void {\n  addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context);\n}\n\n/**\n * Get the context related to a scope.\n */\nexport function getContextFromScope(scope: Scope): Context | undefined {\n  return (scope as { [SCOPE_CONTEXT_FIELD]?: Context })[SCOPE_CONTEXT_FIELD];\n}\n","import { ATTR_URL_FULL, SEMATTRS_HTTP_URL } from '@opentelemetry/semantic-conventions';\nimport { getClient, isSentryRequestUrl } from '@sentry/core';\nimport type { AbstractSpan } from '../types';\nimport { spanHasAttributes } from './spanTypes';\n\n/**\n *\n * @param otelSpan Checks whether a given OTEL Span is an http request to sentry.\n * @returns boolean\n */\nexport function isSentryRequestSpan(span: AbstractSpan): boolean {\n  if (!spanHasAttributes(span)) {\n    return false;\n  }\n\n  const { attributes } = span;\n\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[SEMATTRS_HTTP_URL] || attributes[ATTR_URL_FULL];\n\n  if (!httpUrl) {\n    return false;\n  }\n\n  return isSentryRequestUrl(httpUrl.toString(), getClient());\n}\n","import type { SpanContext } from '@opentelemetry/api';\nimport { TraceFlags } from '@opentelemetry/api';\nimport { baggageHeaderToDynamicSamplingContext } from '@sentry/core';\nimport { SENTRY_TRACE_STATE_DSC, SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING } from '../constants';\n\n/**\n * OpenTelemetry only knows about SAMPLED or NONE decision,\n * but for us it is important to differentiate between unset and unsampled.\n *\n * Both of these are identified as `traceFlags === TracegFlags.NONE`,\n * but we additionally look at a special trace state to differentiate between them.\n */\nexport function getSamplingDecision(spanContext: SpanContext): boolean | undefined {\n  const { traceFlags, traceState } = spanContext;\n\n  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === '1' : false;\n\n  // If trace flag is `SAMPLED`, we interpret this as sampled\n  // If it is `NONE`, it could mean either it was sampled to be not recorder, or that it was not sampled at all\n  // For us this is an important difference, sow e look at the SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING\n  // to identify which it is\n  if (traceFlags === TraceFlags.SAMPLED) {\n    return true;\n  }\n\n  if (sampledNotRecording) {\n    return false;\n  }\n\n  // Fall back to DSC as a last resort, that may also contain `sampled`...\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  if (dsc?.sampled === 'true') {\n    return true;\n  }\n  if (dsc?.sampled === 'false') {\n    return false;\n  }\n\n  return undefined;\n}\n","import type { Attributes, AttributeValue } from '@opentelemetry/api';\nimport { SpanKind } from '@opentelemetry/api';\nimport {\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_HTTP_ROUTE,\n  ATTR_URL_FULL,\n  SEMATTRS_DB_STATEMENT,\n  SEMATTRS_DB_SYSTEM,\n  SEMATTRS_FAAS_TRIGGER,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_TARGET,\n  SEMATTRS_HTTP_URL,\n  SEMATTRS_MESSAGING_SYSTEM,\n  SEMATTRS_RPC_SERVICE,\n} from '@opentelemetry/semantic-conventions';\nimport type { SpanAttributes, TransactionSource } from '@sentry/core';\nimport {\n  getSanitizedUrlString,\n  parseUrl,\n  SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  stripUrlQueryAndFragment,\n} from '@sentry/core';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION } from '../semanticAttributes';\nimport type { AbstractSpan } from '../types';\nimport { getSpanKind } from './getSpanKind';\nimport { spanHasAttributes, spanHasName } from './spanTypes';\n\ninterface SpanDescription {\n  op: string | undefined;\n  description: string;\n  source: TransactionSource;\n  data?: Record<string, string | undefined>;\n}\n\n/**\n * Infer the op & description for a set of name, attributes and kind of a span.\n */\nexport function inferSpanData(spanName: string, attributes: SpanAttributes, kind: SpanKind): SpanDescription {\n  // if http.method exists, this is an http request span\n  // eslint-disable-next-line deprecation/deprecation\n  const httpMethod = attributes[ATTR_HTTP_REQUEST_METHOD] || attributes[SEMATTRS_HTTP_METHOD];\n  if (httpMethod) {\n    return descriptionForHttpMethod({ attributes, name: spanName, kind }, httpMethod);\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const dbSystem = attributes[SEMATTRS_DB_SYSTEM];\n  const opIsCache =\n    typeof attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] === 'string' &&\n    attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith('cache.');\n\n  // If db.type exists then this is a database call span\n  // If the Redis DB is used as a cache, the span description should not be changed\n  if (dbSystem && !opIsCache) {\n    return descriptionForDbSystem({ attributes, name: spanName });\n  }\n\n  const customSourceOrRoute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom' ? 'custom' : 'route';\n\n  // If rpc.service exists then this is a rpc call span.\n  // eslint-disable-next-line deprecation/deprecation\n  const rpcService = attributes[SEMATTRS_RPC_SERVICE];\n  if (rpcService) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, 'route'),\n      op: 'rpc',\n    };\n  }\n\n  // If messaging.system exists then this is a messaging system span.\n  // eslint-disable-next-line deprecation/deprecation\n  const messagingSystem = attributes[SEMATTRS_MESSAGING_SYSTEM];\n  if (messagingSystem) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: 'message',\n    };\n  }\n\n  // If faas.trigger exists then this is a function as a service span.\n  // eslint-disable-next-line deprecation/deprecation\n  const faasTrigger = attributes[SEMATTRS_FAAS_TRIGGER];\n  if (faasTrigger) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: faasTrigger.toString(),\n    };\n  }\n\n  return { op: undefined, description: spanName, source: 'custom' };\n}\n\n/**\n * Extract better op/description from an otel span.\n *\n * Does not overwrite the span name if the source is already set to custom to ensure\n * that user-updated span names are preserved. In this case, we only adjust the op but\n * leave span description and source unchanged.\n *\n * Based on https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/7422ce2a06337f68a59b552b8c5a2ac125d6bae5/exporter/sentryexporter/sentry_exporter.go#L306\n */\nexport function parseSpanDescription(span: AbstractSpan): SpanDescription {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const name = spanHasName(span) ? span.name : '<unknown>';\n  const kind = getSpanKind(span);\n\n  return inferSpanData(name, attributes, kind);\n}\n\nfunction descriptionForDbSystem({ attributes, name }: { attributes: Attributes; name: string }): SpanDescription {\n  // if we already have a custom name, we don't overwrite it but only set the op\n  const userDefinedName = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  if (typeof userDefinedName === 'string') {\n    return {\n      op: 'db',\n      description: userDefinedName,\n      source: (attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] as TransactionSource) || 'custom',\n    };\n  }\n\n  // if we already have the source set to custom, we don't overwrite the span description but only set the op\n  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom') {\n    return { op: 'db', description: name, source: 'custom' };\n  }\n\n  // Use DB statement (Ex \"SELECT * FROM table\") if possible as description.\n  // eslint-disable-next-line deprecation/deprecation\n  const statement = attributes[SEMATTRS_DB_STATEMENT];\n\n  const description = statement ? statement.toString() : name;\n\n  return { op: 'db', description, source: 'task' };\n}\n\n/** Only exported for tests. */\nexport function descriptionForHttpMethod(\n  { name, kind, attributes }: { name: string; attributes: Attributes; kind: SpanKind },\n  httpMethod: AttributeValue,\n): SpanDescription {\n  const opParts = ['http'];\n\n  switch (kind) {\n    case SpanKind.CLIENT:\n      opParts.push('client');\n      break;\n    case SpanKind.SERVER:\n      opParts.push('server');\n      break;\n  }\n\n  // Spans for HTTP requests we have determined to be prefetch requests will have a `.prefetch` postfix in the op\n  if (attributes['sentry.http.prefetch']) {\n    opParts.push('prefetch');\n  }\n\n  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);\n\n  if (!urlPath) {\n    return { ...getUserUpdatedNameAndSource(name, attributes), op: opParts.join('.') };\n  }\n\n  const graphqlOperationsAttribute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION];\n\n  // Ex. GET /api/users\n  const baseDescription = `${httpMethod} ${urlPath}`;\n\n  // When the http span has a graphql operation, append it to the description\n  // We add these in the graphqlIntegration\n  const inferredDescription = graphqlOperationsAttribute\n    ? `${baseDescription} (${getGraphqlOperationNamesFromAttribute(graphqlOperationsAttribute)})`\n    : baseDescription;\n\n  // If `httpPath` is a root path, then we can categorize the transaction source as route.\n  const inferredSource: TransactionSource = hasRoute || urlPath === '/' ? 'route' : 'url';\n\n  const data: Record<string, string> = {};\n\n  if (url) {\n    data.url = url;\n  }\n  if (query) {\n    data['http.query'] = query;\n  }\n  if (fragment) {\n    data['http.fragment'] = fragment;\n  }\n\n  // If the span kind is neither client nor server, we use the original name\n  // this infers that somebody manually started this span, in which case we don't want to overwrite the name\n  const isClientOrServerKind = kind === SpanKind.CLIENT || kind === SpanKind.SERVER;\n\n  // If the span is an auto-span (=it comes from one of our instrumentations),\n  // we always want to infer the name\n  // this is necessary because some of the auto-instrumentation we use uses kind=INTERNAL\n  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] || 'manual';\n  const isManualSpan = !`${origin}`.startsWith('auto');\n\n  // If users (or in very rare occasions we) set the source to custom, we don't overwrite the name\n  const alreadyHasCustomSource = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom';\n  const customSpanName = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  const useInferredDescription =\n    !alreadyHasCustomSource && customSpanName == null && (isClientOrServerKind || !isManualSpan);\n\n  const { description, source } = useInferredDescription\n    ? { description: inferredDescription, source: inferredSource }\n    : getUserUpdatedNameAndSource(name, attributes);\n\n  return {\n    op: opParts.join('.'),\n    description,\n    source,\n    data,\n  };\n}\n\nfunction getGraphqlOperationNamesFromAttribute(attr: AttributeValue): string {\n  if (Array.isArray(attr)) {\n    const sorted = attr.slice().sort();\n\n    // Up to 5 items, we just add all of them\n    if (sorted.length <= 5) {\n      return sorted.join(', ');\n    } else {\n      // Else, we add the first 5 and the diff of other operations\n      return `${sorted.slice(0, 5).join(', ')}, +${sorted.length - 5}`;\n    }\n  }\n\n  return `${attr}`;\n}\n\n/** Exported for tests only */\nexport function getSanitizedUrl(\n  attributes: Attributes,\n  kind: SpanKind,\n): {\n  url: string | undefined;\n  urlPath: string | undefined;\n  query: string | undefined;\n  fragment: string | undefined;\n  hasRoute: boolean;\n} {\n  // This is the relative path of the URL, e.g. /sub\n  // eslint-disable-next-line deprecation/deprecation\n  const httpTarget = attributes[SEMATTRS_HTTP_TARGET];\n  // This is the full URL, including host & query params etc., e.g. https://example.com/sub?foo=bar\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[SEMATTRS_HTTP_URL] || attributes[ATTR_URL_FULL];\n  // This is the normalized route name - may not always be available!\n  const httpRoute = attributes[ATTR_HTTP_ROUTE];\n\n  const parsedUrl = typeof httpUrl === 'string' ? parseUrl(httpUrl) : undefined;\n  const url = parsedUrl ? getSanitizedUrlString(parsedUrl) : undefined;\n  const query = parsedUrl?.search || undefined;\n  const fragment = parsedUrl?.hash || undefined;\n\n  if (typeof httpRoute === 'string') {\n    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };\n  }\n\n  if (kind === SpanKind.SERVER && typeof httpTarget === 'string') {\n    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  if (parsedUrl) {\n    return { urlPath: url, url, query, fragment, hasRoute: false };\n  }\n\n  // fall back to target even for client spans, if no URL is present\n  if (typeof httpTarget === 'string') {\n    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  return { urlPath: undefined, url, query, fragment, hasRoute: false };\n}\n\n/**\n * Because Otel instrumentation sometimes mutates span names via `span.updateName`, the only way\n * to ensure that a user-set span name is preserved is to store it as a tmp attribute on the span.\n * We delete this attribute once we're done with it when preparing the event envelope.\n *\n * This temp attribute always takes precedence over the original name.\n *\n * We also need to take care of setting the correct source. Users can always update the source\n * after updating the name, so we need to respect that.\n *\n * @internal exported only for testing\n */\nexport function getUserUpdatedNameAndSource(\n  originalName: string,\n  attributes: Attributes,\n  fallbackSource: TransactionSource = 'custom',\n): {\n  description: string;\n  source: TransactionSource;\n} {\n  const source = (attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] as TransactionSource) || fallbackSource;\n  const description = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  if (description && typeof description === 'string') {\n    return {\n      description,\n      source,\n    };\n  }\n\n  return { description: originalName, source };\n}\n","import type { Client } from '@sentry/core';\nimport { hasSpansEnabled, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, spanToJSON } from '@sentry/core';\nimport { getSamplingDecision } from './getSamplingDecision';\nimport { parseSpanDescription } from './parseSpanDescription';\nimport { spanHasName } from './spanTypes';\n\n/**\n * Setup a DSC handler on the passed client,\n * ensuring that the transaction name is inferred from the span correctly.\n */\nexport function enhanceDscWithOpenTelemetryRootSpanName(client: Client): void {\n  client.on('createDsc', (dsc, rootSpan) => {\n    if (!rootSpan) {\n      return;\n    }\n\n    // We want to overwrite the transaction on the DSC that is created by default in core\n    // The reason for this is that we want to infer the span name, not use the initial one\n    // Otherwise, we'll get names like \"GET\" instead of e.g. \"GET /foo\"\n    // `parseSpanDescription` takes the attributes of the span into account for the name\n    // This mutates the passed-in DSC\n\n    const jsonSpan = spanToJSON(rootSpan);\n    const attributes = jsonSpan.data;\n    const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };\n    if (source !== 'url' && description) {\n      dsc.transaction = description;\n    }\n\n    // Also ensure sampling decision is correctly inferred\n    // In core, we use `spanIsSampled`, which just looks at the trace flags\n    // but in OTEL, we use a slightly more complex logic to be able to differntiate between unsampled and deferred sampling\n    if (hasSpansEnabled()) {\n      const sampled = getSamplingDecision(rootSpan.spanContext());\n      dsc.sampled = sampled == undefined ? undefined : String(sampled);\n    }\n  });\n}\n","import type { Span } from '@opentelemetry/api';\nimport { trace } from '@opentelemetry/api';\n\n/**\n * Returns the currently active span.\n */\nexport function getActiveSpan(): Span | undefined {\n  return trace.getActiveSpan();\n}\n","declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n","import { TraceState } from '@opentelemetry/core';\nimport type { DynamicSamplingContext } from '@sentry/core';\nimport { dynamicSamplingContextToSentryBaggageHeader } from '@sentry/core';\nimport { SENTRY_TRACE_STATE_DSC, SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING } from '../constants';\n\n/**\n * Generate a TraceState for the given data.\n */\nexport function makeTraceState({\n  dsc,\n  sampled,\n}: {\n  dsc?: Partial<DynamicSamplingContext>;\n  sampled?: boolean;\n}): TraceState {\n  // We store the DSC as OTEL trace state on the span context\n  const dscString = dsc ? dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;\n\n  const traceStateBase = new TraceState();\n\n  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;\n\n  // We also specifically want to store if this is sampled to be not recording,\n  // or unsampled (=could be either sampled or not)\n  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') : traceStateWithDsc;\n}\n","type OpenTelemetryElement = 'SentrySpanProcessor' | 'SentryContextManager' | 'SentryPropagator' | 'SentrySampler';\n\nconst setupElements = new Set<OpenTelemetryElement>();\n\n/** Get all the OpenTelemetry elements that have been set up. */\nexport function openTelemetrySetupCheck(): OpenTelemetryElement[] {\n  return Array.from(setupElements);\n}\n\n/** Mark an OpenTelemetry element as setup. */\nexport function setIsSetup(element: OpenTelemetryElement): void {\n  setupElements.add(element);\n}\n\n/** Only exported for tests. */\nexport function clearOpenTelemetrySetupCheck(): void {\n  setupElements.clear();\n}\n","import type { Baggage, Context, Span, SpanContext, TextMapGetter, TextMapSetter } from '@opentelemetry/api';\nimport { context, INVALID_TRACEID, propagation, trace, TraceFlags } from '@opentelemetry/api';\nimport { isTracingSuppressed, W3CBaggagePropagator } from '@opentelemetry/core';\nimport { ATTR_URL_FULL, SEMATTRS_HTTP_URL } from '@opentelemetry/semantic-conventions';\nimport type { Client, continueTrace, DynamicSamplingContext, Options, Scope } from '@sentry/core';\nimport {\n  generateSentryTraceHeader,\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromScope,\n  getDynamicSamplingContextFromSpan,\n  getIsolationScope,\n  logger,\n  LRUMap,\n  parseBaggageHeader,\n  propagationContextFromHeaders,\n  SENTRY_BAGGAGE_KEY_PREFIX,\n  spanToJSON,\n  stringMatchesSomePattern,\n} from '@sentry/core';\nimport { SENTRY_BAGGAGE_HEADER, SENTRY_TRACE_HEADER, SENTRY_TRACE_STATE_URL } from './constants';\nimport { DEBUG_BUILD } from './debug-build';\nimport { getScopesFromContext, setScopesOnContext } from './utils/contextData';\nimport { getSamplingDecision } from './utils/getSamplingDecision';\nimport { makeTraceState } from './utils/makeTraceState';\nimport { setIsSetup } from './utils/setupCheck';\n\n/**\n * Injects and extracts `sentry-trace` and `baggage` headers from carriers.\n */\nexport class SentryPropagator extends W3CBaggagePropagator {\n  /** A map of URLs that have already been checked for if they match tracePropagationTargets. */\n  private _urlMatchesTargetsMap: LRUMap<string, boolean>;\n\n  public constructor() {\n    super();\n    setIsSetup('SentryPropagator');\n\n    // We're caching results so we don't have to recompute regexp every time we create a request.\n    this._urlMatchesTargetsMap = new LRUMap<string, boolean>(100);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    if (isTracingSuppressed(context)) {\n      DEBUG_BUILD && logger.log('[Tracing] Not injecting trace data for url because tracing is suppressed.');\n      return;\n    }\n\n    const activeSpan = trace.getSpan(context);\n    const url = activeSpan && getCurrentURL(activeSpan);\n\n    const tracePropagationTargets = getClient()?.getOptions()?.tracePropagationTargets;\n    if (!shouldPropagateTraceForUrl(url, tracePropagationTargets, this._urlMatchesTargetsMap)) {\n      DEBUG_BUILD &&\n        logger.log(\n          '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:',\n          url,\n        );\n      return;\n    }\n\n    const existingBaggageHeader = getExistingBaggage(carrier);\n    let baggage = propagation.getBaggage(context) || propagation.createBaggage({});\n\n    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context);\n\n    if (existingBaggageHeader) {\n      const baggageEntries = parseBaggageHeader(existingBaggageHeader);\n\n      if (baggageEntries) {\n        Object.entries(baggageEntries).forEach(([key, value]) => {\n          baggage = baggage.setEntry(key, { value });\n        });\n      }\n    }\n\n    if (dynamicSamplingContext) {\n      baggage = Object.entries(dynamicSamplingContext).reduce<Baggage>((b, [dscKey, dscValue]) => {\n        if (dscValue) {\n          return b.setEntry(`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });\n        }\n        return b;\n      }, baggage);\n    }\n\n    // We also want to avoid setting the default OTEL trace ID, if we get that for whatever reason\n    if (traceId && traceId !== INVALID_TRACEID) {\n      setter.set(carrier, SENTRY_TRACE_HEADER, generateSentryTraceHeader(traceId, spanId, sampled));\n    }\n\n    super.inject(propagation.setBaggage(context, baggage), carrier, setter);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    const maybeSentryTraceHeader: string | string[] | undefined = getter.get(carrier, SENTRY_TRACE_HEADER);\n    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);\n\n    const sentryTrace = maybeSentryTraceHeader\n      ? Array.isArray(maybeSentryTraceHeader)\n        ? maybeSentryTraceHeader[0]\n        : maybeSentryTraceHeader\n      : undefined;\n\n    // Add remote parent span context\n    // If there is no incoming trace, this will return the context as-is\n    return ensureScopesOnContext(getContextWithRemoteActiveSpan(context, { sentryTrace, baggage }));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public fields(): string[] {\n    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];\n  }\n}\n\nconst NOT_PROPAGATED_MESSAGE =\n  '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:';\n\n/**\n * Check if a given URL should be propagated to or not.\n * If no url is defined, or no trace propagation targets are defined, this will always return `true`.\n * You can also optionally provide a decision map, to cache decisions and avoid repeated regex lookups.\n */\nexport function shouldPropagateTraceForUrl(\n  url: string | undefined,\n  tracePropagationTargets: Options['tracePropagationTargets'],\n  decisionMap?: LRUMap<string, boolean>,\n): boolean {\n  if (typeof url !== 'string' || !tracePropagationTargets) {\n    return true;\n  }\n\n  const cachedDecision = decisionMap?.get(url);\n  if (cachedDecision !== undefined) {\n    DEBUG_BUILD && !cachedDecision && logger.log(NOT_PROPAGATED_MESSAGE, url);\n    return cachedDecision;\n  }\n\n  const decision = stringMatchesSomePattern(url, tracePropagationTargets);\n  decisionMap?.set(url, decision);\n\n  DEBUG_BUILD && !decision && logger.log(NOT_PROPAGATED_MESSAGE, url);\n  return decision;\n}\n\n/**\n * Get propagation injection data for the given context.\n * The additional options can be passed to override the scope and client that is otherwise derived from the context.\n */\nexport function getInjectionData(\n  context: Context,\n  options: { scope?: Scope; client?: Client } = {},\n): {\n  dynamicSamplingContext: Partial<DynamicSamplingContext> | undefined;\n  traceId: string | undefined;\n  spanId: string | undefined;\n  sampled: boolean | undefined;\n} {\n  const span = trace.getSpan(context);\n\n  // If we have a remote span, the spanId should be considered as the parentSpanId, not spanId itself\n  // Instead, we use a virtual (generated) spanId for propagation\n  if (span?.spanContext().isRemote) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: undefined,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // If we have a local span, we just use this\n  if (span) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: spanContext.spanId,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // Else we try to use the propagation context from the scope\n  // The only scenario where this should happen is when we neither have a span, nor an incoming trace\n  const scope = options.scope || getScopesFromContext(context)?.scope || getCurrentScope();\n  const client = options.client || getClient();\n\n  const propagationContext = scope.getPropagationContext();\n  const dynamicSamplingContext = client ? getDynamicSamplingContextFromScope(client, scope) : undefined;\n  return {\n    dynamicSamplingContext,\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.propagationSpanId,\n    sampled: propagationContext.sampled,\n  };\n}\n\nfunction getContextWithRemoteActiveSpan(\n  ctx: Context,\n  { sentryTrace, baggage }: Parameters<typeof continueTrace>[0],\n): Context {\n  const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n\n  const { traceId, parentSpanId, sampled, dsc } = propagationContext;\n\n  // We only want to set the virtual span if we are continuing a concrete trace\n  // Otherwise, we ignore the incoming trace here, e.g. if we have no trace headers\n  if (!parentSpanId) {\n    return ctx;\n  }\n\n  const spanContext = generateRemoteSpanContext({\n    traceId,\n    spanId: parentSpanId,\n    sampled,\n    dsc,\n  });\n\n  return trace.setSpanContext(ctx, spanContext);\n}\n\n/**\n * Takes trace strings and propagates them as a remote active span.\n * This should be used in addition to `continueTrace` in OTEL-powered environments.\n */\nexport function continueTraceAsRemoteSpan<T>(\n  ctx: Context,\n  options: Parameters<typeof continueTrace>[0],\n  callback: () => T,\n): T {\n  const ctxWithSpanContext = ensureScopesOnContext(getContextWithRemoteActiveSpan(ctx, options));\n\n  return context.with(ctxWithSpanContext, callback);\n}\n\nfunction ensureScopesOnContext(ctx: Context): Context {\n  // If there are no scopes yet on the context, ensure we have them\n  const scopes = getScopesFromContext(ctx);\n  const newScopes = {\n    // If we have no scope here, this is most likely either the root context or a context manually derived from it\n    // In this case, we want to fork the current scope, to ensure we do not pollute the root scope\n    scope: scopes ? scopes.scope : getCurrentScope().clone(),\n    isolationScope: scopes ? scopes.isolationScope : getIsolationScope(),\n  };\n\n  return setScopesOnContext(ctx, newScopes);\n}\n\n/** Try to get the existing baggage header so we can merge this in. */\nfunction getExistingBaggage(carrier: unknown): string | undefined {\n  try {\n    const baggage = (carrier as Record<string, string | string[]>)[SENTRY_BAGGAGE_HEADER];\n    return Array.isArray(baggage) ? baggage.join(',') : baggage;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * It is pretty tricky to get access to the outgoing request URL of a request in the propagator.\n * As we only have access to the context of the span to be sent and the carrier (=headers),\n * but the span may be unsampled and thus have no attributes.\n *\n * So we use the following logic:\n * 1. If we have an active span, we check if it has a URL attribute.\n * 2. Else, if the active span has no URL attribute (e.g. it is unsampled), we check a special trace state (which we set in our sampler).\n */\nfunction getCurrentURL(span: Span): string | undefined {\n  const spanData = spanToJSON(span).data;\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const urlAttribute = spanData[SEMATTRS_HTTP_URL] || spanData[ATTR_URL_FULL];\n  if (typeof urlAttribute === 'string') {\n    return urlAttribute;\n  }\n\n  // Also look at the traceState, which we may set in the sampler even for unsampled spans\n  const urlTraceState = span.spanContext().traceState?.get(SENTRY_TRACE_STATE_URL);\n  if (urlTraceState) {\n    return urlTraceState;\n  }\n\n  return undefined;\n}\n\nfunction generateRemoteSpanContext({\n  spanId,\n  traceId,\n  sampled,\n  dsc,\n}: {\n  spanId: string;\n  traceId: string;\n  sampled: boolean | undefined;\n  dsc?: Partial<DynamicSamplingContext>;\n}): SpanContext {\n  // We store the DSC as OTEL trace state on the span context\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanContext: SpanContext = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? TraceFlags.SAMPLED : TraceFlags.NONE,\n    traceState,\n  };\n\n  return spanContext;\n}\n","import type { Context, Span, SpanContext, SpanOptions, Tracer } from '@opentelemetry/api';\nimport { context, SpanStatusCode, trace, TraceFlags } from '@opentelemetry/api';\nimport { suppressTracing } from '@opentelemetry/core';\nimport type {\n  Client,\n  continueTrace as baseContinueTrace,\n  DynamicSamplingContext,\n  Scope,\n  Span as SentrySpan,\n  TraceContext,\n} from '@sentry/core';\nimport {\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromScope,\n  getDynamicSamplingContextFromSpan,\n  getRootSpan,\n  getTraceContextFromScope,\n  handleCallbackErrors,\n  SDK_VERSION,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  spanToJSON,\n  spanToTraceContext,\n} from '@sentry/core';\nimport { continueTraceAsRemoteSpan } from './propagator';\nimport type { OpenTelemetryClient, OpenTelemetrySpanContext } from './types';\nimport { getContextFromScope } from './utils/contextData';\nimport { getSamplingDecision } from './utils/getSamplingDecision';\nimport { makeTraceState } from './utils/makeTraceState';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startSpan<T>(options: OpenTelemetrySpanContext, callback: (span: Span) => T): T {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper<T>(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return handleCallbackErrors(\n        () => callback(span),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (spanToJSON(span).status === undefined) {\n            span.setStatus({ code: SpanStatusCode.ERROR });\n          }\n        },\n        () => span.end(),\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startSpanManual<T>(\n  options: OpenTelemetrySpanContext,\n  callback: (span: Span, finish: () => void) => T,\n): T {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper<T>(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return handleCallbackErrors(\n        () => callback(span, () => span.end()),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (spanToJSON(span).status === undefined) {\n            span.setStatus({ code: SpanStatusCode.ERROR });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startInactiveSpan(options: OpenTelemetrySpanContext): Span {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper<Span>(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    const span = tracer.startSpan(name, spanOptions, ctx);\n\n    return span;\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will be root spans.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nexport function withActiveSpan<T>(span: Span | null, callback: (scope: Scope) => T): T {\n  const newContextWithActiveSpan = span ? trace.setSpan(context.active(), span) : trace.deleteSpan(context.active());\n  return context.with(newContextWithActiveSpan, () => callback(getCurrentScope()));\n}\n\nfunction getTracer(): Tracer {\n  const client = getClient<Client & OpenTelemetryClient>();\n  return client?.tracer || trace.getTracer('@sentry/opentelemetry', SDK_VERSION);\n}\n\nfunction getSpanOptions(options: OpenTelemetrySpanContext): SpanOptions {\n  const { startTime, attributes, kind, op, links } = options;\n\n  // OTEL expects timestamps in ms, not seconds\n  const fixedStartTime = typeof startTime === 'number' ? ensureTimestampInMilliseconds(startTime) : startTime;\n\n  return {\n    attributes: op\n      ? {\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n          ...attributes,\n        }\n      : attributes,\n    kind,\n    links,\n    startTime: fixedStartTime,\n  };\n}\n\nfunction ensureTimestampInMilliseconds(timestamp: number): number {\n  const isMs = timestamp < 9999999999;\n  return isMs ? timestamp * 1000 : timestamp;\n}\n\nfunction getContext(scope: Scope | undefined, forceTransaction: boolean | undefined): Context {\n  const ctx = getContextForScope(scope);\n  const parentSpan = trace.getSpan(ctx);\n\n  // In the case that we have no parent span, we start a new trace\n  // Note that if we continue a trace, we'll always have a remote parent span here anyhow\n  if (!parentSpan) {\n    return ctx;\n  }\n\n  // If we don't want to force a transaction, and we have a parent span, all good, we just return as-is!\n  if (!forceTransaction) {\n    return ctx;\n  }\n\n  // Else, if we do have a parent span but want to force a transaction, we have to simulate a \"root\" context\n\n  // Else, we need to do two things:\n  // 1. Unset the parent span from the context, so we'll create a new root span\n  // 2. Ensure the propagation context is correct, so we'll continue from the parent span\n  const ctxWithoutSpan = trace.deleteSpan(ctx);\n\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = getSamplingDecision(parentSpan.spanContext());\n\n  // In this case, when we are forcing a transaction, we want to treat this like continuing an incoming trace\n  // so we set the traceState according to the root span\n  const rootSpan = getRootSpan(parentSpan);\n  const dsc = getDynamicSamplingContextFromSpan(rootSpan);\n\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanOptions: SpanContext = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? TraceFlags.SAMPLED : TraceFlags.NONE,\n    traceState,\n  };\n\n  const ctxWithSpanContext = trace.setSpanContext(ctxWithoutSpan, spanOptions);\n\n  return ctxWithSpanContext;\n}\n\nfunction getContextForScope(scope?: Scope): Context {\n  if (scope) {\n    const ctx = getContextFromScope(scope);\n    if (ctx) {\n      return ctx;\n    }\n  }\n\n  return context.active();\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n *\n * This is a custom version of `continueTrace` that is used in OTEL-powered environments.\n * It propagates the trace as a remote span, in addition to setting it on the propagation context.\n */\nexport function continueTrace<T>(options: Parameters<typeof baseContinueTrace>[0], callback: () => T): T {\n  return continueTraceAsRemoteSpan(context.active(), options, callback);\n}\n\n/**\n * Get the trace context for a given scope.\n * We have a custom implemention here because we need an OTEL-specific way to get the span from a scope.\n */\nexport function getTraceContextForScope(\n  client: Client,\n  scope: Scope,\n): [dynamicSamplingContext: Partial<DynamicSamplingContext>, traceContext: TraceContext] {\n  const ctx = getContextFromScope(scope);\n  const span = ctx && trace.getSpan(ctx);\n\n  const traceContext = span ? spanToTraceContext(span) : getTraceContextFromScope(scope);\n\n  const dynamicSamplingContext = span\n    ? getDynamicSamplingContextFromSpan(span)\n    : getDynamicSamplingContextFromScope(client, scope);\n  return [dynamicSamplingContext, traceContext];\n}\n\nfunction getActiveSpanWrapper<T>(parentSpan: Span | SentrySpan | undefined | null): (callback: () => T) => T {\n  return parentSpan !== undefined\n    ? (callback: () => T) => {\n        return withActiveSpan(parentSpan, callback);\n      }\n    : (callback: () => T) => callback();\n}\n","import { context } from '@opentelemetry/api';\nimport { suppressTracing as suppressTracingImpl } from '@opentelemetry/core';\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nexport function suppressTracing<T>(callback: () => T): T {\n  const ctx = suppressTracingImpl(context.active());\n  return context.with(ctx, callback);\n}\n","import type { Client } from '@sentry/core';\nimport { getDynamicSamplingContextFromSpan, getRootSpan, spanToTraceContext } from '@sentry/core';\nimport { getActiveSpan } from './utils/getActiveSpan';\n\n/** Ensure the `trace` context is set on all events. */\nexport function setupEventContextTrace(client: Client): void {\n  client.on('preprocessEvent', event => {\n    const span = getActiveSpan();\n    // For transaction events, this is handled separately\n    // Because the active span may not be the span that is actually the transaction event\n    if (!span || event.type === 'transaction') {\n      return;\n    }\n\n    // If event has already set `trace` context, use that one.\n    event.contexts = {\n      trace: spanToTraceContext(span),\n      ...event.contexts,\n    };\n\n    const rootSpan = getRootSpan(span);\n\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: getDynamicSamplingContextFromSpan(rootSpan),\n      ...event.sdkProcessingMetadata,\n    };\n\n    return event;\n  });\n}\n","import * as api from '@opentelemetry/api';\nimport type { Client, Scope, SerializedTraceData, Span } from '@sentry/core';\nimport {\n  dynamicSamplingContextToSentryBaggageHeader,\n  generateSentryTraceHeader,\n  getCapturedScopesOnSpan,\n} from '@sentry/core';\nimport { getInjectionData } from '../propagator';\nimport { getContextFromScope } from './contextData';\n\n/**\n * Otel-specific implementation of `getTraceData`.\n * @see `@sentry/core` version of `getTraceData` for more information\n */\nexport function getTraceData({\n  span,\n  scope,\n  client,\n}: { span?: Span; scope?: Scope; client?: Client } = {}): SerializedTraceData {\n  let ctx = (scope && getContextFromScope(scope)) ?? api.context.active();\n\n  if (span) {\n    const { scope } = getCapturedScopesOnSpan(span);\n    // fall back to current context if for whatever reason we can't find the one of the span\n    ctx = (scope && getContextFromScope(scope)) || api.trace.setSpan(api.context.active(), span);\n  }\n\n  const { traceId, spanId, sampled, dynamicSamplingContext } = getInjectionData(ctx, { scope, client });\n\n  return {\n    'sentry-trace': generateSentryTraceHeader(traceId, spanId, sampled),\n    baggage: dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext),\n  };\n}\n","import * as api from '@opentelemetry/api';\nimport type { Scope, withActiveSpan as defaultWithActiveSpan } from '@sentry/core';\nimport { getDefaultCurrentScope, getDefaultIsolationScope, setAsyncContextStrategy } from '@sentry/core';\nimport {\n  SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_SCOPE_CONTEXT_KEY,\n} from './constants';\nimport { continueTrace, startInactiveSpan, startSpan, startSpanManual, withActiveSpan } from './trace';\nimport type { CurrentScopes } from './types';\nimport { getContextFromScope, getScopesFromContext } from './utils/contextData';\nimport { getActiveSpan } from './utils/getActiveSpan';\nimport { getTraceData } from './utils/getTraceData';\nimport { suppressTracing } from './utils/suppressTracing';\n\n/**\n * Sets the async context strategy to use follow the OTEL context under the hood.\n * We handle forking a hub inside of our custom OTEL Context Manager (./otelContextManager.ts)\n */\nexport function setOpenTelemetryContextAsyncContextStrategy(): void {\n  function getScopes(): CurrentScopes {\n    const ctx = api.context.active();\n    const scopes = getScopesFromContext(ctx);\n\n    if (scopes) {\n      return scopes;\n    }\n\n    // fallback behavior:\n    // if, for whatever reason, we can't find scopes on the context here, we have to fix this somehow\n    return {\n      scope: getDefaultCurrentScope(),\n      isolationScope: getDefaultIsolationScope(),\n    };\n  }\n\n  function withScope<T>(callback: (scope: Scope) => T): T {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    // as by default, we don't want to fork this, unless triggered explicitly by `withScope`\n    return api.context.with(ctx, () => {\n      return callback(getCurrentScope());\n    });\n  }\n\n  function withSetScope<T>(scope: Scope, callback: (scope: Scope) => T): T {\n    const ctx = getContextFromScope(scope) || api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_SET_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which picks up this scope as the current scope\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {\n      return callback(scope);\n    });\n  }\n\n  function withIsolationScope<T>(callback: (isolationScope: Scope) => T): T {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function withSetIsolationScope<T>(isolationScope: Scope, callback: (isolationScope: Scope) => T): T {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function getCurrentScope(): Scope {\n    return getScopes().scope;\n  }\n\n  function getIsolationScope(): Scope {\n    return getScopes().isolationScope;\n  }\n\n  setAsyncContextStrategy({\n    withScope,\n    withSetScope,\n    withSetIsolationScope,\n    withIsolationScope,\n    getCurrentScope,\n    getIsolationScope,\n    startSpan,\n    startSpanManual,\n    startInactiveSpan,\n    getActiveSpan,\n    suppressTracing,\n    getTraceData,\n    continueTrace,\n    // The types here don't fully align, because our own `Span` type is narrower\n    // than the OTEL one - but this is OK for here, as we now we'll only have OTEL spans passed around\n    withActiveSpan: withActiveSpan as typeof defaultWithActiveSpan,\n  });\n}\n","import type { Context, ContextManager } from '@opentelemetry/api';\nimport type { Scope } from '@sentry/core';\nimport { getCurrentScope, getIsolationScope } from '@sentry/core';\nimport {\n  SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_SCOPE_CONTEXT_KEY,\n} from './constants';\nimport { getScopesFromContext, setContextOnScope, setScopesOnContext } from './utils/contextData';\nimport { setIsSetup } from './utils/setupCheck';\n\n/**\n * Wrap an OpenTelemetry ContextManager in a way that ensures the context is kept in sync with the Sentry Scope.\n *\n * Usage:\n * import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';\n * const SentryContextManager = wrapContextManagerClass(AsyncLocalStorageContextManager);\n * const contextManager = new SentryContextManager();\n */\nexport function wrapContextManagerClass<ContextManagerInstance extends ContextManager>(\n  ContextManagerClass: new (...args: unknown[]) => ContextManagerInstance,\n): typeof ContextManagerClass {\n  /**\n   * This is a custom ContextManager for OpenTelemetry, which extends the default AsyncLocalStorageContextManager.\n   * It ensures that we create new scopes per context, so that the OTEL Context & the Sentry Scope are always in sync.\n   *\n   * Note that we currently only support AsyncHooks with this,\n   * but since this should work for Node 14+ anyhow that should be good enough.\n   */\n\n  // @ts-expect-error TS does not like this, but we know this is fine\n  class SentryContextManager extends ContextManagerClass {\n    public constructor(...args: unknown[]) {\n      super(...args);\n      setIsSetup('SentryContextManager');\n    }\n    /**\n     * Overwrite with() of the original AsyncLocalStorageContextManager\n     * to ensure we also create new scopes per context.\n     */\n    public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n      context: Context,\n      fn: F,\n      thisArg?: ThisParameterType<F>,\n      ...args: A\n    ): ReturnType<F> {\n      const currentScopes = getScopesFromContext(context);\n      const currentScope = currentScopes?.scope || getCurrentScope();\n      const currentIsolationScope = currentScopes?.isolationScope || getIsolationScope();\n\n      const shouldForkIsolationScope = context.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;\n      const scope = context.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY) as Scope | undefined;\n      const isolationScope = context.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY) as Scope | undefined;\n\n      const newCurrentScope = scope || currentScope.clone();\n      const newIsolationScope =\n        isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);\n      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };\n\n      const ctx1 = setScopesOnContext(context, scopes);\n\n      // Remove the unneeded values again\n      const ctx2 = ctx1\n        .deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);\n\n      setContextOnScope(newCurrentScope, ctx2);\n\n      return super.with(ctx2, fn, thisArg, ...args);\n    }\n  }\n\n  return SentryContextManager as unknown as typeof ContextManagerClass;\n}\n","import type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE } from '../semanticAttributes';\nimport { getParentSpanId } from './getParentSpanId';\n\nexport interface SpanNode {\n  id: string;\n  span?: ReadableSpan;\n  parentNode?: SpanNode | undefined;\n  children: SpanNode[];\n}\n\ntype SpanMap = Map<string, SpanNode>;\n\n/**\n * This function runs through a list of OTEL Spans, and wraps them in an `SpanNode`\n * where each node holds a reference to their parent node.\n */\nexport function groupSpansWithParents(spans: ReadableSpan[]): SpanNode[] {\n  const nodeMap: SpanMap = new Map<string, SpanNode>();\n\n  for (const span of spans) {\n    createOrUpdateSpanNodeAndRefs(nodeMap, span);\n  }\n\n  return Array.from(nodeMap, function ([_id, spanNode]) {\n    return spanNode;\n  });\n}\n\n/**\n * This returns the _local_ parent ID - `parentId` on the span may point to a remote span.\n */\nexport function getLocalParentId(span: ReadableSpan): string | undefined {\n  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;\n  // If the parentId is the trace parent ID, we pretend it's undefined\n  // As this means the parent exists somewhere else\n  return !parentIsRemote ? getParentSpanId(span) : undefined;\n}\n\nfunction createOrUpdateSpanNodeAndRefs(nodeMap: SpanMap, span: ReadableSpan): void {\n  const id = span.spanContext().spanId;\n  const parentId = getLocalParentId(span);\n\n  if (!parentId) {\n    createOrUpdateNode(nodeMap, { id, span, children: [] });\n    return;\n  }\n\n  // Else make sure to create parent node as well\n  // Note that the parent may not know it's parent _yet_, this may be updated in a later pass\n  const parentNode = createOrGetParentNode(nodeMap, parentId);\n  const node = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });\n  parentNode.children.push(node);\n}\n\nfunction createOrGetParentNode(nodeMap: SpanMap, id: string): SpanNode {\n  const existing = nodeMap.get(id);\n\n  if (existing) {\n    return existing;\n  }\n\n  return createOrUpdateNode(nodeMap, { id, children: [] });\n}\n\nfunction createOrUpdateNode(nodeMap: SpanMap, spanNode: SpanNode): SpanNode {\n  const existing = nodeMap.get(spanNode.id);\n\n  // If span is already set, nothing to do here\n  if (existing?.span) {\n    return existing;\n  }\n\n  // If it exists but span is not set yet, we update it\n  if (existing && !existing.span) {\n    existing.span = spanNode.span;\n    existing.parentNode = spanNode.parentNode;\n    return existing;\n  }\n\n  // Else, we create a new one...\n  nodeMap.set(spanNode.id, spanNode);\n  return spanNode;\n}\n","import { SpanStatusCode } from '@opentelemetry/api';\nimport {\n  ATTR_HTTP_RESPONSE_STATUS_CODE,\n  SEMATTRS_HTTP_STATUS_CODE,\n  SEMATTRS_RPC_GRPC_STATUS_CODE,\n} from '@opentelemetry/semantic-conventions';\nimport type { SpanAttributes, SpanStatus } from '@sentry/core';\nimport { getSpanStatusFromHttpCode, SPAN_STATUS_ERROR, SPAN_STATUS_OK } from '@sentry/core';\nimport type { AbstractSpan } from '../types';\nimport { spanHasAttributes, spanHasStatus } from './spanTypes';\n\n// canonicalCodesGrpcMap maps some GRPC codes to Sentry's span statuses. See description in grpc documentation.\nconst canonicalGrpcErrorCodesMap: Record<string, SpanStatus['message']> = {\n  '1': 'cancelled',\n  '2': 'unknown_error',\n  '3': 'invalid_argument',\n  '4': 'deadline_exceeded',\n  '5': 'not_found',\n  '6': 'already_exists',\n  '7': 'permission_denied',\n  '8': 'resource_exhausted',\n  '9': 'failed_precondition',\n  '10': 'aborted',\n  '11': 'out_of_range',\n  '12': 'unimplemented',\n  '13': 'internal_error',\n  '14': 'unavailable',\n  '15': 'data_loss',\n  '16': 'unauthenticated',\n} as const;\n\nconst isStatusErrorMessageValid = (message: string): boolean => {\n  return Object.values(canonicalGrpcErrorCodesMap).includes(message as SpanStatus['message']);\n};\n\n/**\n * Get a Sentry span status from an otel span.\n */\nexport function mapStatus(span: AbstractSpan): SpanStatus {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const status = spanHasStatus(span) ? span.status : undefined;\n\n  if (status) {\n    // Since span status OK is not set by default, we give it priority: https://opentelemetry.io/docs/concepts/signals/traces/#span-status\n    if (status.code === SpanStatusCode.OK) {\n      return { code: SPAN_STATUS_OK };\n      // If the span is already marked as erroneous we return that exact status\n    } else if (status.code === SpanStatusCode.ERROR) {\n      if (typeof status.message === 'undefined') {\n        const inferredStatus = inferStatusFromAttributes(attributes);\n        if (inferredStatus) {\n          return inferredStatus;\n        }\n      }\n\n      if (status.message && isStatusErrorMessageValid(status.message)) {\n        return { code: SPAN_STATUS_ERROR, message: status.message };\n      } else {\n        return { code: SPAN_STATUS_ERROR, message: 'unknown_error' };\n      }\n    }\n  }\n\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n  const inferredStatus = inferStatusFromAttributes(attributes);\n\n  if (inferredStatus) {\n    return inferredStatus;\n  }\n\n  // We default to setting the spans status to ok.\n  if (status?.code === SpanStatusCode.UNSET) {\n    return { code: SPAN_STATUS_OK };\n  } else {\n    return { code: SPAN_STATUS_ERROR, message: 'unknown_error' };\n  }\n}\n\nfunction inferStatusFromAttributes(attributes: SpanAttributes): SpanStatus | undefined {\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n\n  // eslint-disable-next-line deprecation/deprecation\n  const httpCodeAttribute = attributes[ATTR_HTTP_RESPONSE_STATUS_CODE] || attributes[SEMATTRS_HTTP_STATUS_CODE];\n  // eslint-disable-next-line deprecation/deprecation\n  const grpcCodeAttribute = attributes[SEMATTRS_RPC_GRPC_STATUS_CODE];\n\n  const numberHttpCode =\n    typeof httpCodeAttribute === 'number'\n      ? httpCodeAttribute\n      : typeof httpCodeAttribute === 'string'\n        ? parseInt(httpCodeAttribute)\n        : undefined;\n\n  if (typeof numberHttpCode === 'number') {\n    return getSpanStatusFromHttpCode(numberHttpCode);\n  }\n\n  if (typeof grpcCodeAttribute === 'string') {\n    return { code: SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || 'unknown_error' };\n  }\n\n  return undefined;\n}\n","/* eslint-disable max-lines */\nimport type { Span } from '@opentelemetry/api';\nimport { SpanKind } from '@opentelemetry/api';\nimport type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport { ATTR_HTTP_RESPONSE_STATUS_CODE, SEMATTRS_HTTP_STATUS_CODE } from '@opentelemetry/semantic-conventions';\nimport type {\n  SpanAttributes,\n  SpanJSON,\n  SpanOrigin,\n  TraceContext,\n  TransactionEvent,\n  TransactionSource,\n} from '@sentry/core';\nimport {\n  captureEvent,\n  convertSpanLinksForEnvelope,\n  debounce,\n  getCapturedScopesOnSpan,\n  getDynamicSamplingContextFromSpan,\n  getStatusMessage,\n  logger,\n  SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  spanTimeInputToSeconds,\n  timedEventsToMeasurements,\n} from '@sentry/core';\nimport { DEBUG_BUILD } from './debug-build';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE } from './semanticAttributes';\nimport { getParentSpanId } from './utils/getParentSpanId';\nimport { getRequestSpanData } from './utils/getRequestSpanData';\nimport type { SpanNode } from './utils/groupSpansWithParents';\nimport { getLocalParentId, groupSpansWithParents } from './utils/groupSpansWithParents';\nimport { mapStatus } from './utils/mapStatus';\nimport { parseSpanDescription } from './utils/parseSpanDescription';\n\ntype SpanNodeCompleted = SpanNode & { span: ReadableSpan };\n\nconst MAX_SPAN_COUNT = 1000;\nconst DEFAULT_TIMEOUT = 300; // 5 min\n\ninterface FinishedSpanBucket {\n  timestampInS: number;\n  spans: Set<ReadableSpan>;\n}\n\n/**\n * A Sentry-specific exporter that converts OpenTelemetry Spans to Sentry Spans & Transactions.\n */\nexport class SentrySpanExporter {\n  /*\n   * A quick explanation on the buckets: We do bucketing of finished spans for efficiency. This span exporter is\n   * accumulating spans until a root span is encountered and then it flushes all the spans that are descendants of that\n   * root span. Because it is totally in the realm of possibilities that root spans are never finished, and we don't\n   * want to accumulate spans indefinitely in memory, we need to periodically evacuate spans. Naively we could simply\n   * store the spans in an array and each time a new span comes in we could iterate through the entire array and\n   * evacuate all spans that have an end-timestamp that is older than our limit. This could get quite expensive because\n   * we would have to iterate a potentially large number of spans every time we evacuate. We want to avoid these large\n   * bursts of computation.\n   *\n   * Instead we go for a bucketing approach and put spans into buckets, based on what second\n   * (modulo the time limit) the span was put into the exporter. With buckets, when we decide to evacuate, we can\n   * iterate through the bucket entries instead, which have an upper bound of items, making the evacuation much more\n   * efficient. Cleaning up also becomes much more efficient since it simply involves de-referencing a bucket within the\n   * bucket array, and letting garbage collection take care of the rest.\n   */\n  private _finishedSpanBuckets: (FinishedSpanBucket | undefined)[];\n  private _finishedSpanBucketSize: number;\n  private _spansToBucketEntry: WeakMap<ReadableSpan, FinishedSpanBucket>;\n  private _lastCleanupTimestampInS: number;\n  // Essentially a a set of span ids that are already sent. The values are expiration\n  // times in this cache so we don't hold onto them indefinitely.\n  private _sentSpans: Map<string, number>;\n  /* Internally, we use a debounced flush to give some wiggle room to the span processor to accumulate more spans. */\n  private _debouncedFlush: ReturnType<typeof debounce>;\n\n  public constructor(options?: {\n    /** Lower bound of time in seconds until spans that are buffered but have not been sent as part of a transaction get cleared from memory. */\n    timeout?: number;\n  }) {\n    this._finishedSpanBucketSize = options?.timeout || DEFAULT_TIMEOUT;\n    this._finishedSpanBuckets = new Array(this._finishedSpanBucketSize).fill(undefined);\n    this._lastCleanupTimestampInS = Math.floor(Date.now() / 1000);\n    this._spansToBucketEntry = new WeakMap();\n    this._sentSpans = new Map<string, number>();\n    this._debouncedFlush = debounce(this.flush.bind(this), 1, { maxWait: 100 });\n  }\n\n  /**\n   * Export a single span.\n   * This is called by the span processor whenever a span is ended.\n   */\n  public export(span: ReadableSpan): void {\n    const currentTimestampInS = Math.floor(Date.now() / 1000);\n\n    if (this._lastCleanupTimestampInS !== currentTimestampInS) {\n      let droppedSpanCount = 0;\n      this._finishedSpanBuckets.forEach((bucket, i) => {\n        if (bucket && bucket.timestampInS <= currentTimestampInS - this._finishedSpanBucketSize) {\n          droppedSpanCount += bucket.spans.size;\n          this._finishedSpanBuckets[i] = undefined;\n        }\n      });\n      if (droppedSpanCount > 0) {\n        DEBUG_BUILD &&\n          logger.log(\n            `SpanExporter dropped ${droppedSpanCount} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`,\n          );\n      }\n      this._lastCleanupTimestampInS = currentTimestampInS;\n    }\n\n    const currentBucketIndex = currentTimestampInS % this._finishedSpanBucketSize;\n    const currentBucket = this._finishedSpanBuckets[currentBucketIndex] || {\n      timestampInS: currentTimestampInS,\n      spans: new Set(),\n    };\n    this._finishedSpanBuckets[currentBucketIndex] = currentBucket;\n    currentBucket.spans.add(span);\n    this._spansToBucketEntry.set(span, currentBucket);\n\n    // If the span doesn't have a local parent ID (it's a root span), we're gonna flush all the ended spans\n    const localParentId = getLocalParentId(span);\n    if (!localParentId || this._sentSpans.has(localParentId)) {\n      this._debouncedFlush();\n    }\n  }\n\n  /**\n   * Try to flush any pending spans immediately.\n   * This is called internally by the exporter (via _debouncedFlush),\n   * but can also be triggered externally if we force-flush.\n   */\n  public flush(): void {\n    const finishedSpans = this._finishedSpanBuckets.flatMap(bucket => (bucket ? Array.from(bucket.spans) : []));\n\n    this._flushSentSpanCache();\n    const sentSpans = this._maybeSend(finishedSpans);\n\n    const sentSpanCount = sentSpans.size;\n    const remainingOpenSpanCount = finishedSpans.length - sentSpanCount;\n    DEBUG_BUILD &&\n      logger.log(\n        `SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} spans are waiting for their parent spans to finish`,\n      );\n\n    const expirationDate = Date.now() + DEFAULT_TIMEOUT * 1000;\n\n    for (const span of sentSpans) {\n      this._sentSpans.set(span.spanContext().spanId, expirationDate);\n      const bucketEntry = this._spansToBucketEntry.get(span);\n      if (bucketEntry) {\n        bucketEntry.spans.delete(span);\n      }\n    }\n    // Cancel a pending debounced flush, if there is one\n    // This can be relevant if we directly flush, circumventing the debounce\n    // in that case, we want to cancel any pending debounced flush\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Clear the exporter.\n   * This is called when the span processor is shut down.\n   */\n  public clear(): void {\n    this._finishedSpanBuckets = this._finishedSpanBuckets.fill(undefined);\n    this._sentSpans.clear();\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Send the given spans, but only if they are part of a finished transaction.\n   *\n   * Returns the sent spans.\n   * Spans remain unsent when their parent span is not yet finished.\n   * This will happen regularly, as child spans are generally finished before their parents.\n   * But it _could_ also happen because, for whatever reason, a parent span was lost.\n   * In this case, we'll eventually need to clean this up.\n   */\n  private _maybeSend(spans: ReadableSpan[]): Set<ReadableSpan> {\n    const grouped = groupSpansWithParents(spans);\n    const sentSpans = new Set<ReadableSpan>();\n\n    const rootNodes = this._getCompletedRootNodes(grouped);\n\n    for (const root of rootNodes) {\n      const span = root.span;\n      sentSpans.add(span);\n      const transactionEvent = createTransactionForOtelSpan(span);\n\n      // We'll recursively add all the child spans to this array\n      const spans = transactionEvent.spans || [];\n\n      for (const child of root.children) {\n        createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n      }\n\n      // spans.sort() mutates the array, but we do not use this anymore after this point\n      // so we can safely mutate it here\n      transactionEvent.spans =\n        spans.length > MAX_SPAN_COUNT\n          ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n          : spans;\n\n      const measurements = timedEventsToMeasurements(span.events);\n      if (measurements) {\n        transactionEvent.measurements = measurements;\n      }\n\n      captureEvent(transactionEvent);\n    }\n\n    return sentSpans;\n  }\n\n  /** Remove \"expired\" span id entries from the _sentSpans cache. */\n  private _flushSentSpanCache(): void {\n    const currentTimestamp = Date.now();\n    // Note, it is safe to delete items from the map as we go: https://stackoverflow.com/a/35943995/90297\n    for (const [spanId, expirationTime] of this._sentSpans.entries()) {\n      if (expirationTime <= currentTimestamp) {\n        this._sentSpans.delete(spanId);\n      }\n    }\n  }\n\n  /** Check if a node is a completed root node or a node whose parent has already been sent */\n  private _nodeIsCompletedRootNodeOrHasSentParent(node: SpanNode): node is SpanNodeCompleted {\n    return !!node.span && (!node.parentNode || this._sentSpans.has(node.parentNode.id));\n  }\n\n  /** Get all completed root nodes from a list of nodes */\n  private _getCompletedRootNodes(nodes: SpanNode[]): SpanNodeCompleted[] {\n    // TODO: We should be able to remove the explicit `node is SpanNodeCompleted` type guard\n    //       once we stop supporting TS < 5.5\n    return nodes.filter((node): node is SpanNodeCompleted => this._nodeIsCompletedRootNodeOrHasSentParent(node));\n  }\n}\n\nfunction parseSpan(span: ReadableSpan): { op?: string; origin?: SpanOrigin; source?: TransactionSource } {\n  const attributes = span.attributes;\n\n  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] as SpanOrigin | undefined;\n  const op = attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] as string | undefined;\n  const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] as TransactionSource | undefined;\n\n  return { origin, op, source };\n}\n\n/** Exported only for tests. */\nexport function createTransactionForOtelSpan(span: ReadableSpan): TransactionEvent {\n  const { op, description, data, origin = 'manual', source } = getSpanData(span);\n  const capturedSpanScopes = getCapturedScopesOnSpan(span as unknown as Span);\n\n  const sampleRate = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] as number | undefined;\n\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n    [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    ...data,\n    ...removeSentryAttributes(span.attributes),\n  };\n\n  const { links } = span;\n  const { traceId: trace_id, spanId: span_id } = span.spanContext();\n\n  // If parentSpanIdFromTraceState is defined at all, we want it to take precedence\n  // In that case, an empty string should be interpreted as \"no parent span id\",\n  // even if `span.parentSpanId` is set\n  // this is the case when we are starting a new trace, where we have a virtual span based on the propagationContext\n  // We only want to continue the traceId in this case, but ignore the parent span\n  const parent_span_id = getParentSpanId(span);\n\n  const status = mapStatus(span);\n\n  const traceContext: TraceContext = {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data: attributes,\n    origin,\n    op,\n    status: getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    links: convertSpanLinksForEnvelope(links),\n  };\n\n  const statusCode = attributes[ATTR_HTTP_RESPONSE_STATUS_CODE];\n  const responseContext = typeof statusCode === 'number' ? { response: { status_code: statusCode } } : undefined;\n\n  const transactionEvent: TransactionEvent = {\n    contexts: {\n      trace: traceContext,\n      otel: {\n        resource: span.resource.attributes,\n      },\n      ...responseContext,\n    },\n    spans: [],\n    start_timestamp: spanTimeInputToSeconds(span.startTime),\n    timestamp: spanTimeInputToSeconds(span.endTime),\n    transaction: description,\n    type: 'transaction',\n    sdkProcessingMetadata: {\n      capturedSpanScope: capturedSpanScopes.scope,\n      capturedSpanIsolationScope: capturedSpanScopes.isolationScope,\n      sampleRate,\n      dynamicSamplingContext: getDynamicSamplingContextFromSpan(span as unknown as Span),\n    },\n    ...(source && {\n      transaction_info: {\n        source,\n      },\n    }),\n  };\n\n  return transactionEvent;\n}\n\nfunction createAndFinishSpanForOtelSpan(node: SpanNode, spans: SpanJSON[], sentSpans: Set<ReadableSpan>): void {\n  const span = node.span;\n\n  if (span) {\n    sentSpans.add(span);\n  }\n\n  const shouldDrop = !span;\n\n  // If this span should be dropped, we still want to create spans for the children of this\n  if (shouldDrop) {\n    node.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n    });\n    return;\n  }\n\n  const span_id = span.spanContext().spanId;\n  const trace_id = span.spanContext().traceId;\n  const parentSpanId = getParentSpanId(span);\n\n  const { attributes, startTime, endTime, links } = span;\n\n  const { op, description, data, origin = 'manual' } = getSpanData(span);\n  const allData = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    ...removeSentryAttributes(attributes),\n    ...data,\n  };\n\n  const status = mapStatus(span);\n\n  const spanJSON: SpanJSON = {\n    span_id,\n    trace_id,\n    data: allData,\n    description,\n    parent_span_id: parentSpanId,\n    start_timestamp: spanTimeInputToSeconds(startTime),\n    // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n    timestamp: spanTimeInputToSeconds(endTime) || undefined,\n    status: getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    op,\n    origin,\n    measurements: timedEventsToMeasurements(span.events),\n    links: convertSpanLinksForEnvelope(links),\n  };\n\n  spans.push(spanJSON);\n\n  node.children.forEach(child => {\n    createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n  });\n}\n\nfunction getSpanData(span: ReadableSpan): {\n  data: Record<string, unknown>;\n  op?: string;\n  description: string;\n  source?: TransactionSource;\n  origin?: SpanOrigin;\n} {\n  const { op: definedOp, source: definedSource, origin } = parseSpan(span);\n  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);\n\n  const op = definedOp || inferredOp;\n  const source = definedSource || inferredSource;\n\n  const data = { ...inferredData, ...getData(span) };\n\n  return {\n    op,\n    description,\n    source,\n    origin,\n    data,\n  };\n}\n\n/**\n * Remove custom `sentry.` attributes we do not need to send.\n * These are more carrier attributes we use inside of the SDK, we do not need to send them to the API.\n */\nfunction removeSentryAttributes(data: Record<string, unknown>): Record<string, unknown> {\n  const cleanedData = { ...data };\n\n  /* eslint-disable @typescript-eslint/no-dynamic-delete */\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  /* eslint-enable @typescript-eslint/no-dynamic-delete */\n\n  return cleanedData;\n}\n\nfunction getData(span: ReadableSpan): Record<string, unknown> {\n  const attributes = span.attributes;\n  const data: Record<string, unknown> = {};\n\n  if (span.kind !== SpanKind.INTERNAL) {\n    data['otel.kind'] = SpanKind[span.kind];\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeHttpStatusCodeAttribute = attributes[SEMATTRS_HTTP_STATUS_CODE];\n  if (maybeHttpStatusCodeAttribute) {\n    data[ATTR_HTTP_RESPONSE_STATUS_CODE] = maybeHttpStatusCodeAttribute as string;\n  }\n\n  const requestData = getRequestSpanData(span);\n\n  if (requestData.url) {\n    data.url = requestData.url;\n  }\n\n  if (requestData['http.query']) {\n    data['http.query'] = requestData['http.query'].slice(1);\n  }\n  if (requestData['http.fragment']) {\n    data['http.fragment'] = requestData['http.fragment'].slice(1);\n  }\n\n  return data;\n}\n","import type { Context } from '@opentelemetry/api';\nimport { ROOT_CONTEXT, trace } from '@opentelemetry/api';\nimport type { ReadableSpan, Span, SpanProcessor as SpanProcessorInterface } from '@opentelemetry/sdk-trace-base';\nimport {\n  addChildSpanToSpan,\n  getClient,\n  getDefaultCurrentScope,\n  getDefaultIsolationScope,\n  logSpanEnd,\n  logSpanStart,\n  setCapturedScopesOnSpan,\n} from '@sentry/core';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE } from './semanticAttributes';\nimport { SentrySpanExporter } from './spanExporter';\nimport { getScopesFromContext } from './utils/contextData';\nimport { setIsSetup } from './utils/setupCheck';\n\nfunction onSpanStart(span: Span, parentContext: Context): void {\n  // This is a reliable way to get the parent span - because this is exactly how the parent is identified in the OTEL SDK\n  const parentSpan = trace.getSpan(parentContext);\n\n  let scopes = getScopesFromContext(parentContext);\n\n  // We need access to the parent span in order to be able to move up the span tree for breadcrumbs\n  if (parentSpan && !parentSpan.spanContext().isRemote) {\n    addChildSpanToSpan(parentSpan, span);\n  }\n\n  // We need this in the span exporter\n  if (parentSpan?.spanContext().isRemote) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);\n  }\n\n  // The root context does not have scopes stored, so we check for this specifically\n  // As fallback we attach the global scopes\n  if (parentContext === ROOT_CONTEXT) {\n    scopes = {\n      scope: getDefaultCurrentScope(),\n      isolationScope: getDefaultIsolationScope(),\n    };\n  }\n\n  // We need the scope at time of span creation in order to apply it to the event when the span is finished\n  if (scopes) {\n    setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);\n  }\n\n  logSpanStart(span);\n\n  const client = getClient();\n  client?.emit('spanStart', span);\n}\n\nfunction onSpanEnd(span: Span): void {\n  logSpanEnd(span);\n\n  const client = getClient();\n  client?.emit('spanEnd', span);\n}\n\n/**\n * Converts OpenTelemetry Spans to Sentry Spans and sends them to Sentry via\n * the Sentry SDK.\n */\nexport class SentrySpanProcessor implements SpanProcessorInterface {\n  private _exporter: SentrySpanExporter;\n\n  public constructor(options?: { timeout?: number }) {\n    setIsSetup('SentrySpanProcessor');\n    this._exporter = new SentrySpanExporter(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async forceFlush(): Promise<void> {\n    this._exporter.flush();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async shutdown(): Promise<void> {\n    this._exporter.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public onStart(span: Span, parentContext: Context): void {\n    onSpanStart(span, parentContext);\n  }\n\n  /** @inheritDoc */\n  public onEnd(span: Span & ReadableSpan): void {\n    onSpanEnd(span);\n\n    this._exporter.export(span);\n  }\n}\n","/* eslint-disable complexity */\nimport type { Context, Span, TraceState as TraceStateInterface } from '@opentelemetry/api';\nimport { isSpanContextValid, SpanKind, trace } from '@opentelemetry/api';\nimport { TraceState } from '@opentelemetry/core';\nimport type { Sampler, SamplingResult } from '@opentelemetry/sdk-trace-base';\nimport { SamplingDecision } from '@opentelemetry/sdk-trace-base';\nimport {\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_URL_FULL,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_URL,\n} from '@opentelemetry/semantic-conventions';\nimport type { Client, SpanAttributes } from '@sentry/core';\nimport {\n  baggageHeaderToDynamicSamplingContext,\n  hasSpansEnabled,\n  logger,\n  parseSampleRate,\n  sampleSpan,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,\n} from '@sentry/core';\nimport {\n  SENTRY_TRACE_STATE_DSC,\n  SENTRY_TRACE_STATE_SAMPLE_RAND,\n  SENTRY_TRACE_STATE_SAMPLE_RATE,\n  SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING,\n  SENTRY_TRACE_STATE_URL,\n} from './constants';\nimport { DEBUG_BUILD } from './debug-build';\nimport { getScopesFromContext } from './utils/contextData';\nimport { getSamplingDecision } from './utils/getSamplingDecision';\nimport { inferSpanData } from './utils/parseSpanDescription';\nimport { setIsSetup } from './utils/setupCheck';\n\n/**\n * A custom OTEL sampler that uses Sentry sampling rates to make its decision\n */\nexport class SentrySampler implements Sampler {\n  private _client: Client;\n\n  public constructor(client: Client) {\n    this._client = client;\n    setIsSetup('SentrySampler');\n  }\n\n  /** @inheritDoc */\n  public shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    spanAttributes: SpanAttributes,\n    _links: unknown,\n  ): SamplingResult {\n    const options = this._client.getOptions();\n\n    const parentSpan = getValidSpan(context);\n    const parentContext = parentSpan?.spanContext();\n\n    if (!hasSpansEnabled(options)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    // `ATTR_HTTP_REQUEST_METHOD` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_METHOD`, for now.\n    // eslint-disable-next-line deprecation/deprecation\n    const maybeSpanHttpMethod = spanAttributes[SEMATTRS_HTTP_METHOD] || spanAttributes[ATTR_HTTP_REQUEST_METHOD];\n\n    // If we have a http.client span that has no local parent, we never want to sample it\n    // but we want to leave downstream sampling decisions up to the server\n    if (spanKind === SpanKind.CLIENT && maybeSpanHttpMethod && (!parentSpan || parentContext?.isRemote)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;\n    const isRootSpan = !parentSpan || parentContext?.isRemote;\n\n    // We only sample based on parameters (like tracesSampleRate or tracesSampler) for root spans (which is done in sampleSpan).\n    // Non-root-spans simply inherit the sampling decision from their parent.\n    if (!isRootSpan) {\n      return wrapSamplingDecision({\n        decision: parentSampled ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n      });\n    }\n\n    // We want to pass the inferred name & attributes to the sampler method\n    const {\n      description: inferredSpanName,\n      data: inferredAttributes,\n      op,\n    } = inferSpanData(spanName, spanAttributes, spanKind);\n\n    const mergedAttributes = {\n      ...inferredAttributes,\n      ...spanAttributes,\n    };\n\n    if (op) {\n      mergedAttributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] = op;\n    }\n\n    const mutableSamplingDecision = { decision: true };\n    this._client.emit(\n      'beforeSampling',\n      {\n        spanAttributes: mergedAttributes,\n        spanName: inferredSpanName,\n        parentSampled: parentSampled,\n        parentContext: parentContext,\n      },\n      mutableSamplingDecision,\n    );\n    if (!mutableSamplingDecision.decision) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const { isolationScope } = getScopesFromContext(context) ?? {};\n\n    const dscString = parentContext?.traceState ? parentContext.traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n    const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n    const sampleRand = parseSampleRate(dsc?.sample_rand) ?? Math.random();\n\n    const [sampled, sampleRate, localSampleRateWasApplied] = sampleSpan(\n      options,\n      {\n        name: inferredSpanName,\n        attributes: mergedAttributes,\n        normalizedRequest: isolationScope?.getScopeData().sdkProcessingMetadata.normalizedRequest,\n        parentSampled,\n        parentSampleRate: parseSampleRate(dsc?.sample_rate),\n      },\n      sampleRand,\n    );\n\n    const method = `${maybeSpanHttpMethod}`.toUpperCase();\n    if (method === 'OPTIONS' || method === 'HEAD') {\n      DEBUG_BUILD && logger.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);\n\n      return wrapSamplingDecision({\n        decision: SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: 0, // we don't want to sample anything in the downstream trace either\n      });\n    }\n\n    if (\n      !sampled &&\n      // We check for `parentSampled === undefined` because we only want to record client reports for spans that are trace roots (ie. when there was incoming trace)\n      parentSampled === undefined\n    ) {\n      DEBUG_BUILD && logger.log('[Tracing] Discarding root span because its trace was not chosen to be sampled.');\n      this._client.recordDroppedEvent('sample_rate', 'transaction');\n    }\n\n    return {\n      ...wrapSamplingDecision({\n        decision: sampled ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: localSampleRateWasApplied ? sampleRate : undefined,\n      }),\n      attributes: {\n        // We set the sample rate on the span when a local sample rate was applied to better understand how traces were sampled in Sentry\n        [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: localSampleRateWasApplied ? sampleRate : undefined,\n      },\n    };\n  }\n\n  /** Returns the sampler name or short description with the configuration. */\n  public toString(): string {\n    return 'SentrySampler';\n  }\n}\n\nfunction getParentSampled(parentSpan: Span, traceId: string, spanName: string): boolean | undefined {\n  const parentContext = parentSpan.spanContext();\n\n  // Only inherit sample rate if `traceId` is the same\n  // Note for testing: `isSpanContextValid()` checks the format of the traceId/spanId, so we need to pass valid ones\n  if (isSpanContextValid(parentContext) && parentContext.traceId === traceId) {\n    if (parentContext.isRemote) {\n      const parentSampled = getSamplingDecision(parentSpan.spanContext());\n      DEBUG_BUILD &&\n        logger.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled}`);\n      return parentSampled;\n    }\n\n    const parentSampled = getSamplingDecision(parentContext);\n    DEBUG_BUILD && logger.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);\n    return parentSampled;\n  }\n\n  return undefined;\n}\n\n/**\n * Wrap a sampling decision with data that Sentry needs to work properly with it.\n * If you pass `decision: undefined`, it will be treated as `NOT_RECORDING`, but in contrast to passing `NOT_RECORDING`\n * it will not propagate this decision to downstream Sentry SDKs.\n */\nexport function wrapSamplingDecision({\n  decision,\n  context,\n  spanAttributes,\n  sampleRand,\n  downstreamTraceSampleRate,\n}: {\n  decision: SamplingDecision | undefined;\n  context: Context;\n  spanAttributes: SpanAttributes;\n  sampleRand?: number;\n  downstreamTraceSampleRate?: number;\n}): SamplingResult {\n  let traceState = getBaseTraceState(context, spanAttributes);\n\n  // We will override the propagated sample rate downstream when\n  // - the tracesSampleRate is applied\n  // - the tracesSampler is invoked\n  // Since unsampled OTEL spans (NonRecordingSpans) cannot hold attributes we need to store this on the (trace)context.\n  if (downstreamTraceSampleRate !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RATE, `${downstreamTraceSampleRate}`);\n  }\n\n  if (sampleRand !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RAND, `${sampleRand}`);\n  }\n\n  // If the decision is undefined, we treat it as NOT_RECORDING, but we don't propagate this decision to downstream SDKs\n  // Which is done by not setting `SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING` traceState\n  if (decision == undefined) {\n    return { decision: SamplingDecision.NOT_RECORD, traceState };\n  }\n\n  if (decision === SamplingDecision.NOT_RECORD) {\n    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') };\n  }\n\n  return { decision, traceState };\n}\n\nfunction getBaseTraceState(context: Context, spanAttributes: SpanAttributes): TraceStateInterface {\n  const parentSpan = trace.getSpan(context);\n  const parentContext = parentSpan?.spanContext();\n\n  let traceState = parentContext?.traceState || new TraceState();\n\n  // We always keep the URL on the trace state, so we can access it in the propagator\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const url = spanAttributes[SEMATTRS_HTTP_URL] || spanAttributes[ATTR_URL_FULL];\n  if (url && typeof url === 'string') {\n    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);\n  }\n\n  return traceState;\n}\n\n/**\n * If the active span is invalid, we want to ignore it as parent.\n * This aligns with how otel tracers and default samplers handle these cases.\n */\nfunction getValidSpan(context: Context): Span | undefined {\n  const span = trace.getSpan(context);\n  return span && isSpanContextValid(span.spanContext()) ? span : undefined;\n}\n"],"names":["ATTR_URL_FULL","SEMATTRS_HTTP_URL","ATTR_HTTP_REQUEST_METHOD","SEMATTRS_HTTP_METHOD","parseUrl","getSanitizedUrlString","SDK_VERSION","trace","SpanKind","createContextKey","addNonEnumerableProperty","isSentryRequestUrl","getClient","TraceFlags","baggageHeaderToDynamicSamplingContext","SEMATTRS_DB_SYSTEM","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","SEMATTRS_RPC_SERVICE","SEMATTRS_MESSAGING_SYSTEM","SEMATTRS_FAAS_TRIGGER","SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME","SEMATTRS_DB_STATEMENT","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMATTRS_HTTP_TARGET","ATTR_HTTP_ROUTE","stripUrlQueryAndFragment","spanToJSON","hasSpansEnabled","dynamicSamplingContextToSentryBaggageHeader","TraceState","W3CBaggagePropagator","LRUMap","isTracingSuppressed","logger","propagation","parseBaggageHeader","SENTRY_BAGGAGE_KEY_PREFIX","INVALID_TRACEID","generateSentryTraceHeader","stringMatchesSomePattern","getDynamicSamplingContextFromSpan","getCurrentScope","getDynamicSamplingContextFromScope","propagationContextFromHeaders","context","getIsolationScope","suppressTracing","handleCallbackErrors","SpanStatusCode","getRootSpan","spanToTraceContext","getTraceContextFromScope","suppressTracingImpl","getCapturedScopesOnSpan","getDefaultCurrentScope","getDefaultIsolationScope","setAsyncContextStrategy","SPAN_STATUS_OK","SPAN_STATUS_ERROR","ATTR_HTTP_RESPONSE_STATUS_CODE","SEMATTRS_HTTP_STATUS_CODE","SEMATTRS_RPC_GRPC_STATUS_CODE","getSpanStatusFromHttpCode","debounce","timedEventsToMeasurements","captureEvent","SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE","getStatusMessage","convertSpanLinksForEnvelope","spanTimeInputToSeconds","addChildSpanToSpan","ROOT_CONTEXT","setCapturedScopesOnSpan","logSpanStart","logSpanEnd","SamplingDecision","parseSampleRate","sampleSpan","isSpanContextValid"],"mappings":"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"}},
    {"offset": {"line": 1886, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1890, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/semanticAttributes.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/getParentSpanId.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/spanTypes.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/getRequestSpanData.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/custom/client.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/getSpanKind.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/constants.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/contextData.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/isSentryRequest.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/getSamplingDecision.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/parseSpanDescription.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/enhanceDscWithOpenTelemetryRootSpanName.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/getActiveSpan.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/debug-build.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/makeTraceState.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/setupCheck.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/propagator.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/trace.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/suppressTracing.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/setupEventContextTrace.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/getTraceData.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/asyncContextStrategy.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/contextManager.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/groupSpansWithParents.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/utils/mapStatus.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/spanExporter.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/spanProcessor.ts","/turbopack/[project]/node_modules/.pnpm/@sentry+opentelemetry@9.37.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2.0._qbgfklvysmswtj4i5ugwwu22mu/node_modules/@sentry/opentelemetry/src/sampler.ts"],"sourcesContent":["/** If this attribute is true, it means that the parent is a remote span. */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = 'sentry.parentIsRemote';\n\n// These are not standardized yet, but used by the graphql instrumentation\nexport const SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = 'sentry.graphql.operation';\n","import type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\n\n/**\n * Get the parent span id from a span.\n * In OTel v1, the parent span id is accessed as `parentSpanId`\n * In OTel v2, the parent span id is accessed as `spanId` on the `parentSpanContext`\n */\nexport function getParentSpanId(span: ReadableSpan): string | undefined {\n  if ('parentSpanId' in span) {\n    return span.parentSpanId as string | undefined;\n  } else if ('parentSpanContext' in span) {\n    return (span.parentSpanContext as { spanId?: string } | undefined)?.spanId;\n  }\n\n  return undefined;\n}\n","import type { SpanKind, SpanStatus } from '@opentelemetry/api';\nimport type { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base';\nimport type { AbstractSpan } from '../types';\nimport { getParentSpanId } from './getParentSpanId';\n\n/**\n * Check if a given span has attributes.\n * This is necessary because the base `Span` type does not have attributes,\n * so in places where we are passed a generic span, we need to check if we want to access them.\n */\nexport function spanHasAttributes<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { attributes: ReadableSpan['attributes'] } {\n  const castSpan = span as ReadableSpan;\n  return !!castSpan.attributes && typeof castSpan.attributes === 'object';\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasKind<SpanType extends AbstractSpan>(span: SpanType): span is SpanType & { kind: SpanKind } {\n  const castSpan = span as ReadableSpan;\n  return typeof castSpan.kind === 'number';\n}\n\n/**\n * Check if a given span has a status.\n * This is necessary because the base `Span` type does not have a status,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasStatus<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { status: SpanStatus } {\n  const castSpan = span as ReadableSpan;\n  return !!castSpan.status;\n}\n\n/**\n * Check if a given span has a name.\n * This is necessary because the base `Span` type does not have a name,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasName<SpanType extends AbstractSpan>(span: SpanType): span is SpanType & { name: string } {\n  const castSpan = span as ReadableSpan;\n  return !!castSpan.name;\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasParentId<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { parentSpanId: string } {\n  const castSpan = span as ReadableSpan;\n  return !!getParentSpanId(castSpan);\n}\n\n/**\n * Check if a given span has events.\n * This is necessary because the base `Span` type does not have events,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasEvents<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { events: TimedEvent[] } {\n  const castSpan = span as ReadableSpan;\n  return Array.isArray(castSpan.events);\n}\n","import type { Span } from '@opentelemetry/api';\nimport type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport {\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_URL_FULL,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_URL,\n} from '@opentelemetry/semantic-conventions';\nimport type { SanitizedRequestData } from '@sentry/core';\nimport { getSanitizedUrlString, parseUrl } from '@sentry/core';\nimport { spanHasAttributes } from './spanTypes';\n\n/**\n * Get sanitizied request data from an OTEL span.\n */\nexport function getRequestSpanData(span: Span | ReadableSpan): Partial<SanitizedRequestData> {\n  // The base `Span` type has no `attributes`, so we need to guard here against that\n  if (!spanHasAttributes(span)) {\n    return {};\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeUrlAttribute = (span.attributes[ATTR_URL_FULL] || span.attributes[SEMATTRS_HTTP_URL]) as\n    | string\n    | undefined;\n\n  const data: Partial<SanitizedRequestData> = {\n    url: maybeUrlAttribute,\n    // eslint-disable-next-line deprecation/deprecation\n    'http.method': (span.attributes[ATTR_HTTP_REQUEST_METHOD] || span.attributes[SEMATTRS_HTTP_METHOD]) as\n      | string\n      | undefined,\n  };\n\n  // Default to GET if URL is set but method is not\n  if (!data['http.method'] && data.url) {\n    data['http.method'] = 'GET';\n  }\n\n  try {\n    if (typeof maybeUrlAttribute === 'string') {\n      const url = parseUrl(maybeUrlAttribute);\n\n      data.url = getSanitizedUrlString(url);\n\n      if (url.search) {\n        data['http.query'] = url.search;\n      }\n      if (url.hash) {\n        data['http.fragment'] = url.hash;\n      }\n    }\n  } catch {\n    // ignore\n  }\n\n  return data;\n}\n","import type { Tracer } from '@opentelemetry/api';\nimport { trace } from '@opentelemetry/api';\nimport type { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport type { Client } from '@sentry/core';\nimport { SDK_VERSION } from '@sentry/core';\nimport type { OpenTelemetryClient as OpenTelemetryClientInterface } from '../types';\n\n// Typescript complains if we do not use `...args: any[]` for the mixin, with:\n// A mixin class must have a constructor with a single rest parameter of type 'any[]'.ts(2545)\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Wrap an Client class with things we need for OpenTelemetry support.\n * Make sure that the Client class passed in is non-abstract!\n *\n * Usage:\n * const OpenTelemetryClient = getWrappedClientClass(NodeClient);\n * const client = new OpenTelemetryClient(options);\n */\nexport function wrapClientClass<\n  ClassConstructor extends new (...args: any[]) => Client,\n  WrappedClassConstructor extends new (...args: any[]) => Client & OpenTelemetryClientInterface,\n>(ClientClass: ClassConstructor): WrappedClassConstructor {\n  // @ts-expect-error We just assume that this is non-abstract, if you pass in an abstract class this would make it non-abstract\n  class OpenTelemetryClient extends ClientClass implements OpenTelemetryClientInterface {\n    public traceProvider: BasicTracerProvider | undefined;\n    private _tracer: Tracer | undefined;\n\n    public constructor(...args: any[]) {\n      super(...args);\n    }\n\n    /** Get the OTEL tracer. */\n    public get tracer(): Tracer {\n      if (this._tracer) {\n        return this._tracer;\n      }\n\n      const name = '@sentry/opentelemetry';\n      const version = SDK_VERSION;\n      const tracer = trace.getTracer(name, version);\n      this._tracer = tracer;\n\n      return tracer;\n    }\n\n    /**\n     * @inheritDoc\n     */\n    public async flush(timeout?: number): Promise<boolean> {\n      const provider = this.traceProvider;\n      await provider?.forceFlush();\n      return super.flush(timeout);\n    }\n  }\n\n  return OpenTelemetryClient as unknown as WrappedClassConstructor;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n","import { SpanKind } from '@opentelemetry/api';\nimport type { AbstractSpan } from '../types';\nimport { spanHasKind } from './spanTypes';\n\n/**\n * Get the span kind from a span.\n * For whatever reason, this is not public API on the generic \"Span\" type,\n * so we need to check if we actually have a `SDKTraceBaseSpan` where we can fetch this from.\n * Otherwise, we fall back to `SpanKind.INTERNAL`.\n */\nexport function getSpanKind(span: AbstractSpan): SpanKind {\n  if (spanHasKind(span)) {\n    return span.kind;\n  }\n\n  return SpanKind.INTERNAL;\n}\n","import { createContextKey } from '@opentelemetry/api';\n\nexport const SENTRY_TRACE_HEADER = 'sentry-trace';\nexport const SENTRY_BAGGAGE_HEADER = 'baggage';\n\nexport const SENTRY_TRACE_STATE_DSC = 'sentry.dsc';\nexport const SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = 'sentry.sampled_not_recording';\nexport const SENTRY_TRACE_STATE_URL = 'sentry.url';\nexport const SENTRY_TRACE_STATE_SAMPLE_RAND = 'sentry.sample_rand';\nexport const SENTRY_TRACE_STATE_SAMPLE_RATE = 'sentry.sample_rate';\n\nexport const SENTRY_SCOPES_CONTEXT_KEY = createContextKey('sentry_scopes');\n\nexport const SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = createContextKey('sentry_fork_isolation_scope');\n\nexport const SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = createContextKey('sentry_fork_set_scope');\n\nexport const SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = createContextKey('sentry_fork_set_isolation_scope');\n","import type { Context } from '@opentelemetry/api';\nimport type { Scope } from '@sentry/core';\nimport { addNonEnumerableProperty } from '@sentry/core';\nimport { SENTRY_SCOPES_CONTEXT_KEY } from '../constants';\nimport type { CurrentScopes } from '../types';\n\nconst SCOPE_CONTEXT_FIELD = '_scopeContext';\n\n/**\n * Try to get the current scopes from the given OTEL context.\n * This requires a Context Manager that was wrapped with getWrappedContextManager.\n */\nexport function getScopesFromContext(context: Context): CurrentScopes | undefined {\n  return context.getValue(SENTRY_SCOPES_CONTEXT_KEY) as CurrentScopes | undefined;\n}\n\n/**\n * Set the current scopes on an OTEL context.\n * This will return a forked context with the Propagation Context set.\n */\nexport function setScopesOnContext(context: Context, scopes: CurrentScopes): Context {\n  return context.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);\n}\n\n/**\n * Set the context on the scope so we can later look it up.\n * We need this to get the context from the scope in the `trace` functions.\n */\nexport function setContextOnScope(scope: Scope, context: Context): void {\n  addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context);\n}\n\n/**\n * Get the context related to a scope.\n */\nexport function getContextFromScope(scope: Scope): Context | undefined {\n  return (scope as { [SCOPE_CONTEXT_FIELD]?: Context })[SCOPE_CONTEXT_FIELD];\n}\n","import { ATTR_URL_FULL, SEMATTRS_HTTP_URL } from '@opentelemetry/semantic-conventions';\nimport { getClient, isSentryRequestUrl } from '@sentry/core';\nimport type { AbstractSpan } from '../types';\nimport { spanHasAttributes } from './spanTypes';\n\n/**\n *\n * @param otelSpan Checks whether a given OTEL Span is an http request to sentry.\n * @returns boolean\n */\nexport function isSentryRequestSpan(span: AbstractSpan): boolean {\n  if (!spanHasAttributes(span)) {\n    return false;\n  }\n\n  const { attributes } = span;\n\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[SEMATTRS_HTTP_URL] || attributes[ATTR_URL_FULL];\n\n  if (!httpUrl) {\n    return false;\n  }\n\n  return isSentryRequestUrl(httpUrl.toString(), getClient());\n}\n","import type { SpanContext } from '@opentelemetry/api';\nimport { TraceFlags } from '@opentelemetry/api';\nimport { baggageHeaderToDynamicSamplingContext } from '@sentry/core';\nimport { SENTRY_TRACE_STATE_DSC, SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING } from '../constants';\n\n/**\n * OpenTelemetry only knows about SAMPLED or NONE decision,\n * but for us it is important to differentiate between unset and unsampled.\n *\n * Both of these are identified as `traceFlags === TracegFlags.NONE`,\n * but we additionally look at a special trace state to differentiate between them.\n */\nexport function getSamplingDecision(spanContext: SpanContext): boolean | undefined {\n  const { traceFlags, traceState } = spanContext;\n\n  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === '1' : false;\n\n  // If trace flag is `SAMPLED`, we interpret this as sampled\n  // If it is `NONE`, it could mean either it was sampled to be not recorder, or that it was not sampled at all\n  // For us this is an important difference, sow e look at the SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING\n  // to identify which it is\n  if (traceFlags === TraceFlags.SAMPLED) {\n    return true;\n  }\n\n  if (sampledNotRecording) {\n    return false;\n  }\n\n  // Fall back to DSC as a last resort, that may also contain `sampled`...\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  if (dsc?.sampled === 'true') {\n    return true;\n  }\n  if (dsc?.sampled === 'false') {\n    return false;\n  }\n\n  return undefined;\n}\n","import type { Attributes, AttributeValue } from '@opentelemetry/api';\nimport { SpanKind } from '@opentelemetry/api';\nimport {\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_HTTP_ROUTE,\n  ATTR_URL_FULL,\n  SEMATTRS_DB_STATEMENT,\n  SEMATTRS_DB_SYSTEM,\n  SEMATTRS_FAAS_TRIGGER,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_TARGET,\n  SEMATTRS_HTTP_URL,\n  SEMATTRS_MESSAGING_SYSTEM,\n  SEMATTRS_RPC_SERVICE,\n} from '@opentelemetry/semantic-conventions';\nimport type { SpanAttributes, TransactionSource } from '@sentry/core';\nimport {\n  getSanitizedUrlString,\n  parseUrl,\n  SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  stripUrlQueryAndFragment,\n} from '@sentry/core';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION } from '../semanticAttributes';\nimport type { AbstractSpan } from '../types';\nimport { getSpanKind } from './getSpanKind';\nimport { spanHasAttributes, spanHasName } from './spanTypes';\n\ninterface SpanDescription {\n  op: string | undefined;\n  description: string;\n  source: TransactionSource;\n  data?: Record<string, string | undefined>;\n}\n\n/**\n * Infer the op & description for a set of name, attributes and kind of a span.\n */\nexport function inferSpanData(spanName: string, attributes: SpanAttributes, kind: SpanKind): SpanDescription {\n  // if http.method exists, this is an http request span\n  // eslint-disable-next-line deprecation/deprecation\n  const httpMethod = attributes[ATTR_HTTP_REQUEST_METHOD] || attributes[SEMATTRS_HTTP_METHOD];\n  if (httpMethod) {\n    return descriptionForHttpMethod({ attributes, name: spanName, kind }, httpMethod);\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const dbSystem = attributes[SEMATTRS_DB_SYSTEM];\n  const opIsCache =\n    typeof attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] === 'string' &&\n    attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith('cache.');\n\n  // If db.type exists then this is a database call span\n  // If the Redis DB is used as a cache, the span description should not be changed\n  if (dbSystem && !opIsCache) {\n    return descriptionForDbSystem({ attributes, name: spanName });\n  }\n\n  const customSourceOrRoute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom' ? 'custom' : 'route';\n\n  // If rpc.service exists then this is a rpc call span.\n  // eslint-disable-next-line deprecation/deprecation\n  const rpcService = attributes[SEMATTRS_RPC_SERVICE];\n  if (rpcService) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, 'route'),\n      op: 'rpc',\n    };\n  }\n\n  // If messaging.system exists then this is a messaging system span.\n  // eslint-disable-next-line deprecation/deprecation\n  const messagingSystem = attributes[SEMATTRS_MESSAGING_SYSTEM];\n  if (messagingSystem) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: 'message',\n    };\n  }\n\n  // If faas.trigger exists then this is a function as a service span.\n  // eslint-disable-next-line deprecation/deprecation\n  const faasTrigger = attributes[SEMATTRS_FAAS_TRIGGER];\n  if (faasTrigger) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: faasTrigger.toString(),\n    };\n  }\n\n  return { op: undefined, description: spanName, source: 'custom' };\n}\n\n/**\n * Extract better op/description from an otel span.\n *\n * Does not overwrite the span name if the source is already set to custom to ensure\n * that user-updated span names are preserved. In this case, we only adjust the op but\n * leave span description and source unchanged.\n *\n * Based on https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/7422ce2a06337f68a59b552b8c5a2ac125d6bae5/exporter/sentryexporter/sentry_exporter.go#L306\n */\nexport function parseSpanDescription(span: AbstractSpan): SpanDescription {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const name = spanHasName(span) ? span.name : '<unknown>';\n  const kind = getSpanKind(span);\n\n  return inferSpanData(name, attributes, kind);\n}\n\nfunction descriptionForDbSystem({ attributes, name }: { attributes: Attributes; name: string }): SpanDescription {\n  // if we already have a custom name, we don't overwrite it but only set the op\n  const userDefinedName = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  if (typeof userDefinedName === 'string') {\n    return {\n      op: 'db',\n      description: userDefinedName,\n      source: (attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] as TransactionSource) || 'custom',\n    };\n  }\n\n  // if we already have the source set to custom, we don't overwrite the span description but only set the op\n  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom') {\n    return { op: 'db', description: name, source: 'custom' };\n  }\n\n  // Use DB statement (Ex \"SELECT * FROM table\") if possible as description.\n  // eslint-disable-next-line deprecation/deprecation\n  const statement = attributes[SEMATTRS_DB_STATEMENT];\n\n  const description = statement ? statement.toString() : name;\n\n  return { op: 'db', description, source: 'task' };\n}\n\n/** Only exported for tests. */\nexport function descriptionForHttpMethod(\n  { name, kind, attributes }: { name: string; attributes: Attributes; kind: SpanKind },\n  httpMethod: AttributeValue,\n): SpanDescription {\n  const opParts = ['http'];\n\n  switch (kind) {\n    case SpanKind.CLIENT:\n      opParts.push('client');\n      break;\n    case SpanKind.SERVER:\n      opParts.push('server');\n      break;\n  }\n\n  // Spans for HTTP requests we have determined to be prefetch requests will have a `.prefetch` postfix in the op\n  if (attributes['sentry.http.prefetch']) {\n    opParts.push('prefetch');\n  }\n\n  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);\n\n  if (!urlPath) {\n    return { ...getUserUpdatedNameAndSource(name, attributes), op: opParts.join('.') };\n  }\n\n  const graphqlOperationsAttribute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION];\n\n  // Ex. GET /api/users\n  const baseDescription = `${httpMethod} ${urlPath}`;\n\n  // When the http span has a graphql operation, append it to the description\n  // We add these in the graphqlIntegration\n  const inferredDescription = graphqlOperationsAttribute\n    ? `${baseDescription} (${getGraphqlOperationNamesFromAttribute(graphqlOperationsAttribute)})`\n    : baseDescription;\n\n  // If `httpPath` is a root path, then we can categorize the transaction source as route.\n  const inferredSource: TransactionSource = hasRoute || urlPath === '/' ? 'route' : 'url';\n\n  const data: Record<string, string> = {};\n\n  if (url) {\n    data.url = url;\n  }\n  if (query) {\n    data['http.query'] = query;\n  }\n  if (fragment) {\n    data['http.fragment'] = fragment;\n  }\n\n  // If the span kind is neither client nor server, we use the original name\n  // this infers that somebody manually started this span, in which case we don't want to overwrite the name\n  const isClientOrServerKind = kind === SpanKind.CLIENT || kind === SpanKind.SERVER;\n\n  // If the span is an auto-span (=it comes from one of our instrumentations),\n  // we always want to infer the name\n  // this is necessary because some of the auto-instrumentation we use uses kind=INTERNAL\n  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] || 'manual';\n  const isManualSpan = !`${origin}`.startsWith('auto');\n\n  // If users (or in very rare occasions we) set the source to custom, we don't overwrite the name\n  const alreadyHasCustomSource = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom';\n  const customSpanName = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  const useInferredDescription =\n    !alreadyHasCustomSource && customSpanName == null && (isClientOrServerKind || !isManualSpan);\n\n  const { description, source } = useInferredDescription\n    ? { description: inferredDescription, source: inferredSource }\n    : getUserUpdatedNameAndSource(name, attributes);\n\n  return {\n    op: opParts.join('.'),\n    description,\n    source,\n    data,\n  };\n}\n\nfunction getGraphqlOperationNamesFromAttribute(attr: AttributeValue): string {\n  if (Array.isArray(attr)) {\n    const sorted = attr.slice().sort();\n\n    // Up to 5 items, we just add all of them\n    if (sorted.length <= 5) {\n      return sorted.join(', ');\n    } else {\n      // Else, we add the first 5 and the diff of other operations\n      return `${sorted.slice(0, 5).join(', ')}, +${sorted.length - 5}`;\n    }\n  }\n\n  return `${attr}`;\n}\n\n/** Exported for tests only */\nexport function getSanitizedUrl(\n  attributes: Attributes,\n  kind: SpanKind,\n): {\n  url: string | undefined;\n  urlPath: string | undefined;\n  query: string | undefined;\n  fragment: string | undefined;\n  hasRoute: boolean;\n} {\n  // This is the relative path of the URL, e.g. /sub\n  // eslint-disable-next-line deprecation/deprecation\n  const httpTarget = attributes[SEMATTRS_HTTP_TARGET];\n  // This is the full URL, including host & query params etc., e.g. https://example.com/sub?foo=bar\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[SEMATTRS_HTTP_URL] || attributes[ATTR_URL_FULL];\n  // This is the normalized route name - may not always be available!\n  const httpRoute = attributes[ATTR_HTTP_ROUTE];\n\n  const parsedUrl = typeof httpUrl === 'string' ? parseUrl(httpUrl) : undefined;\n  const url = parsedUrl ? getSanitizedUrlString(parsedUrl) : undefined;\n  const query = parsedUrl?.search || undefined;\n  const fragment = parsedUrl?.hash || undefined;\n\n  if (typeof httpRoute === 'string') {\n    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };\n  }\n\n  if (kind === SpanKind.SERVER && typeof httpTarget === 'string') {\n    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  if (parsedUrl) {\n    return { urlPath: url, url, query, fragment, hasRoute: false };\n  }\n\n  // fall back to target even for client spans, if no URL is present\n  if (typeof httpTarget === 'string') {\n    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  return { urlPath: undefined, url, query, fragment, hasRoute: false };\n}\n\n/**\n * Because Otel instrumentation sometimes mutates span names via `span.updateName`, the only way\n * to ensure that a user-set span name is preserved is to store it as a tmp attribute on the span.\n * We delete this attribute once we're done with it when preparing the event envelope.\n *\n * This temp attribute always takes precedence over the original name.\n *\n * We also need to take care of setting the correct source. Users can always update the source\n * after updating the name, so we need to respect that.\n *\n * @internal exported only for testing\n */\nexport function getUserUpdatedNameAndSource(\n  originalName: string,\n  attributes: Attributes,\n  fallbackSource: TransactionSource = 'custom',\n): {\n  description: string;\n  source: TransactionSource;\n} {\n  const source = (attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] as TransactionSource) || fallbackSource;\n  const description = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  if (description && typeof description === 'string') {\n    return {\n      description,\n      source,\n    };\n  }\n\n  return { description: originalName, source };\n}\n","import type { Client } from '@sentry/core';\nimport { hasSpansEnabled, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, spanToJSON } from '@sentry/core';\nimport { getSamplingDecision } from './getSamplingDecision';\nimport { parseSpanDescription } from './parseSpanDescription';\nimport { spanHasName } from './spanTypes';\n\n/**\n * Setup a DSC handler on the passed client,\n * ensuring that the transaction name is inferred from the span correctly.\n */\nexport function enhanceDscWithOpenTelemetryRootSpanName(client: Client): void {\n  client.on('createDsc', (dsc, rootSpan) => {\n    if (!rootSpan) {\n      return;\n    }\n\n    // We want to overwrite the transaction on the DSC that is created by default in core\n    // The reason for this is that we want to infer the span name, not use the initial one\n    // Otherwise, we'll get names like \"GET\" instead of e.g. \"GET /foo\"\n    // `parseSpanDescription` takes the attributes of the span into account for the name\n    // This mutates the passed-in DSC\n\n    const jsonSpan = spanToJSON(rootSpan);\n    const attributes = jsonSpan.data;\n    const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };\n    if (source !== 'url' && description) {\n      dsc.transaction = description;\n    }\n\n    // Also ensure sampling decision is correctly inferred\n    // In core, we use `spanIsSampled`, which just looks at the trace flags\n    // but in OTEL, we use a slightly more complex logic to be able to differntiate between unsampled and deferred sampling\n    if (hasSpansEnabled()) {\n      const sampled = getSamplingDecision(rootSpan.spanContext());\n      dsc.sampled = sampled == undefined ? undefined : String(sampled);\n    }\n  });\n}\n","import type { Span } from '@opentelemetry/api';\nimport { trace } from '@opentelemetry/api';\n\n/**\n * Returns the currently active span.\n */\nexport function getActiveSpan(): Span | undefined {\n  return trace.getActiveSpan();\n}\n","declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n","import { TraceState } from '@opentelemetry/core';\nimport type { DynamicSamplingContext } from '@sentry/core';\nimport { dynamicSamplingContextToSentryBaggageHeader } from '@sentry/core';\nimport { SENTRY_TRACE_STATE_DSC, SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING } from '../constants';\n\n/**\n * Generate a TraceState for the given data.\n */\nexport function makeTraceState({\n  dsc,\n  sampled,\n}: {\n  dsc?: Partial<DynamicSamplingContext>;\n  sampled?: boolean;\n}): TraceState {\n  // We store the DSC as OTEL trace state on the span context\n  const dscString = dsc ? dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;\n\n  const traceStateBase = new TraceState();\n\n  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;\n\n  // We also specifically want to store if this is sampled to be not recording,\n  // or unsampled (=could be either sampled or not)\n  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') : traceStateWithDsc;\n}\n","type OpenTelemetryElement = 'SentrySpanProcessor' | 'SentryContextManager' | 'SentryPropagator' | 'SentrySampler';\n\nconst setupElements = new Set<OpenTelemetryElement>();\n\n/** Get all the OpenTelemetry elements that have been set up. */\nexport function openTelemetrySetupCheck(): OpenTelemetryElement[] {\n  return Array.from(setupElements);\n}\n\n/** Mark an OpenTelemetry element as setup. */\nexport function setIsSetup(element: OpenTelemetryElement): void {\n  setupElements.add(element);\n}\n\n/** Only exported for tests. */\nexport function clearOpenTelemetrySetupCheck(): void {\n  setupElements.clear();\n}\n","import type { Baggage, Context, Span, SpanContext, TextMapGetter, TextMapSetter } from '@opentelemetry/api';\nimport { context, INVALID_TRACEID, propagation, trace, TraceFlags } from '@opentelemetry/api';\nimport { isTracingSuppressed, W3CBaggagePropagator } from '@opentelemetry/core';\nimport { ATTR_URL_FULL, SEMATTRS_HTTP_URL } from '@opentelemetry/semantic-conventions';\nimport type { Client, continueTrace, DynamicSamplingContext, Options, Scope } from '@sentry/core';\nimport {\n  generateSentryTraceHeader,\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromScope,\n  getDynamicSamplingContextFromSpan,\n  getIsolationScope,\n  logger,\n  LRUMap,\n  parseBaggageHeader,\n  propagationContextFromHeaders,\n  SENTRY_BAGGAGE_KEY_PREFIX,\n  spanToJSON,\n  stringMatchesSomePattern,\n} from '@sentry/core';\nimport { SENTRY_BAGGAGE_HEADER, SENTRY_TRACE_HEADER, SENTRY_TRACE_STATE_URL } from './constants';\nimport { DEBUG_BUILD } from './debug-build';\nimport { getScopesFromContext, setScopesOnContext } from './utils/contextData';\nimport { getSamplingDecision } from './utils/getSamplingDecision';\nimport { makeTraceState } from './utils/makeTraceState';\nimport { setIsSetup } from './utils/setupCheck';\n\n/**\n * Injects and extracts `sentry-trace` and `baggage` headers from carriers.\n */\nexport class SentryPropagator extends W3CBaggagePropagator {\n  /** A map of URLs that have already been checked for if they match tracePropagationTargets. */\n  private _urlMatchesTargetsMap: LRUMap<string, boolean>;\n\n  public constructor() {\n    super();\n    setIsSetup('SentryPropagator');\n\n    // We're caching results so we don't have to recompute regexp every time we create a request.\n    this._urlMatchesTargetsMap = new LRUMap<string, boolean>(100);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    if (isTracingSuppressed(context)) {\n      DEBUG_BUILD && logger.log('[Tracing] Not injecting trace data for url because tracing is suppressed.');\n      return;\n    }\n\n    const activeSpan = trace.getSpan(context);\n    const url = activeSpan && getCurrentURL(activeSpan);\n\n    const tracePropagationTargets = getClient()?.getOptions()?.tracePropagationTargets;\n    if (!shouldPropagateTraceForUrl(url, tracePropagationTargets, this._urlMatchesTargetsMap)) {\n      DEBUG_BUILD &&\n        logger.log(\n          '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:',\n          url,\n        );\n      return;\n    }\n\n    const existingBaggageHeader = getExistingBaggage(carrier);\n    let baggage = propagation.getBaggage(context) || propagation.createBaggage({});\n\n    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context);\n\n    if (existingBaggageHeader) {\n      const baggageEntries = parseBaggageHeader(existingBaggageHeader);\n\n      if (baggageEntries) {\n        Object.entries(baggageEntries).forEach(([key, value]) => {\n          baggage = baggage.setEntry(key, { value });\n        });\n      }\n    }\n\n    if (dynamicSamplingContext) {\n      baggage = Object.entries(dynamicSamplingContext).reduce<Baggage>((b, [dscKey, dscValue]) => {\n        if (dscValue) {\n          return b.setEntry(`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });\n        }\n        return b;\n      }, baggage);\n    }\n\n    // We also want to avoid setting the default OTEL trace ID, if we get that for whatever reason\n    if (traceId && traceId !== INVALID_TRACEID) {\n      setter.set(carrier, SENTRY_TRACE_HEADER, generateSentryTraceHeader(traceId, spanId, sampled));\n    }\n\n    super.inject(propagation.setBaggage(context, baggage), carrier, setter);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    const maybeSentryTraceHeader: string | string[] | undefined = getter.get(carrier, SENTRY_TRACE_HEADER);\n    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);\n\n    const sentryTrace = maybeSentryTraceHeader\n      ? Array.isArray(maybeSentryTraceHeader)\n        ? maybeSentryTraceHeader[0]\n        : maybeSentryTraceHeader\n      : undefined;\n\n    // Add remote parent span context\n    // If there is no incoming trace, this will return the context as-is\n    return ensureScopesOnContext(getContextWithRemoteActiveSpan(context, { sentryTrace, baggage }));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public fields(): string[] {\n    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];\n  }\n}\n\nconst NOT_PROPAGATED_MESSAGE =\n  '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:';\n\n/**\n * Check if a given URL should be propagated to or not.\n * If no url is defined, or no trace propagation targets are defined, this will always return `true`.\n * You can also optionally provide a decision map, to cache decisions and avoid repeated regex lookups.\n */\nexport function shouldPropagateTraceForUrl(\n  url: string | undefined,\n  tracePropagationTargets: Options['tracePropagationTargets'],\n  decisionMap?: LRUMap<string, boolean>,\n): boolean {\n  if (typeof url !== 'string' || !tracePropagationTargets) {\n    return true;\n  }\n\n  const cachedDecision = decisionMap?.get(url);\n  if (cachedDecision !== undefined) {\n    DEBUG_BUILD && !cachedDecision && logger.log(NOT_PROPAGATED_MESSAGE, url);\n    return cachedDecision;\n  }\n\n  const decision = stringMatchesSomePattern(url, tracePropagationTargets);\n  decisionMap?.set(url, decision);\n\n  DEBUG_BUILD && !decision && logger.log(NOT_PROPAGATED_MESSAGE, url);\n  return decision;\n}\n\n/**\n * Get propagation injection data for the given context.\n * The additional options can be passed to override the scope and client that is otherwise derived from the context.\n */\nexport function getInjectionData(\n  context: Context,\n  options: { scope?: Scope; client?: Client } = {},\n): {\n  dynamicSamplingContext: Partial<DynamicSamplingContext> | undefined;\n  traceId: string | undefined;\n  spanId: string | undefined;\n  sampled: boolean | undefined;\n} {\n  const span = trace.getSpan(context);\n\n  // If we have a remote span, the spanId should be considered as the parentSpanId, not spanId itself\n  // Instead, we use a virtual (generated) spanId for propagation\n  if (span?.spanContext().isRemote) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: undefined,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // If we have a local span, we just use this\n  if (span) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: spanContext.spanId,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // Else we try to use the propagation context from the scope\n  // The only scenario where this should happen is when we neither have a span, nor an incoming trace\n  const scope = options.scope || getScopesFromContext(context)?.scope || getCurrentScope();\n  const client = options.client || getClient();\n\n  const propagationContext = scope.getPropagationContext();\n  const dynamicSamplingContext = client ? getDynamicSamplingContextFromScope(client, scope) : undefined;\n  return {\n    dynamicSamplingContext,\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.propagationSpanId,\n    sampled: propagationContext.sampled,\n  };\n}\n\nfunction getContextWithRemoteActiveSpan(\n  ctx: Context,\n  { sentryTrace, baggage }: Parameters<typeof continueTrace>[0],\n): Context {\n  const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n\n  const { traceId, parentSpanId, sampled, dsc } = propagationContext;\n\n  // We only want to set the virtual span if we are continuing a concrete trace\n  // Otherwise, we ignore the incoming trace here, e.g. if we have no trace headers\n  if (!parentSpanId) {\n    return ctx;\n  }\n\n  const spanContext = generateRemoteSpanContext({\n    traceId,\n    spanId: parentSpanId,\n    sampled,\n    dsc,\n  });\n\n  return trace.setSpanContext(ctx, spanContext);\n}\n\n/**\n * Takes trace strings and propagates them as a remote active span.\n * This should be used in addition to `continueTrace` in OTEL-powered environments.\n */\nexport function continueTraceAsRemoteSpan<T>(\n  ctx: Context,\n  options: Parameters<typeof continueTrace>[0],\n  callback: () => T,\n): T {\n  const ctxWithSpanContext = ensureScopesOnContext(getContextWithRemoteActiveSpan(ctx, options));\n\n  return context.with(ctxWithSpanContext, callback);\n}\n\nfunction ensureScopesOnContext(ctx: Context): Context {\n  // If there are no scopes yet on the context, ensure we have them\n  const scopes = getScopesFromContext(ctx);\n  const newScopes = {\n    // If we have no scope here, this is most likely either the root context or a context manually derived from it\n    // In this case, we want to fork the current scope, to ensure we do not pollute the root scope\n    scope: scopes ? scopes.scope : getCurrentScope().clone(),\n    isolationScope: scopes ? scopes.isolationScope : getIsolationScope(),\n  };\n\n  return setScopesOnContext(ctx, newScopes);\n}\n\n/** Try to get the existing baggage header so we can merge this in. */\nfunction getExistingBaggage(carrier: unknown): string | undefined {\n  try {\n    const baggage = (carrier as Record<string, string | string[]>)[SENTRY_BAGGAGE_HEADER];\n    return Array.isArray(baggage) ? baggage.join(',') : baggage;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * It is pretty tricky to get access to the outgoing request URL of a request in the propagator.\n * As we only have access to the context of the span to be sent and the carrier (=headers),\n * but the span may be unsampled and thus have no attributes.\n *\n * So we use the following logic:\n * 1. If we have an active span, we check if it has a URL attribute.\n * 2. Else, if the active span has no URL attribute (e.g. it is unsampled), we check a special trace state (which we set in our sampler).\n */\nfunction getCurrentURL(span: Span): string | undefined {\n  const spanData = spanToJSON(span).data;\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const urlAttribute = spanData[SEMATTRS_HTTP_URL] || spanData[ATTR_URL_FULL];\n  if (typeof urlAttribute === 'string') {\n    return urlAttribute;\n  }\n\n  // Also look at the traceState, which we may set in the sampler even for unsampled spans\n  const urlTraceState = span.spanContext().traceState?.get(SENTRY_TRACE_STATE_URL);\n  if (urlTraceState) {\n    return urlTraceState;\n  }\n\n  return undefined;\n}\n\nfunction generateRemoteSpanContext({\n  spanId,\n  traceId,\n  sampled,\n  dsc,\n}: {\n  spanId: string;\n  traceId: string;\n  sampled: boolean | undefined;\n  dsc?: Partial<DynamicSamplingContext>;\n}): SpanContext {\n  // We store the DSC as OTEL trace state on the span context\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanContext: SpanContext = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? TraceFlags.SAMPLED : TraceFlags.NONE,\n    traceState,\n  };\n\n  return spanContext;\n}\n","import type { Context, Span, SpanContext, SpanOptions, Tracer } from '@opentelemetry/api';\nimport { context, SpanStatusCode, trace, TraceFlags } from '@opentelemetry/api';\nimport { suppressTracing } from '@opentelemetry/core';\nimport type {\n  Client,\n  continueTrace as baseContinueTrace,\n  DynamicSamplingContext,\n  Scope,\n  Span as SentrySpan,\n  TraceContext,\n} from '@sentry/core';\nimport {\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromScope,\n  getDynamicSamplingContextFromSpan,\n  getRootSpan,\n  getTraceContextFromScope,\n  handleCallbackErrors,\n  SDK_VERSION,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  spanToJSON,\n  spanToTraceContext,\n} from '@sentry/core';\nimport { continueTraceAsRemoteSpan } from './propagator';\nimport type { OpenTelemetryClient, OpenTelemetrySpanContext } from './types';\nimport { getContextFromScope } from './utils/contextData';\nimport { getSamplingDecision } from './utils/getSamplingDecision';\nimport { makeTraceState } from './utils/makeTraceState';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startSpan<T>(options: OpenTelemetrySpanContext, callback: (span: Span) => T): T {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper<T>(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return handleCallbackErrors(\n        () => callback(span),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (spanToJSON(span).status === undefined) {\n            span.setStatus({ code: SpanStatusCode.ERROR });\n          }\n        },\n        () => span.end(),\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startSpanManual<T>(\n  options: OpenTelemetrySpanContext,\n  callback: (span: Span, finish: () => void) => T,\n): T {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper<T>(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return handleCallbackErrors(\n        () => callback(span, () => span.end()),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (spanToJSON(span).status === undefined) {\n            span.setStatus({ code: SpanStatusCode.ERROR });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startInactiveSpan(options: OpenTelemetrySpanContext): Span {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper<Span>(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    const span = tracer.startSpan(name, spanOptions, ctx);\n\n    return span;\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will be root spans.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nexport function withActiveSpan<T>(span: Span | null, callback: (scope: Scope) => T): T {\n  const newContextWithActiveSpan = span ? trace.setSpan(context.active(), span) : trace.deleteSpan(context.active());\n  return context.with(newContextWithActiveSpan, () => callback(getCurrentScope()));\n}\n\nfunction getTracer(): Tracer {\n  const client = getClient<Client & OpenTelemetryClient>();\n  return client?.tracer || trace.getTracer('@sentry/opentelemetry', SDK_VERSION);\n}\n\nfunction getSpanOptions(options: OpenTelemetrySpanContext): SpanOptions {\n  const { startTime, attributes, kind, op, links } = options;\n\n  // OTEL expects timestamps in ms, not seconds\n  const fixedStartTime = typeof startTime === 'number' ? ensureTimestampInMilliseconds(startTime) : startTime;\n\n  return {\n    attributes: op\n      ? {\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n          ...attributes,\n        }\n      : attributes,\n    kind,\n    links,\n    startTime: fixedStartTime,\n  };\n}\n\nfunction ensureTimestampInMilliseconds(timestamp: number): number {\n  const isMs = timestamp < 9999999999;\n  return isMs ? timestamp * 1000 : timestamp;\n}\n\nfunction getContext(scope: Scope | undefined, forceTransaction: boolean | undefined): Context {\n  const ctx = getContextForScope(scope);\n  const parentSpan = trace.getSpan(ctx);\n\n  // In the case that we have no parent span, we start a new trace\n  // Note that if we continue a trace, we'll always have a remote parent span here anyhow\n  if (!parentSpan) {\n    return ctx;\n  }\n\n  // If we don't want to force a transaction, and we have a parent span, all good, we just return as-is!\n  if (!forceTransaction) {\n    return ctx;\n  }\n\n  // Else, if we do have a parent span but want to force a transaction, we have to simulate a \"root\" context\n\n  // Else, we need to do two things:\n  // 1. Unset the parent span from the context, so we'll create a new root span\n  // 2. Ensure the propagation context is correct, so we'll continue from the parent span\n  const ctxWithoutSpan = trace.deleteSpan(ctx);\n\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = getSamplingDecision(parentSpan.spanContext());\n\n  // In this case, when we are forcing a transaction, we want to treat this like continuing an incoming trace\n  // so we set the traceState according to the root span\n  const rootSpan = getRootSpan(parentSpan);\n  const dsc = getDynamicSamplingContextFromSpan(rootSpan);\n\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanOptions: SpanContext = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? TraceFlags.SAMPLED : TraceFlags.NONE,\n    traceState,\n  };\n\n  const ctxWithSpanContext = trace.setSpanContext(ctxWithoutSpan, spanOptions);\n\n  return ctxWithSpanContext;\n}\n\nfunction getContextForScope(scope?: Scope): Context {\n  if (scope) {\n    const ctx = getContextFromScope(scope);\n    if (ctx) {\n      return ctx;\n    }\n  }\n\n  return context.active();\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n *\n * This is a custom version of `continueTrace` that is used in OTEL-powered environments.\n * It propagates the trace as a remote span, in addition to setting it on the propagation context.\n */\nexport function continueTrace<T>(options: Parameters<typeof baseContinueTrace>[0], callback: () => T): T {\n  return continueTraceAsRemoteSpan(context.active(), options, callback);\n}\n\n/**\n * Get the trace context for a given scope.\n * We have a custom implemention here because we need an OTEL-specific way to get the span from a scope.\n */\nexport function getTraceContextForScope(\n  client: Client,\n  scope: Scope,\n): [dynamicSamplingContext: Partial<DynamicSamplingContext>, traceContext: TraceContext] {\n  const ctx = getContextFromScope(scope);\n  const span = ctx && trace.getSpan(ctx);\n\n  const traceContext = span ? spanToTraceContext(span) : getTraceContextFromScope(scope);\n\n  const dynamicSamplingContext = span\n    ? getDynamicSamplingContextFromSpan(span)\n    : getDynamicSamplingContextFromScope(client, scope);\n  return [dynamicSamplingContext, traceContext];\n}\n\nfunction getActiveSpanWrapper<T>(parentSpan: Span | SentrySpan | undefined | null): (callback: () => T) => T {\n  return parentSpan !== undefined\n    ? (callback: () => T) => {\n        return withActiveSpan(parentSpan, callback);\n      }\n    : (callback: () => T) => callback();\n}\n","import { context } from '@opentelemetry/api';\nimport { suppressTracing as suppressTracingImpl } from '@opentelemetry/core';\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nexport function suppressTracing<T>(callback: () => T): T {\n  const ctx = suppressTracingImpl(context.active());\n  return context.with(ctx, callback);\n}\n","import type { Client } from '@sentry/core';\nimport { getDynamicSamplingContextFromSpan, getRootSpan, spanToTraceContext } from '@sentry/core';\nimport { getActiveSpan } from './utils/getActiveSpan';\n\n/** Ensure the `trace` context is set on all events. */\nexport function setupEventContextTrace(client: Client): void {\n  client.on('preprocessEvent', event => {\n    const span = getActiveSpan();\n    // For transaction events, this is handled separately\n    // Because the active span may not be the span that is actually the transaction event\n    if (!span || event.type === 'transaction') {\n      return;\n    }\n\n    // If event has already set `trace` context, use that one.\n    event.contexts = {\n      trace: spanToTraceContext(span),\n      ...event.contexts,\n    };\n\n    const rootSpan = getRootSpan(span);\n\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: getDynamicSamplingContextFromSpan(rootSpan),\n      ...event.sdkProcessingMetadata,\n    };\n\n    return event;\n  });\n}\n","import * as api from '@opentelemetry/api';\nimport type { Client, Scope, SerializedTraceData, Span } from '@sentry/core';\nimport {\n  dynamicSamplingContextToSentryBaggageHeader,\n  generateSentryTraceHeader,\n  getCapturedScopesOnSpan,\n} from '@sentry/core';\nimport { getInjectionData } from '../propagator';\nimport { getContextFromScope } from './contextData';\n\n/**\n * Otel-specific implementation of `getTraceData`.\n * @see `@sentry/core` version of `getTraceData` for more information\n */\nexport function getTraceData({\n  span,\n  scope,\n  client,\n}: { span?: Span; scope?: Scope; client?: Client } = {}): SerializedTraceData {\n  let ctx = (scope && getContextFromScope(scope)) ?? api.context.active();\n\n  if (span) {\n    const { scope } = getCapturedScopesOnSpan(span);\n    // fall back to current context if for whatever reason we can't find the one of the span\n    ctx = (scope && getContextFromScope(scope)) || api.trace.setSpan(api.context.active(), span);\n  }\n\n  const { traceId, spanId, sampled, dynamicSamplingContext } = getInjectionData(ctx, { scope, client });\n\n  return {\n    'sentry-trace': generateSentryTraceHeader(traceId, spanId, sampled),\n    baggage: dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext),\n  };\n}\n","import * as api from '@opentelemetry/api';\nimport type { Scope, withActiveSpan as defaultWithActiveSpan } from '@sentry/core';\nimport { getDefaultCurrentScope, getDefaultIsolationScope, setAsyncContextStrategy } from '@sentry/core';\nimport {\n  SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_SCOPE_CONTEXT_KEY,\n} from './constants';\nimport { continueTrace, startInactiveSpan, startSpan, startSpanManual, withActiveSpan } from './trace';\nimport type { CurrentScopes } from './types';\nimport { getContextFromScope, getScopesFromContext } from './utils/contextData';\nimport { getActiveSpan } from './utils/getActiveSpan';\nimport { getTraceData } from './utils/getTraceData';\nimport { suppressTracing } from './utils/suppressTracing';\n\n/**\n * Sets the async context strategy to use follow the OTEL context under the hood.\n * We handle forking a hub inside of our custom OTEL Context Manager (./otelContextManager.ts)\n */\nexport function setOpenTelemetryContextAsyncContextStrategy(): void {\n  function getScopes(): CurrentScopes {\n    const ctx = api.context.active();\n    const scopes = getScopesFromContext(ctx);\n\n    if (scopes) {\n      return scopes;\n    }\n\n    // fallback behavior:\n    // if, for whatever reason, we can't find scopes on the context here, we have to fix this somehow\n    return {\n      scope: getDefaultCurrentScope(),\n      isolationScope: getDefaultIsolationScope(),\n    };\n  }\n\n  function withScope<T>(callback: (scope: Scope) => T): T {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    // as by default, we don't want to fork this, unless triggered explicitly by `withScope`\n    return api.context.with(ctx, () => {\n      return callback(getCurrentScope());\n    });\n  }\n\n  function withSetScope<T>(scope: Scope, callback: (scope: Scope) => T): T {\n    const ctx = getContextFromScope(scope) || api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_SET_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which picks up this scope as the current scope\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {\n      return callback(scope);\n    });\n  }\n\n  function withIsolationScope<T>(callback: (isolationScope: Scope) => T): T {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function withSetIsolationScope<T>(isolationScope: Scope, callback: (isolationScope: Scope) => T): T {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function getCurrentScope(): Scope {\n    return getScopes().scope;\n  }\n\n  function getIsolationScope(): Scope {\n    return getScopes().isolationScope;\n  }\n\n  setAsyncContextStrategy({\n    withScope,\n    withSetScope,\n    withSetIsolationScope,\n    withIsolationScope,\n    getCurrentScope,\n    getIsolationScope,\n    startSpan,\n    startSpanManual,\n    startInactiveSpan,\n    getActiveSpan,\n    suppressTracing,\n    getTraceData,\n    continueTrace,\n    // The types here don't fully align, because our own `Span` type is narrower\n    // than the OTEL one - but this is OK for here, as we now we'll only have OTEL spans passed around\n    withActiveSpan: withActiveSpan as typeof defaultWithActiveSpan,\n  });\n}\n","import type { Context, ContextManager } from '@opentelemetry/api';\nimport type { Scope } from '@sentry/core';\nimport { getCurrentScope, getIsolationScope } from '@sentry/core';\nimport {\n  SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_SCOPE_CONTEXT_KEY,\n} from './constants';\nimport { getScopesFromContext, setContextOnScope, setScopesOnContext } from './utils/contextData';\nimport { setIsSetup } from './utils/setupCheck';\n\n/**\n * Wrap an OpenTelemetry ContextManager in a way that ensures the context is kept in sync with the Sentry Scope.\n *\n * Usage:\n * import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';\n * const SentryContextManager = wrapContextManagerClass(AsyncLocalStorageContextManager);\n * const contextManager = new SentryContextManager();\n */\nexport function wrapContextManagerClass<ContextManagerInstance extends ContextManager>(\n  ContextManagerClass: new (...args: unknown[]) => ContextManagerInstance,\n): typeof ContextManagerClass {\n  /**\n   * This is a custom ContextManager for OpenTelemetry, which extends the default AsyncLocalStorageContextManager.\n   * It ensures that we create new scopes per context, so that the OTEL Context & the Sentry Scope are always in sync.\n   *\n   * Note that we currently only support AsyncHooks with this,\n   * but since this should work for Node 14+ anyhow that should be good enough.\n   */\n\n  // @ts-expect-error TS does not like this, but we know this is fine\n  class SentryContextManager extends ContextManagerClass {\n    public constructor(...args: unknown[]) {\n      super(...args);\n      setIsSetup('SentryContextManager');\n    }\n    /**\n     * Overwrite with() of the original AsyncLocalStorageContextManager\n     * to ensure we also create new scopes per context.\n     */\n    public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n      context: Context,\n      fn: F,\n      thisArg?: ThisParameterType<F>,\n      ...args: A\n    ): ReturnType<F> {\n      const currentScopes = getScopesFromContext(context);\n      const currentScope = currentScopes?.scope || getCurrentScope();\n      const currentIsolationScope = currentScopes?.isolationScope || getIsolationScope();\n\n      const shouldForkIsolationScope = context.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;\n      const scope = context.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY) as Scope | undefined;\n      const isolationScope = context.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY) as Scope | undefined;\n\n      const newCurrentScope = scope || currentScope.clone();\n      const newIsolationScope =\n        isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);\n      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };\n\n      const ctx1 = setScopesOnContext(context, scopes);\n\n      // Remove the unneeded values again\n      const ctx2 = ctx1\n        .deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);\n\n      setContextOnScope(newCurrentScope, ctx2);\n\n      return super.with(ctx2, fn, thisArg, ...args);\n    }\n  }\n\n  return SentryContextManager as unknown as typeof ContextManagerClass;\n}\n","import type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE } from '../semanticAttributes';\nimport { getParentSpanId } from './getParentSpanId';\n\nexport interface SpanNode {\n  id: string;\n  span?: ReadableSpan;\n  parentNode?: SpanNode | undefined;\n  children: SpanNode[];\n}\n\ntype SpanMap = Map<string, SpanNode>;\n\n/**\n * This function runs through a list of OTEL Spans, and wraps them in an `SpanNode`\n * where each node holds a reference to their parent node.\n */\nexport function groupSpansWithParents(spans: ReadableSpan[]): SpanNode[] {\n  const nodeMap: SpanMap = new Map<string, SpanNode>();\n\n  for (const span of spans) {\n    createOrUpdateSpanNodeAndRefs(nodeMap, span);\n  }\n\n  return Array.from(nodeMap, function ([_id, spanNode]) {\n    return spanNode;\n  });\n}\n\n/**\n * This returns the _local_ parent ID - `parentId` on the span may point to a remote span.\n */\nexport function getLocalParentId(span: ReadableSpan): string | undefined {\n  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;\n  // If the parentId is the trace parent ID, we pretend it's undefined\n  // As this means the parent exists somewhere else\n  return !parentIsRemote ? getParentSpanId(span) : undefined;\n}\n\nfunction createOrUpdateSpanNodeAndRefs(nodeMap: SpanMap, span: ReadableSpan): void {\n  const id = span.spanContext().spanId;\n  const parentId = getLocalParentId(span);\n\n  if (!parentId) {\n    createOrUpdateNode(nodeMap, { id, span, children: [] });\n    return;\n  }\n\n  // Else make sure to create parent node as well\n  // Note that the parent may not know it's parent _yet_, this may be updated in a later pass\n  const parentNode = createOrGetParentNode(nodeMap, parentId);\n  const node = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });\n  parentNode.children.push(node);\n}\n\nfunction createOrGetParentNode(nodeMap: SpanMap, id: string): SpanNode {\n  const existing = nodeMap.get(id);\n\n  if (existing) {\n    return existing;\n  }\n\n  return createOrUpdateNode(nodeMap, { id, children: [] });\n}\n\nfunction createOrUpdateNode(nodeMap: SpanMap, spanNode: SpanNode): SpanNode {\n  const existing = nodeMap.get(spanNode.id);\n\n  // If span is already set, nothing to do here\n  if (existing?.span) {\n    return existing;\n  }\n\n  // If it exists but span is not set yet, we update it\n  if (existing && !existing.span) {\n    existing.span = spanNode.span;\n    existing.parentNode = spanNode.parentNode;\n    return existing;\n  }\n\n  // Else, we create a new one...\n  nodeMap.set(spanNode.id, spanNode);\n  return spanNode;\n}\n","import { SpanStatusCode } from '@opentelemetry/api';\nimport {\n  ATTR_HTTP_RESPONSE_STATUS_CODE,\n  SEMATTRS_HTTP_STATUS_CODE,\n  SEMATTRS_RPC_GRPC_STATUS_CODE,\n} from '@opentelemetry/semantic-conventions';\nimport type { SpanAttributes, SpanStatus } from '@sentry/core';\nimport { getSpanStatusFromHttpCode, SPAN_STATUS_ERROR, SPAN_STATUS_OK } from '@sentry/core';\nimport type { AbstractSpan } from '../types';\nimport { spanHasAttributes, spanHasStatus } from './spanTypes';\n\n// canonicalCodesGrpcMap maps some GRPC codes to Sentry's span statuses. See description in grpc documentation.\nconst canonicalGrpcErrorCodesMap: Record<string, SpanStatus['message']> = {\n  '1': 'cancelled',\n  '2': 'unknown_error',\n  '3': 'invalid_argument',\n  '4': 'deadline_exceeded',\n  '5': 'not_found',\n  '6': 'already_exists',\n  '7': 'permission_denied',\n  '8': 'resource_exhausted',\n  '9': 'failed_precondition',\n  '10': 'aborted',\n  '11': 'out_of_range',\n  '12': 'unimplemented',\n  '13': 'internal_error',\n  '14': 'unavailable',\n  '15': 'data_loss',\n  '16': 'unauthenticated',\n} as const;\n\nconst isStatusErrorMessageValid = (message: string): boolean => {\n  return Object.values(canonicalGrpcErrorCodesMap).includes(message as SpanStatus['message']);\n};\n\n/**\n * Get a Sentry span status from an otel span.\n */\nexport function mapStatus(span: AbstractSpan): SpanStatus {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const status = spanHasStatus(span) ? span.status : undefined;\n\n  if (status) {\n    // Since span status OK is not set by default, we give it priority: https://opentelemetry.io/docs/concepts/signals/traces/#span-status\n    if (status.code === SpanStatusCode.OK) {\n      return { code: SPAN_STATUS_OK };\n      // If the span is already marked as erroneous we return that exact status\n    } else if (status.code === SpanStatusCode.ERROR) {\n      if (typeof status.message === 'undefined') {\n        const inferredStatus = inferStatusFromAttributes(attributes);\n        if (inferredStatus) {\n          return inferredStatus;\n        }\n      }\n\n      if (status.message && isStatusErrorMessageValid(status.message)) {\n        return { code: SPAN_STATUS_ERROR, message: status.message };\n      } else {\n        return { code: SPAN_STATUS_ERROR, message: 'unknown_error' };\n      }\n    }\n  }\n\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n  const inferredStatus = inferStatusFromAttributes(attributes);\n\n  if (inferredStatus) {\n    return inferredStatus;\n  }\n\n  // We default to setting the spans status to ok.\n  if (status?.code === SpanStatusCode.UNSET) {\n    return { code: SPAN_STATUS_OK };\n  } else {\n    return { code: SPAN_STATUS_ERROR, message: 'unknown_error' };\n  }\n}\n\nfunction inferStatusFromAttributes(attributes: SpanAttributes): SpanStatus | undefined {\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n\n  // eslint-disable-next-line deprecation/deprecation\n  const httpCodeAttribute = attributes[ATTR_HTTP_RESPONSE_STATUS_CODE] || attributes[SEMATTRS_HTTP_STATUS_CODE];\n  // eslint-disable-next-line deprecation/deprecation\n  const grpcCodeAttribute = attributes[SEMATTRS_RPC_GRPC_STATUS_CODE];\n\n  const numberHttpCode =\n    typeof httpCodeAttribute === 'number'\n      ? httpCodeAttribute\n      : typeof httpCodeAttribute === 'string'\n        ? parseInt(httpCodeAttribute)\n        : undefined;\n\n  if (typeof numberHttpCode === 'number') {\n    return getSpanStatusFromHttpCode(numberHttpCode);\n  }\n\n  if (typeof grpcCodeAttribute === 'string') {\n    return { code: SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || 'unknown_error' };\n  }\n\n  return undefined;\n}\n","/* eslint-disable max-lines */\nimport type { Span } from '@opentelemetry/api';\nimport { SpanKind } from '@opentelemetry/api';\nimport type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport { ATTR_HTTP_RESPONSE_STATUS_CODE, SEMATTRS_HTTP_STATUS_CODE } from '@opentelemetry/semantic-conventions';\nimport type {\n  SpanAttributes,\n  SpanJSON,\n  SpanOrigin,\n  TraceContext,\n  TransactionEvent,\n  TransactionSource,\n} from '@sentry/core';\nimport {\n  captureEvent,\n  convertSpanLinksForEnvelope,\n  debounce,\n  getCapturedScopesOnSpan,\n  getDynamicSamplingContextFromSpan,\n  getStatusMessage,\n  logger,\n  SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  spanTimeInputToSeconds,\n  timedEventsToMeasurements,\n} from '@sentry/core';\nimport { DEBUG_BUILD } from './debug-build';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE } from './semanticAttributes';\nimport { getParentSpanId } from './utils/getParentSpanId';\nimport { getRequestSpanData } from './utils/getRequestSpanData';\nimport type { SpanNode } from './utils/groupSpansWithParents';\nimport { getLocalParentId, groupSpansWithParents } from './utils/groupSpansWithParents';\nimport { mapStatus } from './utils/mapStatus';\nimport { parseSpanDescription } from './utils/parseSpanDescription';\n\ntype SpanNodeCompleted = SpanNode & { span: ReadableSpan };\n\nconst MAX_SPAN_COUNT = 1000;\nconst DEFAULT_TIMEOUT = 300; // 5 min\n\ninterface FinishedSpanBucket {\n  timestampInS: number;\n  spans: Set<ReadableSpan>;\n}\n\n/**\n * A Sentry-specific exporter that converts OpenTelemetry Spans to Sentry Spans & Transactions.\n */\nexport class SentrySpanExporter {\n  /*\n   * A quick explanation on the buckets: We do bucketing of finished spans for efficiency. This span exporter is\n   * accumulating spans until a root span is encountered and then it flushes all the spans that are descendants of that\n   * root span. Because it is totally in the realm of possibilities that root spans are never finished, and we don't\n   * want to accumulate spans indefinitely in memory, we need to periodically evacuate spans. Naively we could simply\n   * store the spans in an array and each time a new span comes in we could iterate through the entire array and\n   * evacuate all spans that have an end-timestamp that is older than our limit. This could get quite expensive because\n   * we would have to iterate a potentially large number of spans every time we evacuate. We want to avoid these large\n   * bursts of computation.\n   *\n   * Instead we go for a bucketing approach and put spans into buckets, based on what second\n   * (modulo the time limit) the span was put into the exporter. With buckets, when we decide to evacuate, we can\n   * iterate through the bucket entries instead, which have an upper bound of items, making the evacuation much more\n   * efficient. Cleaning up also becomes much more efficient since it simply involves de-referencing a bucket within the\n   * bucket array, and letting garbage collection take care of the rest.\n   */\n  private _finishedSpanBuckets: (FinishedSpanBucket | undefined)[];\n  private _finishedSpanBucketSize: number;\n  private _spansToBucketEntry: WeakMap<ReadableSpan, FinishedSpanBucket>;\n  private _lastCleanupTimestampInS: number;\n  // Essentially a a set of span ids that are already sent. The values are expiration\n  // times in this cache so we don't hold onto them indefinitely.\n  private _sentSpans: Map<string, number>;\n  /* Internally, we use a debounced flush to give some wiggle room to the span processor to accumulate more spans. */\n  private _debouncedFlush: ReturnType<typeof debounce>;\n\n  public constructor(options?: {\n    /** Lower bound of time in seconds until spans that are buffered but have not been sent as part of a transaction get cleared from memory. */\n    timeout?: number;\n  }) {\n    this._finishedSpanBucketSize = options?.timeout || DEFAULT_TIMEOUT;\n    this._finishedSpanBuckets = new Array(this._finishedSpanBucketSize).fill(undefined);\n    this._lastCleanupTimestampInS = Math.floor(Date.now() / 1000);\n    this._spansToBucketEntry = new WeakMap();\n    this._sentSpans = new Map<string, number>();\n    this._debouncedFlush = debounce(this.flush.bind(this), 1, { maxWait: 100 });\n  }\n\n  /**\n   * Export a single span.\n   * This is called by the span processor whenever a span is ended.\n   */\n  public export(span: ReadableSpan): void {\n    const currentTimestampInS = Math.floor(Date.now() / 1000);\n\n    if (this._lastCleanupTimestampInS !== currentTimestampInS) {\n      let droppedSpanCount = 0;\n      this._finishedSpanBuckets.forEach((bucket, i) => {\n        if (bucket && bucket.timestampInS <= currentTimestampInS - this._finishedSpanBucketSize) {\n          droppedSpanCount += bucket.spans.size;\n          this._finishedSpanBuckets[i] = undefined;\n        }\n      });\n      if (droppedSpanCount > 0) {\n        DEBUG_BUILD &&\n          logger.log(\n            `SpanExporter dropped ${droppedSpanCount} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`,\n          );\n      }\n      this._lastCleanupTimestampInS = currentTimestampInS;\n    }\n\n    const currentBucketIndex = currentTimestampInS % this._finishedSpanBucketSize;\n    const currentBucket = this._finishedSpanBuckets[currentBucketIndex] || {\n      timestampInS: currentTimestampInS,\n      spans: new Set(),\n    };\n    this._finishedSpanBuckets[currentBucketIndex] = currentBucket;\n    currentBucket.spans.add(span);\n    this._spansToBucketEntry.set(span, currentBucket);\n\n    // If the span doesn't have a local parent ID (it's a root span), we're gonna flush all the ended spans\n    const localParentId = getLocalParentId(span);\n    if (!localParentId || this._sentSpans.has(localParentId)) {\n      this._debouncedFlush();\n    }\n  }\n\n  /**\n   * Try to flush any pending spans immediately.\n   * This is called internally by the exporter (via _debouncedFlush),\n   * but can also be triggered externally if we force-flush.\n   */\n  public flush(): void {\n    const finishedSpans = this._finishedSpanBuckets.flatMap(bucket => (bucket ? Array.from(bucket.spans) : []));\n\n    this._flushSentSpanCache();\n    const sentSpans = this._maybeSend(finishedSpans);\n\n    const sentSpanCount = sentSpans.size;\n    const remainingOpenSpanCount = finishedSpans.length - sentSpanCount;\n    DEBUG_BUILD &&\n      logger.log(\n        `SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} spans are waiting for their parent spans to finish`,\n      );\n\n    const expirationDate = Date.now() + DEFAULT_TIMEOUT * 1000;\n\n    for (const span of sentSpans) {\n      this._sentSpans.set(span.spanContext().spanId, expirationDate);\n      const bucketEntry = this._spansToBucketEntry.get(span);\n      if (bucketEntry) {\n        bucketEntry.spans.delete(span);\n      }\n    }\n    // Cancel a pending debounced flush, if there is one\n    // This can be relevant if we directly flush, circumventing the debounce\n    // in that case, we want to cancel any pending debounced flush\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Clear the exporter.\n   * This is called when the span processor is shut down.\n   */\n  public clear(): void {\n    this._finishedSpanBuckets = this._finishedSpanBuckets.fill(undefined);\n    this._sentSpans.clear();\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Send the given spans, but only if they are part of a finished transaction.\n   *\n   * Returns the sent spans.\n   * Spans remain unsent when their parent span is not yet finished.\n   * This will happen regularly, as child spans are generally finished before their parents.\n   * But it _could_ also happen because, for whatever reason, a parent span was lost.\n   * In this case, we'll eventually need to clean this up.\n   */\n  private _maybeSend(spans: ReadableSpan[]): Set<ReadableSpan> {\n    const grouped = groupSpansWithParents(spans);\n    const sentSpans = new Set<ReadableSpan>();\n\n    const rootNodes = this._getCompletedRootNodes(grouped);\n\n    for (const root of rootNodes) {\n      const span = root.span;\n      sentSpans.add(span);\n      const transactionEvent = createTransactionForOtelSpan(span);\n\n      // We'll recursively add all the child spans to this array\n      const spans = transactionEvent.spans || [];\n\n      for (const child of root.children) {\n        createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n      }\n\n      // spans.sort() mutates the array, but we do not use this anymore after this point\n      // so we can safely mutate it here\n      transactionEvent.spans =\n        spans.length > MAX_SPAN_COUNT\n          ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n          : spans;\n\n      const measurements = timedEventsToMeasurements(span.events);\n      if (measurements) {\n        transactionEvent.measurements = measurements;\n      }\n\n      captureEvent(transactionEvent);\n    }\n\n    return sentSpans;\n  }\n\n  /** Remove \"expired\" span id entries from the _sentSpans cache. */\n  private _flushSentSpanCache(): void {\n    const currentTimestamp = Date.now();\n    // Note, it is safe to delete items from the map as we go: https://stackoverflow.com/a/35943995/90297\n    for (const [spanId, expirationTime] of this._sentSpans.entries()) {\n      if (expirationTime <= currentTimestamp) {\n        this._sentSpans.delete(spanId);\n      }\n    }\n  }\n\n  /** Check if a node is a completed root node or a node whose parent has already been sent */\n  private _nodeIsCompletedRootNodeOrHasSentParent(node: SpanNode): node is SpanNodeCompleted {\n    return !!node.span && (!node.parentNode || this._sentSpans.has(node.parentNode.id));\n  }\n\n  /** Get all completed root nodes from a list of nodes */\n  private _getCompletedRootNodes(nodes: SpanNode[]): SpanNodeCompleted[] {\n    // TODO: We should be able to remove the explicit `node is SpanNodeCompleted` type guard\n    //       once we stop supporting TS < 5.5\n    return nodes.filter((node): node is SpanNodeCompleted => this._nodeIsCompletedRootNodeOrHasSentParent(node));\n  }\n}\n\nfunction parseSpan(span: ReadableSpan): { op?: string; origin?: SpanOrigin; source?: TransactionSource } {\n  const attributes = span.attributes;\n\n  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] as SpanOrigin | undefined;\n  const op = attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] as string | undefined;\n  const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] as TransactionSource | undefined;\n\n  return { origin, op, source };\n}\n\n/** Exported only for tests. */\nexport function createTransactionForOtelSpan(span: ReadableSpan): TransactionEvent {\n  const { op, description, data, origin = 'manual', source } = getSpanData(span);\n  const capturedSpanScopes = getCapturedScopesOnSpan(span as unknown as Span);\n\n  const sampleRate = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] as number | undefined;\n\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n    [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    ...data,\n    ...removeSentryAttributes(span.attributes),\n  };\n\n  const { links } = span;\n  const { traceId: trace_id, spanId: span_id } = span.spanContext();\n\n  // If parentSpanIdFromTraceState is defined at all, we want it to take precedence\n  // In that case, an empty string should be interpreted as \"no parent span id\",\n  // even if `span.parentSpanId` is set\n  // this is the case when we are starting a new trace, where we have a virtual span based on the propagationContext\n  // We only want to continue the traceId in this case, but ignore the parent span\n  const parent_span_id = getParentSpanId(span);\n\n  const status = mapStatus(span);\n\n  const traceContext: TraceContext = {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data: attributes,\n    origin,\n    op,\n    status: getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    links: convertSpanLinksForEnvelope(links),\n  };\n\n  const statusCode = attributes[ATTR_HTTP_RESPONSE_STATUS_CODE];\n  const responseContext = typeof statusCode === 'number' ? { response: { status_code: statusCode } } : undefined;\n\n  const transactionEvent: TransactionEvent = {\n    contexts: {\n      trace: traceContext,\n      otel: {\n        resource: span.resource.attributes,\n      },\n      ...responseContext,\n    },\n    spans: [],\n    start_timestamp: spanTimeInputToSeconds(span.startTime),\n    timestamp: spanTimeInputToSeconds(span.endTime),\n    transaction: description,\n    type: 'transaction',\n    sdkProcessingMetadata: {\n      capturedSpanScope: capturedSpanScopes.scope,\n      capturedSpanIsolationScope: capturedSpanScopes.isolationScope,\n      sampleRate,\n      dynamicSamplingContext: getDynamicSamplingContextFromSpan(span as unknown as Span),\n    },\n    ...(source && {\n      transaction_info: {\n        source,\n      },\n    }),\n  };\n\n  return transactionEvent;\n}\n\nfunction createAndFinishSpanForOtelSpan(node: SpanNode, spans: SpanJSON[], sentSpans: Set<ReadableSpan>): void {\n  const span = node.span;\n\n  if (span) {\n    sentSpans.add(span);\n  }\n\n  const shouldDrop = !span;\n\n  // If this span should be dropped, we still want to create spans for the children of this\n  if (shouldDrop) {\n    node.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n    });\n    return;\n  }\n\n  const span_id = span.spanContext().spanId;\n  const trace_id = span.spanContext().traceId;\n  const parentSpanId = getParentSpanId(span);\n\n  const { attributes, startTime, endTime, links } = span;\n\n  const { op, description, data, origin = 'manual' } = getSpanData(span);\n  const allData = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    ...removeSentryAttributes(attributes),\n    ...data,\n  };\n\n  const status = mapStatus(span);\n\n  const spanJSON: SpanJSON = {\n    span_id,\n    trace_id,\n    data: allData,\n    description,\n    parent_span_id: parentSpanId,\n    start_timestamp: spanTimeInputToSeconds(startTime),\n    // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n    timestamp: spanTimeInputToSeconds(endTime) || undefined,\n    status: getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    op,\n    origin,\n    measurements: timedEventsToMeasurements(span.events),\n    links: convertSpanLinksForEnvelope(links),\n  };\n\n  spans.push(spanJSON);\n\n  node.children.forEach(child => {\n    createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n  });\n}\n\nfunction getSpanData(span: ReadableSpan): {\n  data: Record<string, unknown>;\n  op?: string;\n  description: string;\n  source?: TransactionSource;\n  origin?: SpanOrigin;\n} {\n  const { op: definedOp, source: definedSource, origin } = parseSpan(span);\n  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);\n\n  const op = definedOp || inferredOp;\n  const source = definedSource || inferredSource;\n\n  const data = { ...inferredData, ...getData(span) };\n\n  return {\n    op,\n    description,\n    source,\n    origin,\n    data,\n  };\n}\n\n/**\n * Remove custom `sentry.` attributes we do not need to send.\n * These are more carrier attributes we use inside of the SDK, we do not need to send them to the API.\n */\nfunction removeSentryAttributes(data: Record<string, unknown>): Record<string, unknown> {\n  const cleanedData = { ...data };\n\n  /* eslint-disable @typescript-eslint/no-dynamic-delete */\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  /* eslint-enable @typescript-eslint/no-dynamic-delete */\n\n  return cleanedData;\n}\n\nfunction getData(span: ReadableSpan): Record<string, unknown> {\n  const attributes = span.attributes;\n  const data: Record<string, unknown> = {};\n\n  if (span.kind !== SpanKind.INTERNAL) {\n    data['otel.kind'] = SpanKind[span.kind];\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeHttpStatusCodeAttribute = attributes[SEMATTRS_HTTP_STATUS_CODE];\n  if (maybeHttpStatusCodeAttribute) {\n    data[ATTR_HTTP_RESPONSE_STATUS_CODE] = maybeHttpStatusCodeAttribute as string;\n  }\n\n  const requestData = getRequestSpanData(span);\n\n  if (requestData.url) {\n    data.url = requestData.url;\n  }\n\n  if (requestData['http.query']) {\n    data['http.query'] = requestData['http.query'].slice(1);\n  }\n  if (requestData['http.fragment']) {\n    data['http.fragment'] = requestData['http.fragment'].slice(1);\n  }\n\n  return data;\n}\n","import type { Context } from '@opentelemetry/api';\nimport { ROOT_CONTEXT, trace } from '@opentelemetry/api';\nimport type { ReadableSpan, Span, SpanProcessor as SpanProcessorInterface } from '@opentelemetry/sdk-trace-base';\nimport {\n  addChildSpanToSpan,\n  getClient,\n  getDefaultCurrentScope,\n  getDefaultIsolationScope,\n  logSpanEnd,\n  logSpanStart,\n  setCapturedScopesOnSpan,\n} from '@sentry/core';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE } from './semanticAttributes';\nimport { SentrySpanExporter } from './spanExporter';\nimport { getScopesFromContext } from './utils/contextData';\nimport { setIsSetup } from './utils/setupCheck';\n\nfunction onSpanStart(span: Span, parentContext: Context): void {\n  // This is a reliable way to get the parent span - because this is exactly how the parent is identified in the OTEL SDK\n  const parentSpan = trace.getSpan(parentContext);\n\n  let scopes = getScopesFromContext(parentContext);\n\n  // We need access to the parent span in order to be able to move up the span tree for breadcrumbs\n  if (parentSpan && !parentSpan.spanContext().isRemote) {\n    addChildSpanToSpan(parentSpan, span);\n  }\n\n  // We need this in the span exporter\n  if (parentSpan?.spanContext().isRemote) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);\n  }\n\n  // The root context does not have scopes stored, so we check for this specifically\n  // As fallback we attach the global scopes\n  if (parentContext === ROOT_CONTEXT) {\n    scopes = {\n      scope: getDefaultCurrentScope(),\n      isolationScope: getDefaultIsolationScope(),\n    };\n  }\n\n  // We need the scope at time of span creation in order to apply it to the event when the span is finished\n  if (scopes) {\n    setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);\n  }\n\n  logSpanStart(span);\n\n  const client = getClient();\n  client?.emit('spanStart', span);\n}\n\nfunction onSpanEnd(span: Span): void {\n  logSpanEnd(span);\n\n  const client = getClient();\n  client?.emit('spanEnd', span);\n}\n\n/**\n * Converts OpenTelemetry Spans to Sentry Spans and sends them to Sentry via\n * the Sentry SDK.\n */\nexport class SentrySpanProcessor implements SpanProcessorInterface {\n  private _exporter: SentrySpanExporter;\n\n  public constructor(options?: { timeout?: number }) {\n    setIsSetup('SentrySpanProcessor');\n    this._exporter = new SentrySpanExporter(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async forceFlush(): Promise<void> {\n    this._exporter.flush();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async shutdown(): Promise<void> {\n    this._exporter.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public onStart(span: Span, parentContext: Context): void {\n    onSpanStart(span, parentContext);\n  }\n\n  /** @inheritDoc */\n  public onEnd(span: Span & ReadableSpan): void {\n    onSpanEnd(span);\n\n    this._exporter.export(span);\n  }\n}\n","/* eslint-disable complexity */\nimport type { Context, Span, TraceState as TraceStateInterface } from '@opentelemetry/api';\nimport { isSpanContextValid, SpanKind, trace } from '@opentelemetry/api';\nimport { TraceState } from '@opentelemetry/core';\nimport type { Sampler, SamplingResult } from '@opentelemetry/sdk-trace-base';\nimport { SamplingDecision } from '@opentelemetry/sdk-trace-base';\nimport {\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_URL_FULL,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_URL,\n} from '@opentelemetry/semantic-conventions';\nimport type { Client, SpanAttributes } from '@sentry/core';\nimport {\n  baggageHeaderToDynamicSamplingContext,\n  hasSpansEnabled,\n  logger,\n  parseSampleRate,\n  sampleSpan,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,\n} from '@sentry/core';\nimport {\n  SENTRY_TRACE_STATE_DSC,\n  SENTRY_TRACE_STATE_SAMPLE_RAND,\n  SENTRY_TRACE_STATE_SAMPLE_RATE,\n  SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING,\n  SENTRY_TRACE_STATE_URL,\n} from './constants';\nimport { DEBUG_BUILD } from './debug-build';\nimport { getScopesFromContext } from './utils/contextData';\nimport { getSamplingDecision } from './utils/getSamplingDecision';\nimport { inferSpanData } from './utils/parseSpanDescription';\nimport { setIsSetup } from './utils/setupCheck';\n\n/**\n * A custom OTEL sampler that uses Sentry sampling rates to make its decision\n */\nexport class SentrySampler implements Sampler {\n  private _client: Client;\n\n  public constructor(client: Client) {\n    this._client = client;\n    setIsSetup('SentrySampler');\n  }\n\n  /** @inheritDoc */\n  public shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    spanAttributes: SpanAttributes,\n    _links: unknown,\n  ): SamplingResult {\n    const options = this._client.getOptions();\n\n    const parentSpan = getValidSpan(context);\n    const parentContext = parentSpan?.spanContext();\n\n    if (!hasSpansEnabled(options)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    // `ATTR_HTTP_REQUEST_METHOD` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_METHOD`, for now.\n    // eslint-disable-next-line deprecation/deprecation\n    const maybeSpanHttpMethod = spanAttributes[SEMATTRS_HTTP_METHOD] || spanAttributes[ATTR_HTTP_REQUEST_METHOD];\n\n    // If we have a http.client span that has no local parent, we never want to sample it\n    // but we want to leave downstream sampling decisions up to the server\n    if (spanKind === SpanKind.CLIENT && maybeSpanHttpMethod && (!parentSpan || parentContext?.isRemote)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;\n    const isRootSpan = !parentSpan || parentContext?.isRemote;\n\n    // We only sample based on parameters (like tracesSampleRate or tracesSampler) for root spans (which is done in sampleSpan).\n    // Non-root-spans simply inherit the sampling decision from their parent.\n    if (!isRootSpan) {\n      return wrapSamplingDecision({\n        decision: parentSampled ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n      });\n    }\n\n    // We want to pass the inferred name & attributes to the sampler method\n    const {\n      description: inferredSpanName,\n      data: inferredAttributes,\n      op,\n    } = inferSpanData(spanName, spanAttributes, spanKind);\n\n    const mergedAttributes = {\n      ...inferredAttributes,\n      ...spanAttributes,\n    };\n\n    if (op) {\n      mergedAttributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] = op;\n    }\n\n    const mutableSamplingDecision = { decision: true };\n    this._client.emit(\n      'beforeSampling',\n      {\n        spanAttributes: mergedAttributes,\n        spanName: inferredSpanName,\n        parentSampled: parentSampled,\n        parentContext: parentContext,\n      },\n      mutableSamplingDecision,\n    );\n    if (!mutableSamplingDecision.decision) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const { isolationScope } = getScopesFromContext(context) ?? {};\n\n    const dscString = parentContext?.traceState ? parentContext.traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n    const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n    const sampleRand = parseSampleRate(dsc?.sample_rand) ?? Math.random();\n\n    const [sampled, sampleRate, localSampleRateWasApplied] = sampleSpan(\n      options,\n      {\n        name: inferredSpanName,\n        attributes: mergedAttributes,\n        normalizedRequest: isolationScope?.getScopeData().sdkProcessingMetadata.normalizedRequest,\n        parentSampled,\n        parentSampleRate: parseSampleRate(dsc?.sample_rate),\n      },\n      sampleRand,\n    );\n\n    const method = `${maybeSpanHttpMethod}`.toUpperCase();\n    if (method === 'OPTIONS' || method === 'HEAD') {\n      DEBUG_BUILD && logger.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);\n\n      return wrapSamplingDecision({\n        decision: SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: 0, // we don't want to sample anything in the downstream trace either\n      });\n    }\n\n    if (\n      !sampled &&\n      // We check for `parentSampled === undefined` because we only want to record client reports for spans that are trace roots (ie. when there was incoming trace)\n      parentSampled === undefined\n    ) {\n      DEBUG_BUILD && logger.log('[Tracing] Discarding root span because its trace was not chosen to be sampled.');\n      this._client.recordDroppedEvent('sample_rate', 'transaction');\n    }\n\n    return {\n      ...wrapSamplingDecision({\n        decision: sampled ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: localSampleRateWasApplied ? sampleRate : undefined,\n      }),\n      attributes: {\n        // We set the sample rate on the span when a local sample rate was applied to better understand how traces were sampled in Sentry\n        [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: localSampleRateWasApplied ? sampleRate : undefined,\n      },\n    };\n  }\n\n  /** Returns the sampler name or short description with the configuration. */\n  public toString(): string {\n    return 'SentrySampler';\n  }\n}\n\nfunction getParentSampled(parentSpan: Span, traceId: string, spanName: string): boolean | undefined {\n  const parentContext = parentSpan.spanContext();\n\n  // Only inherit sample rate if `traceId` is the same\n  // Note for testing: `isSpanContextValid()` checks the format of the traceId/spanId, so we need to pass valid ones\n  if (isSpanContextValid(parentContext) && parentContext.traceId === traceId) {\n    if (parentContext.isRemote) {\n      const parentSampled = getSamplingDecision(parentSpan.spanContext());\n      DEBUG_BUILD &&\n        logger.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled}`);\n      return parentSampled;\n    }\n\n    const parentSampled = getSamplingDecision(parentContext);\n    DEBUG_BUILD && logger.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);\n    return parentSampled;\n  }\n\n  return undefined;\n}\n\n/**\n * Wrap a sampling decision with data that Sentry needs to work properly with it.\n * If you pass `decision: undefined`, it will be treated as `NOT_RECORDING`, but in contrast to passing `NOT_RECORDING`\n * it will not propagate this decision to downstream Sentry SDKs.\n */\nexport function wrapSamplingDecision({\n  decision,\n  context,\n  spanAttributes,\n  sampleRand,\n  downstreamTraceSampleRate,\n}: {\n  decision: SamplingDecision | undefined;\n  context: Context;\n  spanAttributes: SpanAttributes;\n  sampleRand?: number;\n  downstreamTraceSampleRate?: number;\n}): SamplingResult {\n  let traceState = getBaseTraceState(context, spanAttributes);\n\n  // We will override the propagated sample rate downstream when\n  // - the tracesSampleRate is applied\n  // - the tracesSampler is invoked\n  // Since unsampled OTEL spans (NonRecordingSpans) cannot hold attributes we need to store this on the (trace)context.\n  if (downstreamTraceSampleRate !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RATE, `${downstreamTraceSampleRate}`);\n  }\n\n  if (sampleRand !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RAND, `${sampleRand}`);\n  }\n\n  // If the decision is undefined, we treat it as NOT_RECORDING, but we don't propagate this decision to downstream SDKs\n  // Which is done by not setting `SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING` traceState\n  if (decision == undefined) {\n    return { decision: SamplingDecision.NOT_RECORD, traceState };\n  }\n\n  if (decision === SamplingDecision.NOT_RECORD) {\n    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') };\n  }\n\n  return { decision, traceState };\n}\n\nfunction getBaseTraceState(context: Context, spanAttributes: SpanAttributes): TraceStateInterface {\n  const parentSpan = trace.getSpan(context);\n  const parentContext = parentSpan?.spanContext();\n\n  let traceState = parentContext?.traceState || new TraceState();\n\n  // We always keep the URL on the trace state, so we can access it in the propagator\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const url = spanAttributes[SEMATTRS_HTTP_URL] || spanAttributes[ATTR_URL_FULL];\n  if (url && typeof url === 'string') {\n    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);\n  }\n\n  return traceState;\n}\n\n/**\n * If the active span is invalid, we want to ignore it as parent.\n * This aligns with how otel tracers and default samplers handle these cases.\n */\nfunction getValidSpan(context: Context): Span | undefined {\n  const span = trace.getSpan(context);\n  return span && isSpanContextValid(span.spanContext()) ? span : undefined;\n}\n"],"names":["ATTR_URL_FULL","SEMATTRS_HTTP_URL","ATTR_HTTP_REQUEST_METHOD","SEMATTRS_HTTP_METHOD","parseUrl","getSanitizedUrlString","SDK_VERSION","trace","SpanKind","createContextKey","addNonEnumerableProperty","isSentryRequestUrl","getClient","TraceFlags","baggageHeaderToDynamicSamplingContext","SEMATTRS_DB_SYSTEM","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","SEMATTRS_RPC_SERVICE","SEMATTRS_MESSAGING_SYSTEM","SEMATTRS_FAAS_TRIGGER","SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME","SEMATTRS_DB_STATEMENT","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMATTRS_HTTP_TARGET","ATTR_HTTP_ROUTE","stripUrlQueryAndFragment","spanToJSON","hasSpansEnabled","dynamicSamplingContextToSentryBaggageHeader","TraceState","W3CBaggagePropagator","LRUMap","isTracingSuppressed","logger","propagation","parseBaggageHeader","SENTRY_BAGGAGE_KEY_PREFIX","INVALID_TRACEID","generateSentryTraceHeader","stringMatchesSomePattern","getDynamicSamplingContextFromSpan","getCurrentScope","getDynamicSamplingContextFromScope","propagationContextFromHeaders","context","getIsolationScope","suppressTracing","handleCallbackErrors","SpanStatusCode","getRootSpan","spanToTraceContext","getTraceContextFromScope","suppressTracingImpl","getCapturedScopesOnSpan","getDefaultCurrentScope","getDefaultIsolationScope","setAsyncContextStrategy","SPAN_STATUS_OK","SPAN_STATUS_ERROR","ATTR_HTTP_RESPONSE_STATUS_CODE","SEMATTRS_HTTP_STATUS_CODE","SEMATTRS_RPC_GRPC_STATUS_CODE","getSpanStatusFromHttpCode","debounce","timedEventsToMeasurements","captureEvent","SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE","getStatusMessage","convertSpanLinksForEnvelope","spanTimeInputToSeconds","addChildSpanToSpan","ROOT_CONTEXT","setCapturedScopesOnSpan","logSpanStart","logSpanEnd","SamplingDecision","parseSampleRate","sampleSpan","isSpanContextValid"],"mappings":"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"}},
    {"offset": {"line": 3772, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}