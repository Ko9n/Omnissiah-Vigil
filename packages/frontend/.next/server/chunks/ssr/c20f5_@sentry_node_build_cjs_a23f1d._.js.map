{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/http/index.ts"],"sourcesContent":["import type { ClientRequest, IncomingMessage, RequestOptions, ServerResponse } from 'node:http';\nimport { diag } from '@opentelemetry/api';\nimport type { HttpInstrumentationConfig } from '@opentelemetry/instrumentation-http';\nimport { HttpInstrumentation } from '@opentelemetry/instrumentation-http';\nimport type { Span } from '@sentry/core';\nimport { defineIntegration, getClient, hasSpansEnabled } from '@sentry/core';\nimport type { HTTPModuleRequestIncomingMessage, NodeClient } from '@sentry/node-core';\nimport {\n  type SentryHttpInstrumentationOptions,\n  addOriginToSpan,\n  generateInstrumentOnce,\n  getRequestUrl,\n  NODE_VERSION,\n  SentryHttpInstrumentation,\n} from '@sentry/node-core';\nimport type { NodeClientOptions } from '../../types';\n\nconst INTEGRATION_NAME = 'Http';\n\nconst INSTRUMENTATION_NAME = '@opentelemetry_sentry-patched/instrumentation-http';\n\ninterface HttpOptions {\n  /**\n   * Whether breadcrumbs should be recorded for outgoing requests.\n   * Defaults to true\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * If set to false, do not emit any spans.\n   * This will ensure that the default HttpInstrumentation from OpenTelemetry is not setup,\n   * only the Sentry-specific instrumentation for request isolation is applied.\n   *\n   * If `skipOpenTelemetrySetup: true` is configured, this defaults to `false`, otherwise it defaults to `true`.\n   */\n  spans?: boolean;\n\n  /**\n   * Whether the integration should create [Sessions](https://docs.sentry.io/product/releases/health/#sessions) for incoming requests to track the health and crash-free rate of your releases in Sentry.\n   * Read more about Release Health: https://docs.sentry.io/product/releases/health/\n   *\n   * Defaults to `true`.\n   */\n  trackIncomingRequestsAsSessions?: boolean;\n\n  /**\n   * Number of milliseconds until sessions tracked with `trackIncomingRequestsAsSessions` will be flushed as a session aggregate.\n   *\n   * Defaults to `60000` (60s).\n   */\n  sessionFlushingDelayMS?: number;\n\n  /**\n   * Do not capture spans or breadcrumbs for outgoing HTTP requests to URLs where the given callback returns `true`.\n   * This controls both span & breadcrumb creation - spans will be non recording if tracing is disabled.\n   *\n   * The `url` param contains the entire URL, including query string (if any), protocol, host, etc. of the outgoing request.\n   * For example: `'https://someService.com/users/details?id=123'`\n   *\n   * The `request` param contains the original {@type RequestOptions} object used to make the outgoing request.\n   * You can use it to filter on additional properties like method, headers, etc.\n   */\n  ignoreOutgoingRequests?: (url: string, request: RequestOptions) => boolean;\n\n  /**\n   * Do not capture spans for incoming HTTP requests to URLs where the given callback returns `true`.\n   * Spans will be non recording if tracing is disabled.\n   *\n   * The `urlPath` param consists of the URL path and query string (if any) of the incoming request.\n   * For example: `'/users/details?id=123'`\n   *\n   * The `request` param contains the original {@type IncomingMessage} object of the incoming request.\n   * You can use it to filter on additional properties like method, headers, etc.\n   */\n  ignoreIncomingRequests?: (urlPath: string, request: IncomingMessage) => boolean;\n\n  /**\n   * Do not capture spans for incoming HTTP requests with the given status codes.\n   * By default, spans with 404 status code are ignored.\n   * Expects an array of status codes or a range of status codes, e.g. [[300,399], 404] would ignore 3xx and 404 status codes.\n   *\n   * @default `[404]`\n   */\n  dropSpansForIncomingRequestStatusCodes?: (number | [number, number])[];\n\n  /**\n   * Do not capture the request body for incoming HTTP requests to URLs where the given callback returns `true`.\n   * This can be useful for long running requests where the body is not needed and we want to avoid capturing it.\n   *\n   * @param url Contains the entire URL, including query string (if any), protocol, host, etc. of the incoming request.\n   * @param request Contains the {@type RequestOptions} object used to make the incoming request.\n   */\n  ignoreIncomingRequestBody?: (url: string, request: RequestOptions) => boolean;\n\n  /**\n   * Controls the maximum size of incoming HTTP request bodies attached to events.\n   *\n   * Available options:\n   * - 'none': No request bodies will be attached\n   * - 'small': Request bodies up to 1,000 bytes will be attached\n   * - 'medium': Request bodies up to 10,000 bytes will be attached (default)\n   * - 'always': Request bodies will always be attached\n   *\n   * Note that even with 'always' setting, bodies exceeding 1MB will never be attached\n   * for performance and security reasons.\n   *\n   * @default 'medium'\n   */\n  maxIncomingRequestBodySize?: 'none' | 'small' | 'medium' | 'always';\n\n  /**\n   * If true, do not generate spans for incoming requests at all.\n   * This is used by Remix to avoid generating spans for incoming requests, as it generates its own spans.\n   */\n  disableIncomingRequestSpans?: boolean;\n\n  /**\n   * Additional instrumentation options that are passed to the underlying HttpInstrumentation.\n   */\n  instrumentation?: {\n    requestHook?: (span: Span, req: ClientRequest | HTTPModuleRequestIncomingMessage) => void;\n    responseHook?: (span: Span, response: HTTPModuleRequestIncomingMessage | ServerResponse) => void;\n    applyCustomAttributesOnSpan?: (\n      span: Span,\n      request: ClientRequest | HTTPModuleRequestIncomingMessage,\n      response: HTTPModuleRequestIncomingMessage | ServerResponse,\n    ) => void;\n\n    /**\n     * You can pass any configuration through to the underlying instrumentation.\n     * Note that there are no semver guarantees for this!\n     */\n    _experimentalConfig?: ConstructorParameters<typeof HttpInstrumentation>[0];\n  };\n}\n\nconst instrumentSentryHttp = generateInstrumentOnce<SentryHttpInstrumentationOptions>(\n  `${INTEGRATION_NAME}.sentry`,\n  options => {\n    return new SentryHttpInstrumentation(options);\n  },\n);\n\nexport const instrumentOtelHttp = generateInstrumentOnce<HttpInstrumentationConfig>(INTEGRATION_NAME, config => {\n  const instrumentation = new HttpInstrumentation(config);\n\n  // We want to update the logger namespace so we can better identify what is happening here\n  try {\n    instrumentation['_diag'] = diag.createComponentLogger({\n      namespace: INSTRUMENTATION_NAME,\n    });\n    // @ts-expect-error We are writing a read-only property here...\n    instrumentation.instrumentationName = INSTRUMENTATION_NAME;\n  } catch {\n    // ignore errors here...\n  }\n\n  return instrumentation;\n});\n\n/** Exported only for tests. */\nexport function _shouldInstrumentSpans(options: HttpOptions, clientOptions: Partial<NodeClientOptions> = {}): boolean {\n  // If `spans` is passed in, it takes precedence\n  // Else, we by default emit spans, unless `skipOpenTelemetrySetup` is set to `true` or spans are not enabled\n  if (typeof options.spans === 'boolean') {\n    return options.spans;\n  }\n\n  if (clientOptions.skipOpenTelemetrySetup) {\n    return false;\n  }\n\n  // IMPORTANT: We only disable span instrumentation when spans are not enabled _and_ we are on Node 22+,\n  // as otherwise the necessary diagnostics channel is not available yet\n  if (!hasSpansEnabled(clientOptions) && NODE_VERSION.major >= 22) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * The http integration instruments Node's internal http and https modules.\n * It creates breadcrumbs and spans for outgoing HTTP requests which will be attached to the currently active span.\n */\nexport const httpIntegration = defineIntegration((options: HttpOptions = {}) => {\n  const dropSpansForIncomingRequestStatusCodes = options.dropSpansForIncomingRequestStatusCodes ?? [404];\n\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      const instrumentSpans = _shouldInstrumentSpans(options, getClient<NodeClient>()?.getOptions());\n\n      // This is Sentry-specific instrumentation for request isolation and breadcrumbs\n      instrumentSentryHttp({\n        ...options,\n        // If spans are not instrumented, it means the HttpInstrumentation has not been added\n        // In that case, we want to handle incoming trace extraction ourselves\n        extractIncomingTraceFromHeader: !instrumentSpans,\n        // If spans are not instrumented, it means the HttpInstrumentation has not been added\n        // In that case, we want to handle trace propagation ourselves\n        propagateTraceInOutgoingRequests: !instrumentSpans,\n      });\n\n      // This is the \"regular\" OTEL instrumentation that emits spans\n      if (instrumentSpans) {\n        const instrumentationConfig = getConfigWithDefaults(options);\n        instrumentOtelHttp(instrumentationConfig);\n      }\n    },\n    processEvent(event) {\n      // Drop transaction if it has a status code that should be ignored\n      if (event.type === 'transaction') {\n        const statusCode = event.contexts?.trace?.data?.['http.response.status_code'];\n        if (\n          typeof statusCode === 'number' &&\n          dropSpansForIncomingRequestStatusCodes.some(code => {\n            if (typeof code === 'number') {\n              return code === statusCode;\n            }\n\n            const [min, max] = code;\n            return statusCode >= min && statusCode <= max;\n          })\n        ) {\n          return null;\n        }\n      }\n\n      return event;\n    },\n  };\n});\n\n/**\n * Determines if @param req is a ClientRequest, meaning the request was created within the express app\n * and it's an outgoing request.\n * Checking for properties instead of using `instanceOf` to avoid importing the request classes.\n */\nfunction _isClientRequest(req: ClientRequest | HTTPModuleRequestIncomingMessage): req is ClientRequest {\n  return 'outputData' in req && 'outputSize' in req && !('client' in req) && !('statusCode' in req);\n}\n\n/**\n * Detects if an incoming request is a prefetch request.\n */\nfunction isKnownPrefetchRequest(req: HTTPModuleRequestIncomingMessage): boolean {\n  // Currently only handles Next.js prefetch requests but may check other frameworks in the future.\n  return req.headers['next-router-prefetch'] === '1';\n}\n\nfunction getConfigWithDefaults(options: Partial<HttpOptions> = {}): HttpInstrumentationConfig {\n  const instrumentationConfig = {\n    ...options.instrumentation?._experimentalConfig,\n\n    disableIncomingRequestInstrumentation: options.disableIncomingRequestSpans,\n\n    ignoreOutgoingRequestHook: request => {\n      const url = getRequestUrl(request);\n\n      if (!url) {\n        return false;\n      }\n\n      const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;\n      if (_ignoreOutgoingRequests?.(url, request)) {\n        return true;\n      }\n\n      return false;\n    },\n\n    ignoreIncomingRequestHook: request => {\n      // request.url is the only property that holds any information about the url\n      // it only consists of the URL path and query string (if any)\n      const urlPath = request.url;\n\n      const method = request.method?.toUpperCase();\n      // We do not capture OPTIONS/HEAD requests as transactions\n      if (method === 'OPTIONS' || method === 'HEAD') {\n        return true;\n      }\n\n      const _ignoreIncomingRequests = options.ignoreIncomingRequests;\n      if (urlPath && _ignoreIncomingRequests?.(urlPath, request)) {\n        return true;\n      }\n\n      return false;\n    },\n\n    requireParentforOutgoingSpans: false,\n    requireParentforIncomingSpans: false,\n    requestHook: (span, req) => {\n      addOriginToSpan(span, 'auto.http.otel.http');\n      if (!_isClientRequest(req) && isKnownPrefetchRequest(req)) {\n        span.setAttribute('sentry.http.prefetch', true);\n      }\n\n      options.instrumentation?.requestHook?.(span, req);\n    },\n    responseHook: (span, res) => {\n      options.instrumentation?.responseHook?.(span, res);\n    },\n    applyCustomAttributesOnSpan: (\n      span: Span,\n      request: ClientRequest | HTTPModuleRequestIncomingMessage,\n      response: HTTPModuleRequestIncomingMessage | ServerResponse,\n    ) => {\n      options.instrumentation?.applyCustomAttributesOnSpan?.(span, request, response);\n    },\n  } satisfies HttpInstrumentationConfig;\n\n  return instrumentationConfig;\n}\n"],"names":["generateInstrumentOnce","SentryHttpInstrumentation","HttpInstrumentation","diag","hasSpansEnabled","NODE_VERSION","defineIntegration","getClient","getRequestUrl","addOriginToSpan"],"mappings":"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"}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/node-fetch/index.ts"],"sourcesContent":["import type { UndiciInstrumentationConfig } from '@opentelemetry/instrumentation-undici';\nimport { UndiciInstrumentation } from '@opentelemetry/instrumentation-undici';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration, getClient, hasSpansEnabled, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '@sentry/core';\nimport type { NodeClient } from '@sentry/node-core';\nimport { generateInstrumentOnce, SentryNodeFetchInstrumentation } from '@sentry/node-core';\nimport type { NodeClientOptions } from '../../types';\n\nconst INTEGRATION_NAME = 'NodeFetch';\n\ninterface NodeFetchOptions {\n  /**\n   * Whether breadcrumbs should be recorded for requests.\n   * Defaults to true\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * If set to false, do not emit any spans.\n   * This will ensure that the default UndiciInstrumentation from OpenTelemetry is not setup,\n   * only the Sentry-specific instrumentation for breadcrumbs & trace propagation is applied.\n   *\n   * If `skipOpenTelemetrySetup: true` is configured, this defaults to `false`, otherwise it defaults to `true`.\n   */\n  spans?: boolean;\n\n  /**\n   * Do not capture spans or breadcrumbs for outgoing fetch requests to URLs where the given callback returns `true`.\n   * This controls both span & breadcrumb creation - spans will be non recording if tracing is disabled.\n   */\n  ignoreOutgoingRequests?: (url: string) => boolean;\n}\n\nconst instrumentOtelNodeFetch = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  UndiciInstrumentation,\n  (options: NodeFetchOptions) => {\n    return getConfigWithDefaults(options);\n  },\n);\n\nconst instrumentSentryNodeFetch = generateInstrumentOnce(\n  `${INTEGRATION_NAME}.sentry`,\n  SentryNodeFetchInstrumentation,\n  (options: NodeFetchOptions) => {\n    return options;\n  },\n);\n\nconst _nativeNodeFetchIntegration = ((options: NodeFetchOptions = {}) => {\n  return {\n    name: 'NodeFetch',\n    setupOnce() {\n      const instrumentSpans = _shouldInstrumentSpans(options, getClient<NodeClient>()?.getOptions());\n\n      // This is the \"regular\" OTEL instrumentation that emits spans\n      if (instrumentSpans) {\n        instrumentOtelNodeFetch(options);\n      }\n\n      // This is the Sentry-specific instrumentation that creates breadcrumbs & propagates traces\n      // This must be registered after the OTEL one, to ensure that the core trace propagation logic takes presedence\n      // Otherwise, the sentry-trace header may be set multiple times\n      instrumentSentryNodeFetch(options);\n    },\n  };\n}) satisfies IntegrationFn;\n\nexport const nativeNodeFetchIntegration = defineIntegration(_nativeNodeFetchIntegration);\n\n// Matching the behavior of the base instrumentation\nfunction getAbsoluteUrl(origin: string, path: string = '/'): string {\n  const url = `${origin}`;\n\n  if (url.endsWith('/') && path.startsWith('/')) {\n    return `${url}${path.slice(1)}`;\n  }\n\n  if (!url.endsWith('/') && !path.startsWith('/')) {\n    return `${url}/${path.slice(1)}`;\n  }\n\n  return `${url}${path}`;\n}\n\nfunction _shouldInstrumentSpans(options: NodeFetchOptions, clientOptions: Partial<NodeClientOptions> = {}): boolean {\n  // If `spans` is passed in, it takes precedence\n  // Else, we by default emit spans, unless `skipOpenTelemetrySetup` is set to `true` or spans are not enabled\n  return typeof options.spans === 'boolean'\n    ? options.spans\n    : !clientOptions.skipOpenTelemetrySetup && hasSpansEnabled(clientOptions);\n}\n\nfunction getConfigWithDefaults(options: Partial<NodeFetchOptions> = {}): UndiciInstrumentationConfig {\n  const instrumentationConfig = {\n    requireParentforSpans: false,\n    ignoreRequestHook: request => {\n      const url = getAbsoluteUrl(request.origin, request.path);\n      const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;\n      const shouldIgnore = _ignoreOutgoingRequests && url && _ignoreOutgoingRequests(url);\n\n      return !!shouldIgnore;\n    },\n    startSpanHook: () => {\n      return {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.node_fetch',\n      };\n    },\n  } satisfies UndiciInstrumentationConfig;\n\n  return instrumentationConfig;\n}\n"],"names":["generateInstrumentOnce","UndiciInstrumentation","SentryNodeFetchInstrumentation","getClient","defineIntegration","hasSpansEnabled","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN"],"mappings":";;;;;;AAQA,MAAM,mBAAmB;AAyBzB,MAAM,0BAA0BA,SAAAA,sBAAsB,CACpD,kBACAC,sBAAAA,qBAAqB,EACrB,CAAC;IACC,OAAO,sBAAsB;AACjC;AAGA,MAAM,4BAA4BD,SAAAA,sBAAsB,CACtD,CAAC,EAAA,iBAAA,OAAA,CAAA,EACAE,SAAAA,8BAAA,EACA,CAAA;IACA,OAAA;AACA;AAGA,MAAA,8BAAA,CAAA,UAAA,CAAA,CAAA;IACA,OAAA;QACA,MAAA;QACA;YACA,MAAA,kBAAA,uBAAA,SAAAC,KAAAA,SAAA,IAAA;YAEA,8DAAA;YACA,IAAA,iBAAA;gBACA,wBAAA;YACA;YAEA,2FAAA;YACA,+GAAA;YACA,+DAAA;YACA,0BAAA;QACA;IACA;AACA;AAEA,MAAA,6BAAAC,KAAAA,iBAAA,CAAA;AAEA,oDAAA;AACA,SAAA,eAAA,MAAA,EAAA,OAAA,GAAA;IACA,MAAA,MAAA,CAAA,EAAA,OAAA,CAAA;IAEA,IAAA,IAAA,QAAA,CAAA,QAAA,KAAA,UAAA,CAAA,MAAA;QACA,OAAA,CAAA,EAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,CAAA;IACA;IAEA,IAAA,CAAA,IAAA,QAAA,CAAA,QAAA,CAAA,KAAA,UAAA,CAAA,MAAA;QACA,OAAA,CAAA,EAAA,IAAA,CAAA,EAAA,KAAA,KAAA,CAAA,GAAA,CAAA;IACA;IAEA,OAAA,CAAA,EAAA,IAAA,EAAA,KAAA,CAAA;AACA;AAEA,SAAA,uBAAA,OAAA,EAAA,gBAAA,CAAA,CAAA;IACA,+CAAA;IACA,4GAAA;IACA,OAAA,OAAA,QAAA,KAAA,KAAA,YACA,QAAA,KAAA,GACA,CAAA,cAAA,sBAAA,IAAAC,KAAAA,eAAA,CAAA;AACA;AAEA,SAAA,sBAAA,UAAA,CAAA,CAAA;IACA,MAAA,wBAAA;QACA,uBAAA;QACA,mBAAA,CAAA;YACA,MAAA,MAAA,eAAA,QAAA,MAAA,EAAA,QAAA,IAAA;YACA,MAAA,0BAAA,QAAA,sBAAA;YACA,MAAA,eAAA,2BAAA,OAAA,wBAAA;YAEA,OAAA,CAAA,CAAA;QACA;QACA,eAAA;YACA,OAAA;gBACA,CAAAC,KAAAA,gCAAA,CAAA,EAAA;YACA;QACA;IACA;IAEA,OAAA;AACA"}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 227, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/fs.ts"],"sourcesContent":["import { FsInstrumentation } from '@opentelemetry/instrumentation-fs';\nimport { defineIntegration, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '@sentry/core';\nimport { generateInstrumentOnce } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'FileSystem';\n\n/**\n * This integration will create spans for `fs` API operations, like reading and writing files.\n *\n * **WARNING:** This integration may add significant overhead to your application. Especially in scenarios with a lot of\n * file I/O, like for example when running a framework dev server, including this integration can massively slow down\n * your application.\n *\n * @param options Configuration for this integration.\n */\nexport const fsIntegration = defineIntegration(\n  (\n    options: {\n      /**\n       * Setting this option to `true` will include any filepath arguments from your `fs` API calls as span attributes.\n       *\n       * Defaults to `false`.\n       */\n      recordFilePaths?: boolean;\n\n      /**\n       * Setting this option to `true` will include the error messages of failed `fs` API calls as a span attribute.\n       *\n       * Defaults to `false`.\n       */\n      recordErrorMessagesAsSpanAttributes?: boolean;\n    } = {},\n  ) => {\n    return {\n      name: INTEGRATION_NAME,\n      setupOnce() {\n        generateInstrumentOnce(\n          INTEGRATION_NAME,\n          () =>\n            new FsInstrumentation({\n              requireParentSpan: true,\n              endHook(functionName, { args, span, error }) {\n                span.updateName(`fs.${functionName}`);\n\n                span.setAttributes({\n                  [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'file',\n                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.file.fs',\n                });\n\n                if (options.recordErrorMessagesAsSpanAttributes) {\n                  if (typeof args[0] === 'string' && FS_OPERATIONS_WITH_PATH_ARG.includes(functionName)) {\n                    span.setAttribute('path_argument', args[0]);\n                  } else if (\n                    typeof args[0] === 'string' &&\n                    typeof args[1] === 'string' &&\n                    FS_OPERATIONS_WITH_TARGET_PATH.includes(functionName)\n                  ) {\n                    span.setAttribute('target_argument', args[0]);\n                    span.setAttribute('path_argument', args[1]);\n                  } else if (typeof args[0] === 'string' && FS_OPERATIONS_WITH_PREFIX.includes(functionName)) {\n                    span.setAttribute('prefix_argument', args[0]);\n                  } else if (\n                    typeof args[0] === 'string' &&\n                    typeof args[1] === 'string' &&\n                    FS_OPERATIONS_WITH_EXISTING_PATH_NEW_PATH.includes(functionName)\n                  ) {\n                    span.setAttribute('existing_path_argument', args[0]);\n                    span.setAttribute('new_path_argument', args[1]);\n                  } else if (\n                    typeof args[0] === 'string' &&\n                    typeof args[1] === 'string' &&\n                    FS_OPERATIONS_WITH_SRC_DEST.includes(functionName)\n                  ) {\n                    span.setAttribute('src_argument', args[0]);\n                    span.setAttribute('dest_argument', args[1]);\n                  } else if (\n                    typeof args[0] === 'string' &&\n                    typeof args[1] === 'string' &&\n                    FS_OPERATIONS_WITH_OLD_PATH_NEW_PATH.includes(functionName)\n                  ) {\n                    span.setAttribute('old_path_argument', args[0]);\n                    span.setAttribute('new_path_argument', args[1]);\n                  }\n                }\n\n                if (error && options.recordErrorMessagesAsSpanAttributes) {\n                  span.setAttribute('fs_error', error.message);\n                }\n              },\n            }),\n        )();\n      },\n    };\n  },\n);\n\nconst FS_OPERATIONS_WITH_OLD_PATH_NEW_PATH = ['rename', 'renameSync'];\nconst FS_OPERATIONS_WITH_SRC_DEST = ['copyFile', 'cp', 'copyFileSync', 'cpSync'];\nconst FS_OPERATIONS_WITH_EXISTING_PATH_NEW_PATH = ['link', 'linkSync'];\nconst FS_OPERATIONS_WITH_PREFIX = ['mkdtemp', 'mkdtempSync'];\nconst FS_OPERATIONS_WITH_TARGET_PATH = ['symlink', 'symlinkSync'];\nconst FS_OPERATIONS_WITH_PATH_ARG = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'exists',\n  'mkdir',\n  'lchown',\n  'lstat',\n  'lutimes',\n  'open',\n  'opendir',\n  'readdir',\n  'readFile',\n  'readlink',\n  'realpath',\n  'realpath.native',\n  'rm',\n  'rmdir',\n  'stat',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile',\n  'accessSync',\n  'appendFileSync',\n  'chmodSync',\n  'chownSync',\n  'existsSync',\n  'lchownSync',\n  'lstatSync',\n  'lutimesSync',\n  'opendirSync',\n  'mkdirSync',\n  'openSync',\n  'readdirSync',\n  'readFileSync',\n  'readlinkSync',\n  'realpathSync',\n  'realpathSync.native',\n  'rmdirSync',\n  'rmSync',\n  'statSync',\n  'truncateSync',\n  'unlinkSync',\n  'utimesSync',\n  'writeFileSync',\n];\n"],"names":["defineIntegration","generateInstrumentOnce","FsInstrumentation","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN"],"mappings":";;;;;;AAIA,MAAM,mBAAmB;AAEzB;;;;;;;;CAQA,GACO,MAAM,gBAAgBA,KAAAA,iBAAiB,CAC5C,CACE,UAcI,CAAA,CAAE;IAEN,OAAO;QACL,MAAM;QACN;YACEC,SAAAA,sBAAsB,CACpB,kBACA,IACE,IAAIC,kBAAAA,iBAAiB,CAAC;oBACpB,mBAAmB;oBACnB,SAAQ,YAAY,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,KAAA,EAAO;wBACzC,KAAK,UAAU,CAAC,CAAC,GAAG,EAAE,aAAa,CAAA;wBAEA,KAAA,aAAA,CAAA;4BACA,CAAAC,KAAAA,4BAAA,CAAA,EAAA;4BACA,CAAAC,KAAAA,gCAAA,CAAA,EAAA;wBACA;wBAEA,IAAA,QAAA,mCAAA,EAAA;4BACA,IAAA,OAAA,IAAA,CAAA,EAAA,KAAA,YAAA,4BAAA,QAAA,CAAA,eAAA;gCACA,KAAA,YAAA,CAAA,iBAAA,IAAA,CAAA,EAAA;4BACA,OAAA,IACA,OAAA,IAAA,CAAA,EAAA,KAAA,YACA,OAAA,IAAA,CAAA,EAAA,KAAA,YACA,+BAAA,QAAA,CAAA,eACA;gCACA,KAAA,YAAA,CAAA,mBAAA,IAAA,CAAA,EAAA;gCACA,KAAA,YAAA,CAAA,iBAAA,IAAA,CAAA,EAAA;4BACA,OAAA,IAAA,OAAA,IAAA,CAAA,EAAA,KAAA,YAAA,0BAAA,QAAA,CAAA,eAAA;gCACA,KAAA,YAAA,CAAA,mBAAA,IAAA,CAAA,EAAA;4BACA,OAAA,IACA,OAAA,IAAA,CAAA,EAAA,KAAA,YACA,OAAA,IAAA,CAAA,EAAA,KAAA,YACA,0CAAA,QAAA,CAAA,eACA;gCACA,KAAA,YAAA,CAAA,0BAAA,IAAA,CAAA,EAAA;gCACA,KAAA,YAAA,CAAA,qBAAA,IAAA,CAAA,EAAA;4BACA,OAAA,IACA,OAAA,IAAA,CAAA,EAAA,KAAA,YACA,OAAA,IAAA,CAAA,EAAA,KAAA,YACA,4BAAA,QAAA,CAAA,eACA;gCACA,KAAA,YAAA,CAAA,gBAAA,IAAA,CAAA,EAAA;gCACA,KAAA,YAAA,CAAA,iBAAA,IAAA,CAAA,EAAA;4BACA,OAAA,IACA,OAAA,IAAA,CAAA,EAAA,KAAA,YACA,OAAA,IAAA,CAAA,EAAA,KAAA,YACA,qCAAA,QAAA,CAAA,eACA;gCACA,KAAA,YAAA,CAAA,qBAAA,IAAA,CAAA,EAAA;gCACA,KAAA,YAAA,CAAA,qBAAA,IAAA,CAAA,EAAA;4BACA;wBACA;wBAEA,IAAA,SAAA,QAAA,mCAAA,EAAA;4BACA,KAAA,YAAA,CAAA,YAAA,MAAA,OAAA;wBACA;oBACA;gBACA;QAEA;IACA;AACA;AAGA,MAAA,uCAAA;IAAA;IAAA;CAAA;AACA,MAAA,8BAAA;IAAA;IAAA;IAAA;IAAA;CAAA;AACA,MAAA,4CAAA;IAAA;IAAA;CAAA;AACA,MAAA,4BAAA;IAAA;IAAA;CAAA;AACA,MAAA,iCAAA;IAAA;IAAA;CAAA;AACA,MAAA,8BAAA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACA"}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 356, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/debug-build.ts"],"sourcesContent":["declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n"],"names":[],"mappings":";;;AAEA;;;;CAIA,GACO,MAAM,cAAc,OAAA,qBAAA,eAAA"}},
    {"offset": {"line": 365, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 369, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/express-v5/enums/AttributeNames.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum AttributeNames {\n  EXPRESS_TYPE = 'express.type',\n  EXPRESS_NAME = 'express.name',\n}\n"],"names":["AttributeNames"],"mappings":";;;AAAA;;;;;;;;;;;;;;CAcA,GACAA,QAAAA,cAAAA,GAAAA,KAAAA;AAAA,CAAA,SAAA,cAAA;IACE,MAAA,eAAe;IAAA,cAAA,CAAA,eAAA,GAAA;IACf,MAAA,eAAe;IAAA,cAAA,CAAA,eAAA,GAAA;AACjB,CAAA,EAAAA,QAAAA,cAAA,IAAA,CAAAA,QAAAA,cAAA,GAAA,CAAA,CAAA"}},
    {"offset": {"line": 393, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 397, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/express-v5/enums/ExpressLayerType.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum ExpressLayerType {\n  ROUTER = 'router',\n  MIDDLEWARE = 'middleware',\n  REQUEST_HANDLER = 'request_handler',\n}\n"],"names":["ExpressLayerType"],"mappings":";;;AAAA;;;;;;;;;;;;;;CAcA,GACAA,QAAAA,gBAAAA,GAAAA,KAAAA;AAAA,CAAA,SAAA,gBAAA;IACE,MAAA,SAAS;IAAA,gBAAA,CAAA,SAAA,GAAA;IACT,MAAA,aAAa;IAAA,gBAAA,CAAA,aAAA,GAAA;IACb,MAAA,kBAAkB;IAAA,gBAAA,CAAA,kBAAA,GAAA;AACpB,CAAA,EAAAA,QAAAA,gBAAA,IAAA,CAAAA,QAAAA,gBAAA,GAAA,CAAA,CAAA"}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 427, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/express-v5/internal-types.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\n\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Request } from 'express';\n\n/**\n * This symbol is used to mark express layer as being already instrumented\n * since its possible to use a given layer multiple times (ex: middlewares)\n */\nexport const kLayerPatched: unique symbol = Symbol('express-layer-patched');\n\n/**\n * This const define where on the `request` object the Instrumentation will mount the\n * current stack of express layer.\n *\n * It is necessary because express doesn't store the different layers\n * (ie: middleware, router etc) that it called to get to the current layer.\n * Given that, the only way to know the route of a given layer is to\n * store the path of where each previous layer has been mounted.\n *\n * ex: bodyParser > auth middleware > /users router > get /:id\n *  in this case the stack would be: [\"/users\", \"/:id\"]\n *\n * ex2: bodyParser > /api router > /v1 router > /users router > get /:id\n *  stack: [\"/api\", \"/v1\", \"/users\", \":id\"]\n *\n */\nexport const _LAYERS_STORE_PROPERTY = '__ot_middlewares';\n\nexport type PatchedRequest = {\n  [_LAYERS_STORE_PROPERTY]?: string[];\n} & Request;\nexport type PathParams = string | RegExp | Array<string | RegExp>;\n\n// https://github.com/expressjs/express/blob/main/lib/router/index.js#L53\nexport type ExpressRouter = {\n  stack: ExpressLayer[];\n};\n\n// https://github.com/expressjs/express/blob/main/lib/router/layer.js#L33\nexport type ExpressLayer = {\n  handle: Function & Record<string, any>;\n  [kLayerPatched]?: boolean;\n  name: string;\n  path: string;\n  route?: ExpressLayer;\n};\n"],"names":[],"mappings":";;;AAqBA;;;CAGA,SACa,gBAA+B,OAAO;AAEnD;;;;;;;;;;;;;;;CAeA,GACO,MAAM,yBAAyB"}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 456, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/express-v5/utils.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Attributes } from '@opentelemetry/api';\nimport { AttributeNames } from './enums/AttributeNames';\nimport { ExpressLayerType } from './enums/ExpressLayerType';\nimport type { ExpressLayer, PatchedRequest } from './internal-types';\nimport { _LAYERS_STORE_PROPERTY } from './internal-types';\nimport type { ExpressInstrumentationConfig, IgnoreMatcher, LayerPathSegment } from './types';\n\n/**\n * Store layers path in the request to be able to construct route later\n * @param request The request where\n * @param [value] the value to push into the array\n */\nexport const storeLayerPath = (request: PatchedRequest, value?: string): void => {\n  if (Array.isArray(request[_LAYERS_STORE_PROPERTY]) === false) {\n    Object.defineProperty(request, _LAYERS_STORE_PROPERTY, {\n      enumerable: false,\n      value: [],\n    });\n  }\n  if (value === undefined) return;\n  (request[_LAYERS_STORE_PROPERTY] as string[]).push(value);\n};\n\n/**\n * Recursively search the router path from layer stack\n * @param path The path to reconstruct\n * @param layer The layer to reconstruct from\n * @returns The reconstructed path\n */\nexport const getRouterPath = (path: string, layer: ExpressLayer): string => {\n  const stackLayer = layer.handle?.stack?.[0];\n\n  if (stackLayer?.route?.path) {\n    return `${path}${stackLayer.route.path}`;\n  }\n\n  if (stackLayer?.handle?.stack) {\n    return getRouterPath(path, stackLayer);\n  }\n\n  return path;\n};\n\n/**\n * Parse express layer context to retrieve a name and attributes.\n * @param route The route of the layer\n * @param layer Express layer\n * @param [layerPath] if present, the path on which the layer has been mounted\n */\nexport const getLayerMetadata = (\n  route: string,\n  layer: ExpressLayer,\n  layerPath?: string,\n): {\n  attributes: Attributes;\n  name: string;\n} => {\n  if (layer.name === 'router') {\n    const maybeRouterPath = getRouterPath('', layer);\n    const extractedRouterPath = maybeRouterPath ? maybeRouterPath : layerPath || route || '/';\n\n    return {\n      attributes: {\n        [AttributeNames.EXPRESS_NAME]: extractedRouterPath,\n        [AttributeNames.EXPRESS_TYPE]: ExpressLayerType.ROUTER,\n      },\n      name: `router - ${extractedRouterPath}`,\n    };\n  } else if (layer.name === 'bound dispatch' || layer.name === 'handle') {\n    return {\n      attributes: {\n        [AttributeNames.EXPRESS_NAME]: (route || layerPath) ?? 'request handler',\n        [AttributeNames.EXPRESS_TYPE]: ExpressLayerType.REQUEST_HANDLER,\n      },\n      name: `request handler${layer.path ? ` - ${route || layerPath}` : ''}`,\n    };\n  } else {\n    return {\n      attributes: {\n        [AttributeNames.EXPRESS_NAME]: layer.name,\n        [AttributeNames.EXPRESS_TYPE]: ExpressLayerType.MIDDLEWARE,\n      },\n      name: `middleware - ${layer.name}`,\n    };\n  }\n};\n\n/**\n * Check whether the given obj match pattern\n * @param constant e.g URL of request\n * @param obj obj to inspect\n * @param pattern Match pattern\n */\nconst satisfiesPattern = (constant: string, pattern: IgnoreMatcher): boolean => {\n  if (typeof pattern === 'string') {\n    return pattern === constant;\n  } else if (pattern instanceof RegExp) {\n    return pattern.test(constant);\n  } else if (typeof pattern === 'function') {\n    return pattern(constant);\n  } else {\n    throw new TypeError('Pattern is in unsupported datatype');\n  }\n};\n\n/**\n * Check whether the given request is ignored by configuration\n * It will not re-throw exceptions from `list` provided by the client\n * @param constant e.g URL of request\n * @param [list] List of ignore patterns\n * @param [onException] callback for doing something when an exception has\n *     occurred\n */\nexport const isLayerIgnored = (\n  name: string,\n  type: ExpressLayerType,\n  config?: ExpressInstrumentationConfig,\n): boolean => {\n  if (Array.isArray(config?.ignoreLayersType) && config?.ignoreLayersType?.includes(type)) {\n    return true;\n  }\n  if (Array.isArray(config?.ignoreLayers) === false) return false;\n  try {\n    for (const pattern of config!.ignoreLayers!) {\n      if (satisfiesPattern(name, pattern)) {\n        return true;\n      }\n    }\n  } catch (e) {\n    /* catch block */\n  }\n\n  return false;\n};\n\n/**\n * Converts a user-provided error value into an error and error message pair\n *\n * @param error - User-provided error value\n * @returns Both an Error or string representation of the value and an error message\n */\nexport const asErrorAndMessage = (error: unknown): [error: string | Error, message: string] =>\n  error instanceof Error ? [error, error.message] : [String(error), String(error)];\n\n/**\n * Extracts the layer path from the route arguments\n *\n * @param args - Arguments of the route\n * @returns The layer path\n */\nexport const getLayerPath = (args: [LayerPathSegment | LayerPathSegment[], ...unknown[]]): string | undefined => {\n  const firstArg = args[0];\n\n  if (Array.isArray(firstArg)) {\n    return firstArg.map(arg => extractLayerPathSegment(arg) || '').join(',');\n  }\n\n  return extractLayerPathSegment(firstArg);\n};\n\nconst extractLayerPathSegment = (arg: LayerPathSegment) => {\n  if (typeof arg === 'string') {\n    return arg;\n  }\n\n  if (arg instanceof RegExp || typeof arg === 'number') {\n    return arg.toString();\n  }\n\n  return;\n};\n"],"names":["_LAYERS_STORE_PROPERTY","AttributeNames","ExpressLayerType"],"mappings":"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"}},
    {"offset": {"line": 602, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 606, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/express-v5/instrumentation.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/member-ordering */\n/* eslint-disable guard-for-in */\n/* eslint-disable @typescript-eslint/ban-types */\n/* eslint-disable prefer-rest-params */\n/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable jsdoc/require-jsdoc */\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/* eslint-disable @typescript-eslint/explicit-member-accessibility */\n\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Attributes } from '@opentelemetry/api';\nimport { context, diag, SpanStatusCode, trace } from '@opentelemetry/api';\nimport { getRPCMetadata, RPCType } from '@opentelemetry/core';\nimport {\n  InstrumentationBase,\n  InstrumentationNodeModuleDefinition,\n  isWrapped,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport { SEMATTRS_HTTP_ROUTE } from '@opentelemetry/semantic-conventions';\nimport type * as express from 'express';\nimport { AttributeNames } from './enums/AttributeNames';\nimport { ExpressLayerType } from './enums/ExpressLayerType';\nimport type { ExpressLayer, ExpressRouter, PatchedRequest } from './internal-types';\nimport { _LAYERS_STORE_PROPERTY, kLayerPatched } from './internal-types';\nimport type { ExpressInstrumentationConfig, ExpressRequestInfo } from './types';\nimport { asErrorAndMessage, getLayerMetadata, getLayerPath, isLayerIgnored, storeLayerPath } from './utils';\n\nexport const PACKAGE_VERSION = '0.1.0';\nexport const PACKAGE_NAME = '@sentry/instrumentation-express-v5';\n\n/** Express instrumentation for OpenTelemetry */\nexport class ExpressInstrumentationV5 extends InstrumentationBase<ExpressInstrumentationConfig> {\n  constructor(config: ExpressInstrumentationConfig = {}) {\n    super(PACKAGE_NAME, PACKAGE_VERSION, config);\n  }\n\n  init() {\n    return [\n      new InstrumentationNodeModuleDefinition(\n        'express',\n        ['>=5.0.0'],\n        moduleExports => this._setup(moduleExports),\n        moduleExports => this._tearDown(moduleExports),\n      ),\n    ];\n  }\n\n  private _setup(moduleExports: any) {\n    const routerProto = moduleExports.Router.prototype;\n    // patch express.Router.route\n    if (isWrapped(routerProto.route)) {\n      this._unwrap(routerProto, 'route');\n    }\n    this._wrap(routerProto, 'route', this._getRoutePatch());\n    // patch express.Router.use\n    if (isWrapped(routerProto.use)) {\n      this._unwrap(routerProto, 'use');\n    }\n    this._wrap(routerProto, 'use', this._getRouterUsePatch() as any);\n    // patch express.Application.use\n    if (isWrapped(moduleExports.application.use)) {\n      this._unwrap(moduleExports.application, 'use');\n    }\n    this._wrap(moduleExports.application, 'use', this._getAppUsePatch() as any);\n    return moduleExports;\n  }\n\n  private _tearDown(moduleExports: any) {\n    if (moduleExports === undefined) return;\n    const routerProto = moduleExports.Router.prototype;\n    this._unwrap(routerProto, 'route');\n    this._unwrap(routerProto, 'use');\n    this._unwrap(moduleExports.application, 'use');\n  }\n\n  /**\n   * Get the patch for Router.route function\n   */\n  private _getRoutePatch() {\n    const instrumentation = this;\n    return function (original: express.Router['route']) {\n      return function route_trace(this: ExpressRouter, ...args: Parameters<typeof original>) {\n        const route = original.apply(this, args);\n        const layer = this.stack[this.stack.length - 1] as ExpressLayer;\n        instrumentation._applyPatch(layer, getLayerPath(args));\n        return route;\n      };\n    };\n  }\n\n  /**\n   * Get the patch for Router.use function\n   */\n  private _getRouterUsePatch() {\n    const instrumentation = this;\n    return function (original: express.Router['use']) {\n      return function use(this: express.Application, ...args: Parameters<typeof original>) {\n        const route = original.apply(this, args);\n        const layer = this.stack[this.stack.length - 1] as ExpressLayer;\n        instrumentation._applyPatch(layer, getLayerPath(args));\n        return route;\n      };\n    };\n  }\n\n  /**\n   * Get the patch for Application.use function\n   */\n  private _getAppUsePatch() {\n    const instrumentation = this;\n    return function (original: express.Application['use']) {\n      return function use(\n        // In express 5.x the router is stored in `router` whereas in 4.x it's stored in `_router`\n        this: { _router?: ExpressRouter; router?: ExpressRouter },\n        ...args: Parameters<typeof original>\n      ) {\n        // if we access app.router in express 4.x we trigger an assertion error\n        // This property existed in v3, was removed in v4 and then re-added in v5\n        const router = this.router;\n        const route = original.apply(this, args);\n        if (router) {\n          const layer = router.stack[router.stack.length - 1] as ExpressLayer;\n          instrumentation._applyPatch(layer, getLayerPath(args));\n        }\n        return route;\n      };\n    };\n  }\n\n  /** Patch each express layer to create span and propagate context */\n  private _applyPatch(this: ExpressInstrumentationV5, layer: ExpressLayer, layerPath?: string) {\n    const instrumentation = this;\n    // avoid patching multiple times the same layer\n    if (layer[kLayerPatched] === true) return;\n    layer[kLayerPatched] = true;\n\n    this._wrap(layer, 'handle', original => {\n      // TODO: instrument error handlers\n      if (original.length === 4) return original;\n\n      const patched = function (this: ExpressLayer, req: PatchedRequest, res: express.Response) {\n        storeLayerPath(req, layerPath);\n        const route = (req[_LAYERS_STORE_PROPERTY] as string[])\n          .filter(path => path !== '/' && path !== '/*')\n          .join('')\n          // remove duplicate slashes to normalize route\n          .replace(/\\/{2,}/g, '/');\n\n        const actualRoute = route.length > 0 ? route : undefined;\n\n        const attributes: Attributes = {\n          // eslint-disable-next-line deprecation/deprecation\n          [SEMATTRS_HTTP_ROUTE]: actualRoute,\n        };\n        const metadata = getLayerMetadata(route, layer, layerPath);\n        const type = metadata.attributes[AttributeNames.EXPRESS_TYPE] as ExpressLayerType;\n\n        const rpcMetadata = getRPCMetadata(context.active());\n        if (rpcMetadata?.type === RPCType.HTTP) {\n          rpcMetadata.route = actualRoute;\n        }\n\n        // verify against the config if the layer should be ignored\n        if (isLayerIgnored(metadata.name, type, instrumentation.getConfig())) {\n          if (type === ExpressLayerType.MIDDLEWARE) {\n            (req[_LAYERS_STORE_PROPERTY] as string[]).pop();\n          }\n          return original.apply(this, arguments);\n        }\n\n        if (trace.getSpan(context.active()) === undefined) {\n          return original.apply(this, arguments);\n        }\n\n        const spanName = instrumentation._getSpanName(\n          {\n            request: req,\n            layerType: type,\n            route,\n          },\n          metadata.name,\n        );\n        const span = instrumentation.tracer.startSpan(spanName, {\n          attributes: Object.assign(attributes, metadata.attributes),\n        });\n\n        const { requestHook } = instrumentation.getConfig();\n        if (requestHook) {\n          safeExecuteInTheMiddle(\n            () =>\n              requestHook(span, {\n                request: req,\n                layerType: type,\n                route,\n              }),\n            e => {\n              if (e) {\n                diag.error('express instrumentation: request hook failed', e);\n              }\n            },\n            true,\n          );\n        }\n\n        let spanHasEnded = false;\n        if (metadata.attributes[AttributeNames.EXPRESS_TYPE] !== ExpressLayerType.MIDDLEWARE) {\n          span.end();\n          spanHasEnded = true;\n        }\n        // listener for response.on('finish')\n        const onResponseFinish = () => {\n          if (spanHasEnded === false) {\n            spanHasEnded = true;\n            span.end();\n          }\n        };\n\n        // verify we have a callback\n        const args = Array.from(arguments);\n        const callbackIdx = args.findIndex(arg => typeof arg === 'function');\n        if (callbackIdx >= 0) {\n          arguments[callbackIdx] = function () {\n            // express considers anything but an empty value, \"route\" or \"router\"\n            // passed to its callback to be an error\n            const maybeError = arguments[0];\n            const isError = ![undefined, null, 'route', 'router'].includes(maybeError);\n            if (!spanHasEnded && isError) {\n              const [error, message] = asErrorAndMessage(maybeError);\n              span.recordException(error);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message,\n              });\n            }\n\n            if (spanHasEnded === false) {\n              spanHasEnded = true;\n              req.res?.removeListener('finish', onResponseFinish);\n              span.end();\n            }\n            if (!(req.route && isError)) {\n              (req[_LAYERS_STORE_PROPERTY] as string[]).pop();\n            }\n            const callback = args[callbackIdx] as Function;\n            return callback.apply(this, arguments);\n          };\n        }\n\n        try {\n          return original.apply(this, arguments);\n        } catch (anyError) {\n          const [error, message] = asErrorAndMessage(anyError);\n          span.recordException(error);\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message,\n          });\n          throw anyError;\n        } finally {\n          /**\n           * At this point if the callback wasn't called, that means either the\n           * layer is asynchronous (so it will call the callback later on) or that\n           * the layer directly end the http response, so we'll hook into the \"finish\"\n           * event to handle the later case.\n           */\n          if (!spanHasEnded) {\n            res.once('finish', onResponseFinish);\n          }\n        }\n      };\n\n      // `handle` isn't just a regular function in some cases. It also contains\n      // some properties holding metadata and state so we need to proxy them\n      // through through patched function\n      // ref: https://github.com/open-telemetry/opentelemetry-js-contrib/issues/1950\n      // Also some apps/libs do their own patching before OTEL and have these properties\n      // in the proptotype. So we use a `for...in` loop to get own properties and also\n      // any enumerable prop in the prototype chain\n      // ref: https://github.com/open-telemetry/opentelemetry-js-contrib/issues/2271\n      for (const key in original) {\n        Object.defineProperty(patched, key, {\n          get() {\n            return original[key];\n          },\n          set(value) {\n            original[key] = value;\n          },\n        });\n      }\n      return patched;\n    });\n  }\n\n  _getSpanName(info: ExpressRequestInfo, defaultName: string) {\n    const { spanNameHook } = this.getConfig();\n\n    if (!(spanNameHook instanceof Function)) {\n      return defaultName;\n    }\n\n    try {\n      return spanNameHook(info, defaultName) ?? defaultName;\n    } catch (err) {\n      diag.error('express instrumentation: error calling span name rewrite hook', err);\n      return defaultName;\n    }\n  }\n}\n"],"names":["InstrumentationBase","InstrumentationNodeModuleDefinition","isWrapped","getLayerPath","instrumentation","kLayerPatched","storeLayerPath","_LAYERS_STORE_PROPERTY","SEMATTRS_HTTP_ROUTE","getLayerMetadata","AttributeNames","getRPCMetadata","context","RPCType","isLayerIgnored","ExpressLayerType","trace","safeExecuteInTheMiddle","diag","asErrorAndMessage","SpanStatusCode"],"mappings":"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"}},
    {"offset": {"line": 858, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 862, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/express.ts"],"sourcesContent":["import type * as http from 'node:http';\nimport type { Span } from '@opentelemetry/api';\nimport type { ExpressRequestInfo } from '@opentelemetry/instrumentation-express';\nimport { ExpressInstrumentation } from '@opentelemetry/instrumentation-express';\nimport type { IntegrationFn } from '@sentry/core';\nimport {\n  captureException,\n  defineIntegration,\n  getDefaultIsolationScope,\n  getIsolationScope,\n  httpRequestToRequestData,\n  logger,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  spanToJSON,\n} from '@sentry/core';\nimport { addOriginToSpan, ensureIsWrapped, generateInstrumentOnce } from '@sentry/node-core';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport { ExpressInstrumentationV5 } from './express-v5/instrumentation';\n\nconst INTEGRATION_NAME = 'Express';\nconst INTEGRATION_NAME_V5 = 'Express-V5';\n\nfunction requestHook(span: Span): void {\n  addOriginToSpan(span, 'auto.http.otel.express');\n\n  const attributes = spanToJSON(span).data;\n  // this is one of: middleware, request_handler, router\n  const type = attributes['express.type'];\n\n  if (type) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, `${type}.express`);\n  }\n\n  // Also update the name, we don't need to \"middleware - \" prefix\n  const name = attributes['express.name'];\n  if (typeof name === 'string') {\n    span.updateName(name);\n  }\n}\n\nfunction spanNameHook(info: ExpressRequestInfo<unknown>, defaultName: string): string {\n  if (getIsolationScope() === getDefaultIsolationScope()) {\n    DEBUG_BUILD && logger.warn('Isolation scope is still default isolation scope - skipping setting transactionName');\n    return defaultName;\n  }\n  if (info.layerType === 'request_handler') {\n    // type cast b/c Otel unfortunately types info.request as any :(\n    const req = info.request as { method?: string };\n    const method = req.method ? req.method.toUpperCase() : 'GET';\n    getIsolationScope().setTransactionName(`${method} ${info.route}`);\n  }\n  return defaultName;\n}\n\nexport const instrumentExpress = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  () =>\n    new ExpressInstrumentation({\n      requestHook: span => requestHook(span),\n      spanNameHook: (info, defaultName) => spanNameHook(info, defaultName),\n    }),\n);\n\nexport const instrumentExpressV5 = generateInstrumentOnce(\n  INTEGRATION_NAME_V5,\n  () =>\n    new ExpressInstrumentationV5({\n      requestHook: span => requestHook(span),\n      spanNameHook: (info, defaultName) => spanNameHook(info, defaultName),\n    }),\n);\n\nconst _expressIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentExpress();\n      instrumentExpressV5();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for [Express](https://expressjs.com/).\n *\n * If you also want to capture errors, you need to call `setupExpressErrorHandler(app)` after you set up your Express server.\n *\n * For more information, see the [express documentation](https://docs.sentry.io/platforms/javascript/guides/express/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *   integrations: [Sentry.expressIntegration()],\n * })\n * ```\n */\nexport const expressIntegration = defineIntegration(_expressIntegration);\n\ninterface MiddlewareError extends Error {\n  status?: number | string;\n  statusCode?: number | string;\n  status_code?: number | string;\n  output?: {\n    statusCode?: number | string;\n  };\n}\n\ntype ExpressMiddleware = (req: http.IncomingMessage, res: http.ServerResponse, next: () => void) => void;\n\ntype ExpressErrorMiddleware = (\n  error: MiddlewareError,\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  next: (error: MiddlewareError) => void,\n) => void;\n\ninterface ExpressHandlerOptions {\n  /**\n   * Callback method deciding whether error should be captured and sent to Sentry\n   * @param error Captured middleware error\n   */\n  shouldHandleError?(this: void, error: MiddlewareError): boolean;\n}\n\n/**\n * An Express-compatible error handler.\n */\nexport function expressErrorHandler(options?: ExpressHandlerOptions): ExpressErrorMiddleware {\n  return function sentryErrorMiddleware(\n    error: MiddlewareError,\n    request: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error: MiddlewareError) => void,\n  ): void {\n    const normalizedRequest = httpRequestToRequestData(request);\n    // Ensure we use the express-enhanced request here, instead of the plain HTTP one\n    // When an error happens, the `expressRequestHandler` middleware does not run, so we set it here too\n    getIsolationScope().setSDKProcessingMetadata({ normalizedRequest });\n\n    const shouldHandleError = options?.shouldHandleError || defaultShouldHandleError;\n\n    if (shouldHandleError(error)) {\n      const eventId = captureException(error, { mechanism: { type: 'middleware', handled: false } });\n      (res as { sentry?: string }).sentry = eventId;\n    }\n\n    next(error);\n  };\n}\n\nfunction expressRequestHandler(): ExpressMiddleware {\n  return function sentryRequestMiddleware(\n    request: http.IncomingMessage,\n    _res: http.ServerResponse,\n    next: () => void,\n  ): void {\n    const normalizedRequest = httpRequestToRequestData(request);\n    // Ensure we use the express-enhanced request here, instead of the plain HTTP one\n    getIsolationScope().setSDKProcessingMetadata({ normalizedRequest });\n\n    next();\n  };\n}\n\n/**\n * Add an Express error handler to capture errors to Sentry.\n *\n * The error handler must be before any other middleware and after all controllers.\n *\n * @param app The Express instances\n * @param options {ExpressHandlerOptions} Configuration options for the handler\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n * const express = require(\"express\");\n *\n * const app = express();\n *\n * // Add your routes, etc.\n *\n * // Add this after all routes,\n * // but before any and other error-handling middlewares are defined\n * Sentry.setupExpressErrorHandler(app);\n *\n * app.listen(3000);\n * ```\n */\nexport function setupExpressErrorHandler(\n  app: { use: (middleware: ExpressMiddleware | ExpressErrorMiddleware) => unknown },\n  options?: ExpressHandlerOptions,\n): void {\n  app.use(expressRequestHandler());\n  app.use(expressErrorHandler(options));\n  ensureIsWrapped(app.use, 'express');\n}\n\nfunction getStatusCodeFromResponse(error: MiddlewareError): number {\n  const statusCode = error.status || error.statusCode || error.status_code || error.output?.statusCode;\n  return statusCode ? parseInt(statusCode as string, 10) : 500;\n}\n\n/** Returns true if response code is internal server error */\nfunction defaultShouldHandleError(error: MiddlewareError): boolean {\n  const status = getStatusCodeFromResponse(error);\n  return status >= 500;\n}\n"],"names":["addOriginToSpan","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_OP","getIsolationScope","getDefaultIsolationScope","DEBUG_BUILD","logger","generateInstrumentOnce","ExpressInstrumentation","ExpressInstrumentationV5","defineIntegration","httpRequestToRequestData","captureException","ensureIsWrapped"],"mappings":";;;;;;;;AAmBA,MAAM,mBAAmB;AACzB,MAAM,sBAAsB;AAE5B,SAAS,YAAY,IAAI;IACvBA,SAAAA,eAAe,CAAC,MAAM;IAEtB,MAAM,aAAaC,KAAAA,UAAU,CAAC,MAAM,IAAI;IAC1C,sDAAA;IACE,MAAM,OAAO,UAAU,CAAC,eAAe;IAEvC,IAAI,MAAM;QACR,KAAK,YAAY,CAACC,KAAAA,4BAA4B,EAAE,CAAC,EAAA,KAAA,QAAA,CAAA;IACA;IAEA,gEAAA;IACA,MAAA,OAAA,UAAA,CAAA,eAAA;IACA,IAAA,OAAA,SAAA,UAAA;QACA,KAAA,UAAA,CAAA;IACA;AACA;AAEA,SAAA,aAAA,IAAA,EAAA,WAAA;IACA,IAAAC,KAAAA,iBAAA,OAAAC,KAAAA,wBAAA,IAAA;QACAC,WAAAA,WAAA,IAAAC,KAAAA,MAAA,CAAA,IAAA,CAAA;QACA,OAAA;IACA;IACA,IAAA,KAAA,SAAA,KAAA,mBAAA;QACA,gEAAA;QACA,MAAA,MAAA,KAAA,OAAA;QACA,MAAA,SAAA,IAAA,MAAA,GAAA,IAAA,MAAA,CAAA,WAAA,KAAA;QACAH,KAAAA,iBAAA,GAAA,kBAAA,CAAA,CAAA,EAAA,OAAA,CAAA,EAAA,KAAA,KAAA,CAAA,CAAA;IACA;IACA,OAAA;AACA;AAEA,MAAA,oBAAAI,SAAAA,sBAAA,CACA,kBACA,IACA,IAAAC,uBAAAA,sBAAA,CAAA;QACA,aAAA,CAAA,OAAA,YAAA;QACA,cAAA,CAAA,MAAA,cAAA,aAAA,MAAA;IACA;AAGA,MAAA,sBAAAD,SAAAA,sBAAA,CACA,qBACA,IACA,IAAAE,gBAAAA,wBAAA,CAAA;QACA,aAAA,CAAA,OAAA,YAAA;QACA,cAAA,CAAA,MAAA,cAAA,aAAA,MAAA;IACA;AAGA,MAAA,sBAAA;IACA,OAAA;QACA,MAAA;QACA;YACA;YACA;QACA;IACA;AACA;AAEA;;;;;;;;;;;;;;;CAeA,GACA,MAAA,qBAAAC,KAAAA,iBAAA,CAAA;AA4BA;;CAEA,GACA,SAAA,oBAAA,OAAA;IACA,OAAA,SAAA,sBACA,KAAA,EACA,OAAA,EACA,GAAA,EACA,IAAA;QAEA,MAAA,oBAAAC,KAAAA,wBAAA,CAAA;QACA,iFAAA;QACA,oGAAA;QACAR,KAAAA,iBAAA,GAAA,wBAAA,CAAA;YAAA;QAAA;QAEA,MAAA,oBAAA,SAAA,qBAAA;QAEA,IAAA,kBAAA,QAAA;YACA,MAAA,UAAAS,KAAAA,gBAAA,CAAA,OAAA;gBAAA,WAAA;oBAAA,MAAA;oBAAA,SAAA;gBAAA;YAAA;YACA,IAAA,MAAA,GAAA;QACA;QAEA,KAAA;IACA;AACA;AAEA,SAAA;IACA,OAAA,SAAA,wBACA,OAAA,EACA,IAAA,EACA,IAAA;QAEA,MAAA,oBAAAD,KAAAA,wBAAA,CAAA;QACA,iFAAA;QACAR,KAAAA,iBAAA,GAAA,wBAAA,CAAA;YAAA;QAAA;QAEA;IACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;CAuBA,GACA,SAAA,yBACA,GAAA,EACA,OAAA;IAEA,IAAA,GAAA,CAAA;IACA,IAAA,GAAA,CAAA,oBAAA;IACAU,SAAAA,eAAA,CAAA,IAAA,GAAA,EAAA;AACA;AAEA,SAAA,0BAAA,KAAA;IACA,MAAA,aAAA,MAAA,MAAA,IAAA,MAAA,UAAA,IAAA,MAAA,WAAA,IAAA,MAAA,MAAA,EAAA;IACA,OAAA,aAAA,SAAA,YAAA,MAAA;AACA;AAEA,2DAAA,GACA,SAAA,yBAAA,KAAA;IACA,MAAA,SAAA,0BAAA;IACA,OAAA,UAAA;AACA"}},
    {"offset": {"line": 1006, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1010, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/fastify/fastify-otel/index.js"],"sourcesContent":["/*\nVendored in and modified from @fastify/otel version 0.8.0\nhttps://github.com/fastify/otel/releases/tag/v0.8.0\n\nTried not to modify the original code too much keeping it as a JavaScript CJS module to make it easier to update when required\n\nModifications include:\n- Removed reading of package.json to get the version and package name\n\nMIT License\n\nCopyright (c) 2024 Fastify\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n/* eslint-disable jsdoc/require-jsdoc */\n/* eslint-disable max-lines */\n/* eslint-disable no-param-reassign */\nimport dc from 'node:diagnostics_channel';\nimport { context, diag, propagation, SpanStatusCode, trace } from '@opentelemetry/api';\nimport { getRPCMetadata, RPCType } from '@opentelemetry/core';\nimport { InstrumentationBase } from '@opentelemetry/instrumentation';\nimport {\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_HTTP_RESPONSE_STATUS_CODE,\n  ATTR_HTTP_ROUTE,\n  ATTR_SERVICE_NAME,\n} from '@opentelemetry/semantic-conventions';\nimport * as minimatch from 'minimatch';\n\n// SENTRY VENDOR NOTE\n// Instead of using the package.json file, we hard code the package name and version here.\nconst PACKAGE_NAME = '@fastify/otel';\nconst PACKAGE_VERSION = '0.8.0';\n\n// Constants\nconst SUPPORTED_VERSIONS = '>=4.0.0 <6';\nconst FASTIFY_HOOKS = [\n  'onRequest',\n  'preParsing',\n  'preValidation',\n  'preHandler',\n  'preSerialization',\n  'onSend',\n  'onResponse',\n  'onError',\n];\nconst ATTRIBUTE_NAMES = {\n  HOOK_NAME: 'hook.name',\n  FASTIFY_TYPE: 'fastify.type',\n  HOOK_CALLBACK_NAME: 'hook.callback.name',\n  ROOT: 'fastify.root',\n};\nconst HOOK_TYPES = {\n  ROUTE: 'route-hook',\n  INSTANCE: 'hook',\n  HANDLER: 'request-handler',\n};\nconst ANONYMOUS_FUNCTION_NAME = 'anonymous';\n\n// Symbols\nconst kInstrumentation = Symbol('fastify otel instance');\nconst kRequestSpan = Symbol('fastify otel request spans');\nconst kRequestContext = Symbol('fastify otel request context');\nconst kAddHookOriginal = Symbol('fastify otel addhook original');\nconst kSetNotFoundOriginal = Symbol('fastify otel setnotfound original');\nconst kIgnorePaths = Symbol('fastify otel ignore path');\n\nexport class FastifyOtelInstrumentation extends InstrumentationBase {\n  constructor(config) {\n    super(PACKAGE_NAME, PACKAGE_VERSION, config);\n    this.servername = config?.servername ?? process.env.OTEL_SERVICE_NAME ?? 'fastify';\n    this[kIgnorePaths] = null;\n    this._logger = diag.createComponentLogger({ namespace: PACKAGE_NAME });\n\n    if (config?.ignorePaths != null || process.env.OTEL_FASTIFY_IGNORE_PATHS != null) {\n      const ignorePaths = config?.ignorePaths ?? process.env.OTEL_FASTIFY_IGNORE_PATHS;\n\n      if ((typeof ignorePaths !== 'string' || ignorePaths.length === 0) && typeof ignorePaths !== 'function') {\n        throw new TypeError('ignorePaths must be a string or a function');\n      }\n\n      const globMatcher = minimatch.minimatch;\n\n      this[kIgnorePaths] = routeOptions => {\n        if (typeof ignorePaths === 'function') {\n          return ignorePaths(routeOptions);\n        } else {\n          return globMatcher(routeOptions.url, ignorePaths);\n        }\n      };\n    }\n  }\n\n  enable() {\n    if (this._handleInitialization === undefined && this.getConfig().registerOnInitialization) {\n      const FastifyInstrumentationPlugin = this.plugin();\n      this._handleInitialization = message => {\n        message.fastify.register(FastifyInstrumentationPlugin);\n      };\n      dc.subscribe('fastify.initialization', this._handleInitialization);\n    }\n    return super.enable();\n  }\n\n  disable() {\n    if (this._handleInitialization) {\n      dc.unsubscribe('fastify.initialization', this._handleInitialization);\n      this._handleInitialization = undefined;\n    }\n    return super.disable();\n  }\n\n  // We do not do patching in this instrumentation\n  init() {\n    return [];\n  }\n\n  plugin() {\n    const instrumentation = this;\n\n    FastifyInstrumentationPlugin[Symbol.for('skip-override')] = true;\n    FastifyInstrumentationPlugin[Symbol.for('fastify.display-name')] = '@fastify/otel';\n    FastifyInstrumentationPlugin[Symbol.for('plugin-meta')] = {\n      fastify: SUPPORTED_VERSIONS,\n      name: '@fastify/otel',\n    };\n\n    return FastifyInstrumentationPlugin;\n\n    function FastifyInstrumentationPlugin(instance, opts, done) {\n      instance.decorate(kInstrumentation, instrumentation);\n      // addHook and notfoundHandler are essentially inherited from the prototype\n      // what is important is to bound it to the right instance\n      instance.decorate(kAddHookOriginal, instance.addHook);\n      instance.decorate(kSetNotFoundOriginal, instance.setNotFoundHandler);\n      instance.decorateRequest('opentelemetry', function openetelemetry() {\n        const ctx = this[kRequestContext];\n        const span = this[kRequestSpan];\n        return {\n          span,\n          tracer: instrumentation.tracer,\n          context: ctx,\n          inject: (carrier, setter) => {\n            return propagation.inject(ctx, carrier, setter);\n          },\n          extract: (carrier, getter) => {\n            return propagation.extract(ctx, carrier, getter);\n          },\n        };\n      });\n      instance.decorateRequest(kRequestSpan, null);\n      instance.decorateRequest(kRequestContext, null);\n\n      instance.addHook('onRoute', function (routeOptions) {\n        if (instrumentation[kIgnorePaths]?.(routeOptions) === true) {\n          instrumentation._logger.debug(\n            `Ignoring route instrumentation ${routeOptions.method} ${routeOptions.url} because it matches the ignore path`,\n          );\n          return;\n        }\n\n        for (const hook of FASTIFY_HOOKS) {\n          if (routeOptions[hook] != null) {\n            const handlerLike = routeOptions[hook];\n\n            if (typeof handlerLike === 'function') {\n              routeOptions[hook] = handlerWrapper(handlerLike, {\n                [ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,\n                [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - route -> ${hook}`,\n                [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.ROUTE,\n                [ATTR_HTTP_ROUTE]: routeOptions.url,\n                [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]:\n                  handlerLike.name?.length > 0 ? handlerLike.name : ANONYMOUS_FUNCTION_NAME /* c8 ignore next */,\n              });\n            } else if (Array.isArray(handlerLike)) {\n              const wrappedHandlers = [];\n\n              for (const handler of handlerLike) {\n                wrappedHandlers.push(\n                  handlerWrapper(handler, {\n                    [ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,\n                    [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - route -> ${hook}`,\n                    [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.ROUTE,\n                    [ATTR_HTTP_ROUTE]: routeOptions.url,\n                    [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]:\n                      handler.name?.length > 0 ? handler.name : ANONYMOUS_FUNCTION_NAME,\n                  }),\n                );\n              }\n\n              routeOptions[hook] = wrappedHandlers;\n            }\n          }\n        }\n\n        // We always want to add the onSend hook to the route to be executed last\n        if (routeOptions.onSend != null) {\n          routeOptions.onSend = Array.isArray(routeOptions.onSend)\n            ? [...routeOptions.onSend, onSendHook]\n            : [routeOptions.onSend, onSendHook];\n        } else {\n          routeOptions.onSend = onSendHook;\n        }\n\n        // We always want to add the onError hook to the route to be executed last\n        if (routeOptions.onError != null) {\n          routeOptions.onError = Array.isArray(routeOptions.onError)\n            ? [...routeOptions.onError, onErrorHook]\n            : [routeOptions.onError, onErrorHook];\n        } else {\n          routeOptions.onError = onErrorHook;\n        }\n\n        routeOptions.handler = handlerWrapper(routeOptions.handler, {\n          [ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,\n          [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - route-handler`,\n          [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.HANDLER,\n          [ATTR_HTTP_ROUTE]: routeOptions.url,\n          [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]:\n            routeOptions.handler.name.length > 0 ? routeOptions.handler.name : ANONYMOUS_FUNCTION_NAME,\n        });\n      });\n\n      instance.addHook('onRequest', function (request, _reply, hookDone) {\n        if (this[kInstrumentation].isEnabled() === false) {\n          return hookDone();\n        } else if (\n          this[kInstrumentation][kIgnorePaths]?.({\n            url: request.url,\n            method: request.method,\n          }) === true\n        ) {\n          this[kInstrumentation]._logger.debug(\n            `Ignoring request ${request.method} ${request.url} because it matches the ignore path`,\n          );\n          return hookDone();\n        }\n\n        let ctx = context.active();\n\n        if (trace.getSpan(ctx) == null) {\n          ctx = propagation.extract(ctx, request.headers);\n        }\n\n        const rpcMetadata = getRPCMetadata(ctx);\n\n        if (request.routeOptions.url != null && rpcMetadata?.type === RPCType.HTTP) {\n          rpcMetadata.route = request.routeOptions.url;\n        }\n\n        /** @type {import('@opentelemetry/api').Span} */\n        const span = this[kInstrumentation].tracer.startSpan(\n          'request',\n          {\n            attributes: {\n              [ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,\n              [ATTRIBUTE_NAMES.ROOT]: '@fastify/otel',\n              [ATTR_HTTP_ROUTE]: request.url,\n              [ATTR_HTTP_REQUEST_METHOD]: request.method,\n            },\n          },\n          ctx,\n        );\n\n        request[kRequestContext] = trace.setSpan(ctx, span);\n        request[kRequestSpan] = span;\n\n        context.with(request[kRequestContext], () => {\n          hookDone();\n        });\n      });\n\n      // onResponse is the last hook to be executed, only added for 404 handlers\n      instance.addHook('onResponse', function (request, reply, hookDone) {\n        const span = request[kRequestSpan];\n\n        if (span != null) {\n          span.setStatus({\n            code: SpanStatusCode.OK,\n            message: 'OK',\n          });\n          span.setAttributes({\n            [ATTR_HTTP_RESPONSE_STATUS_CODE]: 404,\n          });\n          span.end();\n        }\n\n        request[kRequestSpan] = null;\n\n        hookDone();\n      });\n\n      instance.addHook = addHookPatched;\n      instance.setNotFoundHandler = setNotFoundHandlerPatched;\n\n      done();\n\n      function onSendHook(request, reply, payload, hookDone) {\n        /** @type {import('@opentelemetry/api').Span} */\n        const span = request[kRequestSpan];\n\n        if (span != null) {\n          if (reply.statusCode < 500) {\n            span.setStatus({\n              code: SpanStatusCode.OK,\n              message: 'OK',\n            });\n          }\n\n          span.setAttributes({\n            [ATTR_HTTP_RESPONSE_STATUS_CODE]: reply.statusCode,\n          });\n          span.end();\n        }\n\n        request[kRequestSpan] = null;\n\n        hookDone(null, payload);\n      }\n\n      function onErrorHook(request, reply, error, hookDone) {\n        /** @type {Span} */\n        const span = request[kRequestSpan];\n\n        if (span != null) {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: error.message,\n          });\n          span.recordException(error);\n        }\n\n        hookDone();\n      }\n\n      function addHookPatched(name, hook) {\n        const addHookOriginal = this[kAddHookOriginal];\n\n        if (FASTIFY_HOOKS.includes(name)) {\n          return addHookOriginal.call(\n            this,\n            name,\n            handlerWrapper(hook, {\n              [ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,\n              [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - ${name}`,\n              [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.INSTANCE,\n              [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]:\n                hook.name?.length > 0 ? hook.name : ANONYMOUS_FUNCTION_NAME /* c8 ignore next */,\n            }),\n          );\n        } else {\n          return addHookOriginal.call(this, name, hook);\n        }\n      }\n\n      function setNotFoundHandlerPatched(hooks, handler) {\n        const setNotFoundHandlerOriginal = this[kSetNotFoundOriginal];\n        if (typeof hooks === 'function') {\n          handler = handlerWrapper(hooks, {\n            [ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,\n            [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - not-found-handler`,\n            [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.INSTANCE,\n            [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]:\n              hooks.name?.length > 0 ? hooks.name : ANONYMOUS_FUNCTION_NAME /* c8 ignore next */,\n          });\n          setNotFoundHandlerOriginal.call(this, handler);\n        } else {\n          if (hooks.preValidation != null) {\n            hooks.preValidation = handlerWrapper(hooks.preValidation, {\n              [ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,\n              [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - not-found-handler - preValidation`,\n              [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.INSTANCE,\n              [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]:\n                hooks.preValidation.name?.length > 0\n                  ? hooks.preValidation.name\n                  : ANONYMOUS_FUNCTION_NAME /* c8 ignore next */,\n            });\n          }\n\n          if (hooks.preHandler != null) {\n            hooks.preHandler = handlerWrapper(hooks.preHandler, {\n              [ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,\n              [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - not-found-handler - preHandler`,\n              [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.INSTANCE,\n              [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]:\n                hooks.preHandler.name?.length > 0\n                  ? hooks.preHandler.name\n                  : ANONYMOUS_FUNCTION_NAME /* c8 ignore next */,\n            });\n          }\n\n          handler = handlerWrapper(handler, {\n            [ATTR_SERVICE_NAME]: instance[kInstrumentation].servername,\n            [ATTRIBUTE_NAMES.HOOK_NAME]: `${this.pluginName} - not-found-handler`,\n            [ATTRIBUTE_NAMES.FASTIFY_TYPE]: HOOK_TYPES.INSTANCE,\n            [ATTRIBUTE_NAMES.HOOK_CALLBACK_NAME]:\n              handler.name?.length > 0 ? handler.name : ANONYMOUS_FUNCTION_NAME /* c8 ignore next */,\n          });\n          setNotFoundHandlerOriginal.call(this, hooks, handler);\n        }\n      }\n\n      function handlerWrapper(handler, spanAttributes = {}) {\n        return function handlerWrapped(...args) {\n          /** @type {FastifyOtelInstrumentation} */\n          const instrumentation = this[kInstrumentation];\n          const [request] = args;\n\n          if (instrumentation.isEnabled() === false) {\n            return handler.call(this, ...args);\n          }\n\n          const ctx = request[kRequestContext] ?? context.active();\n          const span = instrumentation.tracer.startSpan(\n            `handler - ${\n              handler.name?.length > 0\n                ? handler.name\n                : this.pluginName /* c8 ignore next */ ?? ANONYMOUS_FUNCTION_NAME /* c8 ignore next */\n            }`,\n            {\n              attributes: spanAttributes,\n            },\n            ctx,\n          );\n\n          return context.with(\n            trace.setSpan(ctx, span),\n            function () {\n              try {\n                const res = handler.call(this, ...args);\n\n                if (typeof res?.then === 'function') {\n                  return res.then(\n                    result => {\n                      span.end();\n                      return result;\n                    },\n                    error => {\n                      span.setStatus({\n                        code: SpanStatusCode.ERROR,\n                        message: error.message,\n                      });\n                      span.recordException(error);\n                      span.end();\n                      return Promise.reject(error);\n                    },\n                  );\n                }\n\n                span.end();\n                return res;\n              } catch (error) {\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: error.message,\n                });\n                span.recordException(error);\n                span.end();\n                throw error;\n              }\n            },\n            this,\n          );\n        };\n      }\n    }\n  }\n}\n"],"names":["InstrumentationBase","diag","dc","propagation","ATTR_SERVICE_NAME","ATTR_HTTP_ROUTE","context","trace","getRPCMetadata","RPCType","ATTR_HTTP_REQUEST_METHOD","SpanStatusCode","ATTR_HTTP_RESPONSE_STATUS_CODE"],"mappings":"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"}},
    {"offset": {"line": 1397, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1401, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/fastify/v3/enums/AttributeNames.ts"],"sourcesContent":["// Vendored from https://github.com/open-telemetry/opentelemetry-js-contrib/blob/407f61591ba69a39a6908264379d4d98a48dbec4/plugins/node/opentelemetry-instrumentation-fastify/src/enums/AttributeNames.ts\n//\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum AttributeNames {\n  FASTIFY_NAME = 'fastify.name',\n  FASTIFY_TYPE = 'fastify.type',\n  HOOK_NAME = 'hook.name',\n  PLUGIN_NAME = 'plugin.name',\n}\n\nexport enum FastifyTypes {\n  MIDDLEWARE = 'middleware',\n  REQUEST_HANDLER = 'request_handler',\n}\n\nexport enum FastifyNames {\n  MIDDLEWARE = 'middleware',\n  REQUEST_HANDLER = 'request handler',\n}\n"],"names":["AttributeNames","FastifyTypes","FastifyNames"],"mappings":";;;AAAA,wMAAA;AACA,EAAA;AACA;;;;;;;;;;;;;;CAcA,GAEAA,QAAAA,cAAAA,GAAAA,KAAAA;AAAA,CAAA,SAAA,cAAA;IACE,MAAA,eAAe;IAAA,cAAA,CAAA,eAAA,GAAA;IACf,MAAA,eAAe;IAAA,cAAA,CAAA,eAAA,GAAA;IACf,MAAA,YAAY;IAAA,cAAA,CAAA,YAAA,GAAA;IACZ,MAAA,cAAc;IAAA,cAAA,CAAA,cAAA,GAAA;AAChB,CAAA,EAAAA,QAAAA,cAAA,IAAA,CAAAA,QAAAA,cAAA,GAAA,CAAA,CAAA;AAEAC,QAAAA,YAAAA,GAAAA,KAAAA;AAAA,CAAA,SAAA,YAAA;IACE,MAAA,aAAa;IAAA,YAAA,CAAA,aAAA,GAAA;IACb,MAAA,kBAAkB;IAAA,YAAA,CAAA,kBAAA,GAAA;AACpB,CAAA,EAAAA,QAAAA,YAAA,IAAA,CAAAA,QAAAA,YAAA,GAAA,CAAA,CAAA;AAEAC,QAAAA,YAAAA,GAAAA,KAAAA;AAAA,CAAA,SAAA,YAAA;IACE,MAAA,aAAa;IAAA,YAAA,CAAA,aAAA,GAAA;IACb,MAAA,kBAAkB;IAAA,YAAA,CAAA,kBAAA,GAAA;AACpB,CAAA,EAAAA,QAAAA,YAAA,IAAA,CAAAA,QAAAA,YAAA,GAAA,CAAA,CAAA"}},
    {"offset": {"line": 1445, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1449, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/fastify/v3/constants.ts"],"sourcesContent":["// Vendored from https://github.com/open-telemetry/opentelemetry-js-contrib/blob/407f61591ba69a39a6908264379d4d98a48dbec4/plugins/node/opentelemetry-instrumentation-fastify/src/constants.ts\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const spanRequestSymbol = Symbol('opentelemetry.instrumentation.fastify.request_active_span');\n\n// The instrumentation creates a span for invocations of lifecycle hook handlers\n// that take `(request, reply, ...[, done])` arguments. Currently this is all\n// lifecycle hooks except `onRequestAbort`.\n// https://fastify.dev/docs/latest/Reference/Hooks\nexport const hooksNamesToWrap = new Set([\n  'onTimeout',\n  'onRequest',\n  'preParsing',\n  'preValidation',\n  'preSerialization',\n  'preHandler',\n  'onSend',\n  'onResponse',\n  'onError',\n]);\n"],"names":[],"mappings":";;;AAAA,6LAAA;AACA;;;;;;;;;;;;;;CAcA,SAEa,oBAAoB,OAAO"}},
    {"offset": {"line": 1469, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1473, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/fastify/v3/utils.ts"],"sourcesContent":["// Vendored from: https://github.com/open-telemetry/opentelemetry-js-contrib/blob/407f61591ba69a39a6908264379d4d98a48dbec4/plugins/node/opentelemetry-instrumentation-fastify/src/utils.ts\n/* eslint-disable jsdoc/require-jsdoc */\n/* eslint-disable @typescript-eslint/no-dynamic-delete */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { type Attributes, type Span, type Tracer, SpanStatusCode } from '@opentelemetry/api';\nimport { spanRequestSymbol } from './constants';\nimport type { PluginFastifyReply } from './internal-types';\n\n/**\n * Starts Span\n * @param reply - reply function\n * @param tracer - tracer\n * @param spanName - span name\n * @param spanAttributes - span attributes\n */\nexport function startSpan(\n  reply: PluginFastifyReply,\n  tracer: Tracer,\n  spanName: string,\n  spanAttributes: Attributes = {},\n) {\n  const span = tracer.startSpan(spanName, { attributes: spanAttributes });\n\n  const spans: Span[] = reply[spanRequestSymbol] || [];\n  spans.push(span);\n\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  Object.defineProperty(reply, spanRequestSymbol, {\n    enumerable: false,\n    configurable: true,\n    value: spans,\n  });\n\n  return span;\n}\n\n/**\n * Ends span\n * @param reply - reply function\n * @param err - error\n */\nexport function endSpan(reply: PluginFastifyReply, err?: any) {\n  const spans = reply[spanRequestSymbol] || [];\n  // there is no active span, or it has already ended\n  if (!spans.length) {\n    return;\n  }\n  // biome-ignore lint/complexity/noForEach: <explanation>\n  spans.forEach((span: Span) => {\n    if (err) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message,\n      });\n      span.recordException(err);\n    }\n    span.end();\n  });\n  delete reply[spanRequestSymbol];\n}\n\n// @TODO after approve add this to instrumentation package and replace usage\n// when it will be released\n\n/**\n * This function handles the missing case from instrumentation package when\n * execute can either return a promise or void. And using async is not an\n * option as it is producing unwanted side effects.\n * @param execute - function to be executed\n * @param onFinish - function called when function executed\n * @param preventThrowingError - prevent to throw error when execute\n * function fails\n */\nexport function safeExecuteInTheMiddleMaybePromise<T>(\n  execute: () => Promise<T>,\n  onFinish: (e: unknown, result?: T) => void,\n  preventThrowingError?: boolean,\n): Promise<T>;\nexport function safeExecuteInTheMiddleMaybePromise<T>(\n  execute: () => T,\n  onFinish: (e: unknown, result?: T) => void,\n  preventThrowingError?: boolean,\n): T;\nexport function safeExecuteInTheMiddleMaybePromise<T>(\n  execute: () => T | Promise<T>,\n  onFinish: (e: unknown, result?: T) => void,\n  preventThrowingError?: boolean,\n): T | Promise<T> | undefined {\n  let error: unknown;\n  let result: T | Promise<T> | undefined = undefined;\n  try {\n    result = execute();\n\n    if (isPromise(result)) {\n      result.then(\n        res => onFinish(undefined, res),\n        err => onFinish(err),\n      );\n    }\n  } catch (e) {\n    error = e;\n  } finally {\n    if (!isPromise(result)) {\n      onFinish(error, result);\n      if (error && !preventThrowingError) {\n        // eslint-disable-next-line no-unsafe-finally\n        throw error;\n      }\n    }\n    // eslint-disable-next-line no-unsafe-finally\n    return result;\n  }\n}\n\nfunction isPromise<T>(val: T | Promise<T>): val is Promise<T> {\n  return (\n    (typeof val === 'object' && val && typeof Object.getOwnPropertyDescriptor(val, 'then')?.value === 'function') ||\n    false\n  );\n}\n"],"names":["spanRequestSymbol","SpanStatusCode"],"mappings":";;;;;AAAA,0LAAA;AACA,sCAAA,GACA,uDAAA,GACA,6DAAA,GACA,mEAAA,GACA;;;;;;;;;;;;;;CAcA,GAMA;;;;;;CAMA,GACO,SAAS,UACd,KAAK,EACL,MAAM,EACN,QAAQ,EACR,iBAA6B,CAAA,CAAE;IAE/B,MAAM,OAAO,OAAO,SAAS,CAAC,UAAU;QAAE,YAAY;IAAA;IAEtD,MAAM,QAAgB,KAAK,CAACA,UAAAA,iBAAiB,CAAA,IAAK,EAAE;IACpD,MAAM,IAAI,CAAC;IAEb,mEAAA;IACE,OAAO,cAAc,CAAC,OAAOA,UAAAA,iBAAiB,EAAE;QAC9C,YAAY;QACZ,cAAc;QACd,OAAO;IACX;IAEE,OAAO;AACT;AAEA;;;;CAIA,GACO,SAAS,QAAQ,KAAK,EAAsB,GAAG;IACpD,MAAM,QAAQ,KAAK,CAACA,UAAAA,iBAAiB,CAAA,IAAK,EAAE;IAC9C,mDAAA;IACE,IAAI,CAAC,MAAM,MAAM,EAAE;QACjB;IACJ;IACA,wDAAA;IACE,MAAM,OAAO,CAAC,CAAC;QACb,IAAI,KAAK;YACP,KAAK,SAAS,CAAC;gBACb,MAAMC,IAAAA,cAAc,CAAC,KAAK;gBAC1B,SAAS,IAAI,OAAO;YAC5B;YACM,KAAK,eAAe,CAAC;QAC3B;QACI,KAAK,GAAG;IACZ;IACE,OAAO,KAAK,CAACD,UAAAA,iBAAiB,CAAC;AACjC;AAEA,4EAAA;AACA,2BAAA;AAEA;;;;;;;;CAQA,GAWO,SAAS,mCACd,OAAO,EACP,QAAQ,EACR,oBAAoB;IAEpB,IAAI;IACJ,IAAI,SAAqC;IACzC,IAAI;QACF,SAAS;QAET,IAAI,UAAU,SAAS;YACrB,OAAO,IAAI,CACT,CAAA,MAAO,SAAS,WAAW,MAC3B,CAAA,MAAO,SAAS;QAExB;IACA,EAAI,OAAO,GAAG;QACV,QAAQ;IACZ,SAAY;QACR,IAAI,CAAC,UAAU,SAAS;YACtB,SAAS,OAAO;YAChB,IAAI,SAAS,MAAuB;gBAC1C,6CAAA;gBACQ,MAAM;YACd;QACA;QACA,6CAAA;QACI,OAAO;IACX;AACA;AAEA,SAAS,UAAa,GAAG;IACvB,OACE,AAAC,OAAO,QAAQ,YAAY,OAAO,OAAO,OAAO,wBAAwB,CAAC,KAAK,SAAS,UAAU,cAClG;AAEJ"}},
    {"offset": {"line": 1574, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1578, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/fastify/v3/instrumentation.ts"],"sourcesContent":["// Vendored from: https://github.com/open-telemetry/opentelemetry-js-contrib/blob/407f61591ba69a39a6908264379d4d98a48dbec4/plugins/node/opentelemetry-instrumentation-fastify/src/instrumentation.ts\n/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable jsdoc/require-jsdoc */\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { type Attributes, context, SpanStatusCode, trace } from '@opentelemetry/api';\nimport { getRPCMetadata, RPCType } from '@opentelemetry/core';\nimport {\n  InstrumentationBase,\n  InstrumentationNodeModuleDefinition,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport { SEMATTRS_HTTP_ROUTE } from '@opentelemetry/semantic-conventions';\nimport type { Span } from '@sentry/core';\nimport {\n  getClient,\n  getIsolationScope,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  spanToJSON,\n} from '@sentry/core';\nimport type {\n  FastifyErrorCodes,\n  FastifyInstance,\n  FastifyReply,\n  FastifyRequest,\n  HandlerOriginal,\n  HookHandlerDoneFunction,\n} from '../types';\nimport { AttributeNames, FastifyNames, FastifyTypes } from './enums/AttributeNames';\nimport type { PluginFastifyReply } from './internal-types';\nimport type { FastifyInstrumentationConfig } from './types';\nimport { endSpan, safeExecuteInTheMiddleMaybePromise, startSpan } from './utils';\n/** @knipignore */\n\nconst PACKAGE_VERSION = '0.1.0';\n\nconst PACKAGE_NAME = '@sentry/instrumentation-fastify-v3';\nconst ANONYMOUS_NAME = 'anonymous';\n\n// The instrumentation creates a span for invocations of lifecycle hook handlers\n// that take `(request, reply, ...[, done])` arguments. Currently this is all\n// lifecycle hooks except `onRequestAbort`.\n// https://fastify.dev/docs/latest/Reference/Hooks\nconst hooksNamesToWrap = new Set([\n  'onTimeout',\n  'onRequest',\n  'preParsing',\n  'preValidation',\n  'preSerialization',\n  'preHandler',\n  'onSend',\n  'onResponse',\n  'onError',\n]);\n\n/**\n * Fastify instrumentation for OpenTelemetry\n */\nexport class FastifyInstrumentationV3 extends InstrumentationBase<FastifyInstrumentationConfig> {\n  public constructor(config: FastifyInstrumentationConfig = {}) {\n    super(PACKAGE_NAME, PACKAGE_VERSION, config);\n  }\n\n  public init(): InstrumentationNodeModuleDefinition[] {\n    return [\n      new InstrumentationNodeModuleDefinition('fastify', ['>=3.0.0 <4'], moduleExports => {\n        return this._patchConstructor(moduleExports);\n      }),\n    ];\n  }\n\n  private _hookOnRequest() {\n    const instrumentation = this;\n\n    return function onRequest(request: FastifyRequest, reply: FastifyReply, done: HookHandlerDoneFunction) {\n      if (!instrumentation.isEnabled()) {\n        return done();\n      }\n      instrumentation._wrap(reply, 'send', instrumentation._patchSend());\n\n      const anyRequest = request as any;\n\n      const rpcMetadata = getRPCMetadata(context.active());\n      const routeName = anyRequest.routeOptions\n        ? anyRequest.routeOptions.url // since fastify@4.10.0\n        : request.routerPath;\n      if (routeName && rpcMetadata?.type === RPCType.HTTP) {\n        rpcMetadata.route = routeName;\n      }\n\n      const method = request.method || 'GET';\n\n      getIsolationScope().setTransactionName(`${method} ${routeName}`);\n      done();\n    };\n  }\n\n  private _wrapHandler(\n    pluginName: string,\n    hookName: string,\n    original: HandlerOriginal,\n    syncFunctionWithDone: boolean,\n  ): () => Promise<unknown> {\n    const instrumentation = this;\n    this._diag.debug('Patching fastify route.handler function');\n\n    return function (this: any, ...args: unknown[]): Promise<unknown> {\n      if (!instrumentation.isEnabled()) {\n        return original.apply(this, args);\n      }\n\n      const name = original.name || pluginName || ANONYMOUS_NAME;\n      const spanName = `${FastifyNames.MIDDLEWARE} - ${name}`;\n\n      const reply = args[1] as PluginFastifyReply;\n\n      const span = startSpan(reply, instrumentation.tracer, spanName, {\n        [AttributeNames.FASTIFY_TYPE]: FastifyTypes.MIDDLEWARE,\n        [AttributeNames.PLUGIN_NAME]: pluginName,\n        [AttributeNames.HOOK_NAME]: hookName,\n      });\n\n      const origDone = syncFunctionWithDone && (args[args.length - 1] as HookHandlerDoneFunction);\n      if (origDone) {\n        args[args.length - 1] = function (...doneArgs: Parameters<HookHandlerDoneFunction>) {\n          endSpan(reply);\n          origDone.apply(this, doneArgs);\n        };\n      }\n\n      return context.with(trace.setSpan(context.active(), span), () => {\n        return safeExecuteInTheMiddleMaybePromise(\n          () => {\n            return original.apply(this, args);\n          },\n          err => {\n            if (err instanceof Error) {\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: err.message,\n              });\n              span.recordException(err);\n            }\n            // async hooks should end the span as soon as the promise is resolved\n            if (!syncFunctionWithDone) {\n              endSpan(reply);\n            }\n          },\n        );\n      });\n    };\n  }\n\n  private _wrapAddHook(): (original: FastifyInstance['addHook']) => () => FastifyInstance {\n    const instrumentation = this;\n    this._diag.debug('Patching fastify server.addHook function');\n\n    // biome-ignore lint/complexity/useArrowFunction: <explanation>\n    return function (original: FastifyInstance['addHook']): () => FastifyInstance {\n      return function wrappedAddHook(this: any, ...args: any) {\n        const name = args[0] as string;\n        const handler = args[1] as HandlerOriginal;\n        const pluginName = this.pluginName;\n        if (!hooksNamesToWrap.has(name)) {\n          return original.apply(this, args);\n        }\n\n        const syncFunctionWithDone =\n          typeof args[args.length - 1] === 'function' && handler.constructor.name !== 'AsyncFunction';\n\n        return original.apply(this, [\n          name,\n          instrumentation._wrapHandler(pluginName, name, handler, syncFunctionWithDone),\n        ] as never);\n      };\n    };\n  }\n\n  private _patchConstructor(moduleExports: {\n    fastify: () => FastifyInstance;\n    errorCodes: FastifyErrorCodes | undefined;\n  }): () => FastifyInstance {\n    const instrumentation = this;\n\n    function fastify(this: FastifyInstance, ...args: any) {\n      const app: FastifyInstance = moduleExports.fastify.apply(this, args);\n      app.addHook('onRequest', instrumentation._hookOnRequest());\n      app.addHook('preHandler', instrumentation._hookPreHandler());\n\n      instrumentClient();\n\n      instrumentation._wrap(app, 'addHook', instrumentation._wrapAddHook());\n\n      return app;\n    }\n\n    if (moduleExports.errorCodes !== undefined) {\n      fastify.errorCodes = moduleExports.errorCodes;\n    }\n    fastify.fastify = fastify;\n    fastify.default = fastify;\n    return fastify;\n  }\n\n  private _patchSend() {\n    const instrumentation = this;\n    this._diag.debug('Patching fastify reply.send function');\n\n    return function patchSend(original: () => FastifyReply): () => FastifyReply {\n      return function send(this: FastifyReply, ...args: any) {\n        const maybeError: any = args[0];\n\n        if (!instrumentation.isEnabled()) {\n          return original.apply(this, args);\n        }\n\n        return safeExecuteInTheMiddle<FastifyReply>(\n          () => {\n            return original.apply(this, args);\n          },\n          err => {\n            if (!err && maybeError instanceof Error) {\n              // eslint-disable-next-line no-param-reassign\n              err = maybeError;\n            }\n            endSpan(this, err);\n          },\n        );\n      };\n    };\n  }\n\n  private _hookPreHandler() {\n    const instrumentation = this;\n    this._diag.debug('Patching fastify preHandler function');\n\n    return function preHandler(this: any, request: FastifyRequest, reply: FastifyReply, done: HookHandlerDoneFunction) {\n      if (!instrumentation.isEnabled()) {\n        return done();\n      }\n      const anyRequest = request as any;\n\n      const handler = anyRequest.routeOptions?.handler || anyRequest.context?.handler;\n      const handlerName = handler?.name.startsWith('bound ') ? handler.name.substring(6) : handler?.name;\n      const spanName = `${FastifyNames.REQUEST_HANDLER} - ${handlerName || this.pluginName || ANONYMOUS_NAME}`;\n\n      const spanAttributes: Attributes = {\n        [AttributeNames.PLUGIN_NAME]: this.pluginName,\n        [AttributeNames.FASTIFY_TYPE]: FastifyTypes.REQUEST_HANDLER,\n        // eslint-disable-next-line deprecation/deprecation\n        [SEMATTRS_HTTP_ROUTE]: anyRequest.routeOptions\n          ? anyRequest.routeOptions.url // since fastify@4.10.0\n          : request.routerPath,\n      };\n      if (handlerName) {\n        spanAttributes[AttributeNames.FASTIFY_NAME] = handlerName;\n      }\n      const span = startSpan(reply, instrumentation.tracer, spanName, spanAttributes);\n\n      addFastifyV3SpanAttributes(span);\n\n      const { requestHook } = instrumentation.getConfig();\n      if (requestHook) {\n        safeExecuteInTheMiddle(\n          () => requestHook(span, { request }),\n          e => {\n            if (e) {\n              instrumentation._diag.error('request hook failed', e);\n            }\n          },\n          true,\n        );\n      }\n\n      return context.with(trace.setSpan(context.active(), span), () => {\n        done();\n      });\n    };\n  }\n}\n\nfunction instrumentClient(): void {\n  const client = getClient();\n  if (client) {\n    client.on('spanStart', (span: Span) => {\n      addFastifyV3SpanAttributes(span);\n    });\n  }\n}\n\nfunction addFastifyV3SpanAttributes(span: Span): void {\n  const attributes = spanToJSON(span).data;\n\n  // this is one of: middleware, request_handler\n  const type = attributes['fastify.type'];\n\n  // If this is already set, or we have no fastify span, no need to process again...\n  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] || !type) {\n    return;\n  }\n\n  span.setAttributes({\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.fastify',\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${type}.fastify`,\n  });\n\n  // Also update the name, we don't need to \"middleware - \" prefix\n  const name = attributes['fastify.name'] || attributes['plugin.name'] || attributes['hook.name'];\n  if (typeof name === 'string') {\n    // Try removing `fastify -> ` and `@fastify/otel -> ` prefixes\n    // This is a bit of a hack, and not always working for all spans\n    // But it's the best we can do without a proper API\n    const updatedName = name.replace(/^fastify -> /, '').replace(/^@fastify\\/otel -> /, '');\n\n    span.updateName(updatedName);\n  }\n}\n"],"names":["InstrumentationBase","InstrumentationNodeModuleDefinition","getRPCMetadata","context","RPCType","getIsolationScope","FastifyNames","startSpan","AttributeNames","FastifyTypes","endSpan","trace","safeExecuteInTheMiddleMaybePromise","SpanStatusCode","instrumentation","safeExecuteInTheMiddle","SEMATTRS_HTTP_ROUTE","getClient","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN"],"mappings":"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"}},
    {"offset": {"line": 1810, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1814, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/fastify/index.ts"],"sourcesContent":["import * as diagnosticsChannel from 'node:diagnostics_channel';\nimport type { Instrumentation, InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport type { IntegrationFn, Span } from '@sentry/core';\nimport {\n  captureException,\n  defineIntegration,\n  getClient,\n  getIsolationScope,\n  logger,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  spanToJSON,\n} from '@sentry/core';\nimport { generateInstrumentOnce } from '@sentry/node-core';\nimport { DEBUG_BUILD } from '../../../debug-build';\nimport { FastifyOtelInstrumentation } from './fastify-otel/index';\nimport type { FastifyInstance, FastifyReply, FastifyRequest } from './types';\nimport { FastifyInstrumentationV3 } from './v3/instrumentation';\n\ninterface FastifyHandlerOptions {\n  /**\n   * Callback method deciding whether error should be captured and sent to Sentry\n   *\n   * @param error Captured Fastify error\n   * @param request Fastify request (or any object containing at least method, routeOptions.url, and routerPath)\n   * @param reply Fastify reply (or any object containing at least statusCode)\n   *\n   * @example\n   *\n   * ```javascript\n   * setupFastifyErrorHandler(app, {\n   *   shouldHandleError(_error, _request, reply) {\n   *     return reply.statusCode >= 400;\n   *   },\n   * });\n   * ```\n   *\n   * If using TypeScript, you can cast the request and reply to get full type safety.\n   *\n   * ```typescript\n   * import type { FastifyRequest, FastifyReply } from 'fastify';\n   *\n   * setupFastifyErrorHandler(app, {\n   *   shouldHandleError(error, minimalRequest, minimalReply) {\n   *     const request = minimalRequest as FastifyRequest;\n   *     const reply = minimalReply as FastifyReply;\n   *     return reply.statusCode >= 500;\n   *   },\n   * });\n   * ```\n   */\n  shouldHandleError: (error: Error, request: FastifyRequest, reply: FastifyReply) => boolean;\n}\n\nconst INTEGRATION_NAME = 'Fastify';\nconst INTEGRATION_NAME_V3 = 'Fastify-V3';\n\nexport const instrumentFastifyV3 = generateInstrumentOnce(INTEGRATION_NAME_V3, () => new FastifyInstrumentationV3());\n\nfunction handleFastifyError(\n  this: {\n    diagnosticsChannelExists?: boolean;\n  },\n  error: Error,\n  request: FastifyRequest & { opentelemetry?: () => { span?: Span } },\n  reply: FastifyReply,\n  shouldHandleError: (error: Error, request: FastifyRequest, reply: FastifyReply) => boolean,\n  handlerOrigin: 'diagnostics-channel' | 'onError-hook',\n): void {\n  // Diagnostics channel runs before the onError hook, so we can use it to check if the handler was already registered\n  if (handlerOrigin === 'diagnostics-channel') {\n    this.diagnosticsChannelExists = true;\n  }\n\n  if (this.diagnosticsChannelExists && handlerOrigin === 'onError-hook') {\n    DEBUG_BUILD &&\n      logger.warn(\n        'Fastify error handler was already registered via diagnostics channel.',\n        'You can safely remove `setupFastifyErrorHandler` call.',\n      );\n\n    // If the diagnostics channel already exists, we don't need to handle the error again\n    return;\n  }\n\n  if (shouldHandleError(error, request, reply)) {\n    captureException(error);\n  }\n}\n\nexport const instrumentFastify = generateInstrumentOnce(INTEGRATION_NAME, () => {\n  const fastifyOtelInstrumentationInstance = new FastifyOtelInstrumentation();\n  const plugin = fastifyOtelInstrumentationInstance.plugin();\n  const options = fastifyOtelInstrumentationInstance.getConfig();\n  const shouldHandleError = (options as FastifyHandlerOptions)?.shouldHandleError || defaultShouldHandleError;\n\n  // This message handler works for Fastify versions 3, 4 and 5\n  diagnosticsChannel.subscribe('fastify.initialization', message => {\n    const fastifyInstance = (message as { fastify?: FastifyInstance }).fastify;\n\n    fastifyInstance?.register(plugin).after(err => {\n      if (err) {\n        DEBUG_BUILD && logger.error('Failed to setup Fastify instrumentation', err);\n      } else {\n        instrumentClient();\n\n        if (fastifyInstance) {\n          instrumentOnRequest(fastifyInstance);\n        }\n      }\n    });\n  });\n\n  // This diagnostics channel only works on Fastify version 5\n  // For versions 3 and 4, we use `setupFastifyErrorHandler` instead\n  diagnosticsChannel.subscribe('tracing:fastify.request.handler:error', message => {\n    const { error, request, reply } = message as {\n      error: Error;\n      request: FastifyRequest & { opentelemetry?: () => { span?: Span } };\n      reply: FastifyReply;\n    };\n\n    handleFastifyError.call(handleFastifyError, error, request, reply, shouldHandleError, 'diagnostics-channel');\n  });\n\n  // Returning this as unknown not to deal with the internal types of the FastifyOtelInstrumentation\n  return fastifyOtelInstrumentationInstance as Instrumentation<InstrumentationConfig & FastifyHandlerOptions>;\n});\n\nconst _fastifyIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentFastifyV3();\n      instrumentFastify();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for [Fastify](https://fastify.dev/).\n *\n * If you also want to capture errors, you need to call `setupFastifyErrorHandler(app)` after you set up your Fastify server.\n *\n * For more information, see the [fastify documentation](https://docs.sentry.io/platforms/javascript/guides/fastify/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *   integrations: [Sentry.fastifyIntegration()],\n * })\n * ```\n */\nexport const fastifyIntegration = defineIntegration(_fastifyIntegration);\n\n/**\n * Default function to determine if an error should be sent to Sentry\n *\n * 3xx and 4xx errors are not sent by default.\n */\nfunction defaultShouldHandleError(_error: Error, _request: FastifyRequest, reply: FastifyReply): boolean {\n  const statusCode = reply.statusCode;\n  // 3xx and 4xx errors are not sent by default.\n  return statusCode >= 500 || statusCode <= 299;\n}\n\n/**\n * Add an Fastify error handler to capture errors to Sentry.\n *\n * @param fastify The Fastify instance to which to add the error handler\n * @param options Configuration options for the handler\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n * const Fastify = require(\"fastify\");\n *\n * const app = Fastify();\n *\n * Sentry.setupFastifyErrorHandler(app);\n *\n * // Add your routes, etc.\n *\n * app.listen({ port: 3000 });\n * ```\n */\nexport function setupFastifyErrorHandler(fastify: FastifyInstance, options?: Partial<FastifyHandlerOptions>): void {\n  const shouldHandleError = options?.shouldHandleError || defaultShouldHandleError;\n  const plugin = Object.assign(\n    function (fastify: FastifyInstance, _options: unknown, done: () => void): void {\n      fastify.addHook('onError', async (request, reply, error) => {\n        handleFastifyError.call(handleFastifyError, error, request, reply, shouldHandleError, 'onError-hook');\n      });\n      done();\n    },\n    {\n      [Symbol.for('skip-override')]: true,\n      [Symbol.for('fastify.display-name')]: 'sentry-fastify-error-handler',\n    },\n  );\n\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  fastify.register(plugin);\n}\n\nfunction addFastifySpanAttributes(span: Span): void {\n  const spanJSON = spanToJSON(span);\n  const spanName = spanJSON.description;\n  const attributes = spanJSON.data;\n\n  const type = attributes['fastify.type'];\n\n  const isHook = type === 'hook';\n  const isHandler = type === spanName?.startsWith('handler -');\n  // In @fastify/otel `request-handler` is separated by dash, not underscore\n  const isRequestHandler = spanName === 'request' || type === 'request-handler';\n\n  // If this is already set, or we have no fastify span, no need to process again...\n  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] || (!isHandler && !isRequestHandler && !isHook)) {\n    return;\n  }\n\n  const opPrefix = isHook ? 'hook' : isHandler ? 'middleware' : isRequestHandler ? 'request-handler' : '<unknown>';\n\n  span.setAttributes({\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.fastify',\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${opPrefix}.fastify`,\n  });\n\n  const attrName = attributes['fastify.name'] || attributes['plugin.name'] || attributes['hook.name'];\n  if (typeof attrName === 'string') {\n    // Try removing `fastify -> ` and `@fastify/otel -> ` prefixes\n    // This is a bit of a hack, and not always working for all spans\n    // But it's the best we can do without a proper API\n    const updatedName = attrName.replace(/^fastify -> /, '').replace(/^@fastify\\/otel -> /, '');\n\n    span.updateName(updatedName);\n  }\n}\n\nfunction instrumentClient(): void {\n  const client = getClient();\n  if (client) {\n    client.on('spanStart', (span: Span) => {\n      addFastifySpanAttributes(span);\n    });\n  }\n}\n\nfunction instrumentOnRequest(fastify: FastifyInstance): void {\n  fastify.addHook('onRequest', async (request: FastifyRequest & { opentelemetry?: () => { span?: Span } }, _reply) => {\n    if (request.opentelemetry) {\n      const { span } = request.opentelemetry();\n\n      if (span) {\n        addFastifySpanAttributes(span);\n      }\n    }\n\n    const routeName = request.routeOptions?.url;\n    const method = request.method || 'GET';\n\n    getIsolationScope().setTransactionName(`${method} ${routeName}`);\n  });\n}\n"],"names":["generateInstrumentOnce","FastifyInstrumentationV3","DEBUG_BUILD","logger","captureException","FastifyOtelInstrumentation","diagnosticsChannel","defineIntegration","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","getClient","getIsolationScope"],"mappings":"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"}},
    {"offset": {"line": 1987, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1991, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/graphql.ts"],"sourcesContent":["import type { AttributeValue } from '@opentelemetry/api';\nimport { SpanStatusCode } from '@opentelemetry/api';\nimport { GraphQLInstrumentation } from '@opentelemetry/instrumentation-graphql';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration, getRootSpan, spanToJSON } from '@sentry/core';\nimport { addOriginToSpan, generateInstrumentOnce } from '@sentry/node-core';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION } from '@sentry/opentelemetry';\n\ninterface GraphqlOptions {\n  /**\n   * Do not create spans for resolvers.\n   *\n   * Defaults to true.\n   */\n  ignoreResolveSpans?: boolean;\n\n  /**\n   * Don't create spans for the execution of the default resolver on object properties.\n   *\n   * When a resolver function is not defined on the schema for a field, graphql will\n   * use the default resolver which just looks for a property with that name on the object.\n   * If the property is not a function, it's not very interesting to trace.\n   * This option can reduce noise and number of spans created.\n   *\n   * Defaults to true.\n   */\n  ignoreTrivialResolveSpans?: boolean;\n\n  /**\n   * If this is enabled, a http.server root span containing this span will automatically be renamed to include the operation name.\n   * Set this to `false` if you do not want this behavior, and want to keep the default http.server span name.\n   *\n   * Defaults to true.\n   */\n  useOperationNameForRootSpan?: boolean;\n}\n\nconst INTEGRATION_NAME = 'Graphql';\n\nexport const instrumentGraphql = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  GraphQLInstrumentation,\n  (_options: GraphqlOptions) => {\n    const options = getOptionsWithDefaults(_options);\n\n    return {\n      ...options,\n      responseHook(span, result) {\n        addOriginToSpan(span, 'auto.graphql.otel.graphql');\n\n        // We want to ensure spans are marked as errored if there are errors in the result\n        // We only do that if the span is not already marked with a status\n        const resultWithMaybeError = result as { errors?: { message: string }[] };\n        if (resultWithMaybeError.errors?.length && !spanToJSON(span).status) {\n          span.setStatus({ code: SpanStatusCode.ERROR });\n        }\n\n        const attributes = spanToJSON(span).data;\n\n        // If operation.name is not set, we fall back to use operation.type only\n        const operationType = attributes['graphql.operation.type'];\n        const operationName = attributes['graphql.operation.name'];\n\n        if (options.useOperationNameForRootSpan && operationType) {\n          const rootSpan = getRootSpan(span);\n          const rootSpanAttributes = spanToJSON(rootSpan).data;\n\n          const existingOperations = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION] || [];\n\n          const newOperation = operationName ? `${operationType} ${operationName}` : `${operationType}`;\n\n          // We keep track of each operation on the root span\n          // This can either be a string, or an array of strings (if there are multiple operations)\n          if (Array.isArray(existingOperations)) {\n            (existingOperations as string[]).push(newOperation);\n            rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, existingOperations);\n          } else if (typeof existingOperations === 'string') {\n            rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, [existingOperations, newOperation]);\n          } else {\n            rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, newOperation);\n          }\n\n          if (!spanToJSON(rootSpan).data['original-description']) {\n            rootSpan.setAttribute('original-description', spanToJSON(rootSpan).description);\n          }\n          // Important for e.g. @sentry/aws-serverless because this would otherwise overwrite the name again\n          rootSpan.updateName(\n            `${spanToJSON(rootSpan).data['original-description']} (${getGraphqlOperationNamesFromAttribute(\n              existingOperations,\n            )})`,\n          );\n        }\n      },\n    };\n  },\n);\n\nconst _graphqlIntegration = ((options: GraphqlOptions = {}) => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      // We set defaults here, too, because otherwise we'd update the instrumentation config\n      // to the config without defaults, as `generateInstrumentOnce` automatically calls `setConfig(options)`\n      // when being called the second time\n      instrumentGraphql(getOptionsWithDefaults(options));\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [graphql](https://www.npmjs.com/package/graphql) library.\n *\n * For more information, see the [`graphqlIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/graphql/).\n *\n * @param {GraphqlOptions} options Configuration options for the GraphQL integration.\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.graphqlIntegration()],\n * });\n */\nexport const graphqlIntegration = defineIntegration(_graphqlIntegration);\n\nfunction getOptionsWithDefaults(options?: GraphqlOptions): GraphqlOptions {\n  return {\n    ignoreResolveSpans: true,\n    ignoreTrivialResolveSpans: true,\n    useOperationNameForRootSpan: true,\n    ...options,\n  };\n}\n\n// copy from packages/opentelemetry/utils\nfunction getGraphqlOperationNamesFromAttribute(attr: AttributeValue): string {\n  if (Array.isArray(attr)) {\n    const sorted = attr.slice().sort();\n\n    // Up to 5 items, we just add all of them\n    if (sorted.length <= 5) {\n      return sorted.join(', ');\n    } else {\n      // Else, we add the first 5 and the diff of other operations\n      return `${sorted.slice(0, 5).join(', ')}, +${sorted.length - 5}`;\n    }\n  }\n\n  return `${attr}`;\n}\n"],"names":["generateInstrumentOnce","GraphQLInstrumentation","addOriginToSpan","spanToJSON","SpanStatusCode","getRootSpan","SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION","defineIntegration"],"mappings":";;;;;;;;AAqCA,MAAM,mBAAmB;AAElB,MAAM,oBAAoBA,SAAAA,sBAAsB,CACrD,kBACAC,uBAAAA,sBAAsB,EACtB,CAAC;IACC,MAAM,UAAU,uBAAuB;IAEvC,OAAO;QACL,GAAG,OAAO;QACV,cAAa,IAAI,EAAE,MAAM;YACvBC,SAAAA,eAAe,CAAC,MAAM;YAE9B,kFAAA;YACA,kEAAA;YACQ,MAAM,uBAAuB;YAC7B,IAAI,qBAAqB,MAAM,EAAE,UAAU,CAACC,KAAAA,UAAU,CAAC,MAAM,MAAM,EAAE;gBACnE,KAAK,SAAS,CAAC;oBAAE,MAAMC,IAAAA,cAAc,CAAC,KAAA;gBAAA;YAChD;YAEQ,MAAM,aAAaD,KAAAA,UAAU,CAAC,MAAM,IAAI;YAEhD,wEAAA;YACQ,MAAM,gBAAgB,UAAU,CAAC,yBAAyB;YAC1D,MAAM,gBAAgB,UAAU,CAAC,yBAAyB;YAE1D,IAAI,QAAQ,2BAAA,IAA+B,eAAe;gBACxD,MAAM,WAAWE,KAAAA,WAAW,CAAC;gBAC7B,MAAM,qBAAqBF,KAAAA,UAAU,CAAC,UAAU,IAAI;gBAEpD,MAAM,qBAAqB,kBAAkB,CAACG,cAAAA,2CAA2C,CAAA,IAAK,EAAE;gBAEhG,MAAM,eAAe,gBAAgB,CAAC,EAAA,cAAA,CAAA,EAAA,cAAA,CAAA,GAAA,CAAA,EAAA,cAAA,CAAA;gBAEA,mDAAA;gBACA,yFAAA;gBACA,IAAA,MAAA,OAAA,CAAA,qBAAA;oBACA,mBAAA,IAAA,CAAA;oBACA,SAAA,YAAA,CAAAA,cAAAA,2CAAA,EAAA;gBACA,OAAA,IAAA,OAAA,uBAAA,UAAA;oBACA,SAAA,YAAA,CAAAA,cAAAA,2CAAA,EAAA;wBAAA;wBAAA;qBAAA;gBACA,OAAA;oBACA,SAAA,YAAA,CAAAA,cAAAA,2CAAA,EAAA;gBACA;gBAEA,IAAA,CAAAH,KAAAA,UAAA,CAAA,UAAA,IAAA,CAAA,uBAAA,EAAA;oBACA,SAAA,YAAA,CAAA,wBAAAA,KAAAA,UAAA,CAAA,UAAA,WAAA;gBACA;gBACA,kGAAA;gBACA,SAAA,UAAA,CACA,CAAA,EAAAA,KAAAA,UAAA,CAAA,UAAA,IAAA,CAAA,uBAAA,CAAA,EAAA,EAAA,sCACA,oBACA,CAAA,CAAA;YAEA;QACA;IACA;AACA;AAGA,MAAA,sBAAA,CAAA,UAAA,CAAA,CAAA;IACA,OAAA;QACA,MAAA;QACA;YACA,sFAAA;YACA,uGAAA;YACA,oCAAA;YACA,kBAAA,uBAAA;QACA;IACA;AACA;AAEA;;;;;;;;;;;;;;CAcA,GACA,MAAA,qBAAAI,KAAAA,iBAAA,CAAA;AAEA,SAAA,uBAAA,OAAA;IACA,OAAA;QACA,oBAAA;QACA,2BAAA;QACA,6BAAA;QACA,GAAA,OAAA;IACA;AACA;AAEA,yCAAA;AACA,SAAA,sCAAA,IAAA;IACA,IAAA,MAAA,OAAA,CAAA,OAAA;QACA,MAAA,SAAA,KAAA,KAAA,GAAA,IAAA;QAEA,yCAAA;QACA,IAAA,OAAA,MAAA,IAAA,GAAA;YACA,OAAA,OAAA,IAAA,CAAA;QACA,OAAA;YACA,4DAAA;YACA,OAAA,CAAA,EAAA,OAAA,KAAA,CAAA,GAAA,GAAA,IAAA,CAAA,MAAA,GAAA,EAAA,OAAA,MAAA,GAAA,EAAA,CAAA;QACA;IACA;IAEA,OAAA,CAAA,EAAA,KAAA,CAAA;AACA"}},
    {"offset": {"line": 2095, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2099, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/kafka.ts"],"sourcesContent":["import { KafkaJsInstrumentation } from '@opentelemetry/instrumentation-kafkajs';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration } from '@sentry/core';\nimport { addOriginToSpan, generateInstrumentOnce } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'Kafka';\n\nexport const instrumentKafka = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  () =>\n    new KafkaJsInstrumentation({\n      consumerHook(span) {\n        addOriginToSpan(span, 'auto.kafkajs.otel.consumer');\n      },\n      producerHook(span) {\n        addOriginToSpan(span, 'auto.kafkajs.otel.producer');\n      },\n    }),\n);\n\nconst _kafkaIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentKafka();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [kafkajs](https://www.npmjs.com/package/kafkajs) library.\n *\n * For more information, see the [`kafkaIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/kafka/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.kafkaIntegration()],\n * });\n */\nexport const kafkaIntegration = defineIntegration(_kafkaIntegration);\n"],"names":["generateInstrumentOnce","KafkaJsInstrumentation","addOriginToSpan","defineIntegration"],"mappings":";;;;;;AAKA,MAAM,mBAAmB;AAElB,MAAM,kBAAkBA,SAAAA,sBAAsB,CACnD,kBACA,IACE,IAAIC,uBAAAA,sBAAsB,CAAC;QACzB,cAAa,IAAI;YACfC,SAAAA,eAAe,CAAC,MAAM;QAC9B;QACM,cAAa,IAAI;YACfA,SAAAA,eAAe,CAAC,MAAM;QAC9B;IACA;AAGA,MAAM,oBAAqB;IACzB,OAAO;QACL,MAAM;QACN;YACE;QACN;IACA;AACA;AAEA;;;;;;;;;;;;CAYA,SACa,mBAAmBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 2137, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2141, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/lrumemoizer.ts"],"sourcesContent":["import { LruMemoizerInstrumentation } from '@opentelemetry/instrumentation-lru-memoizer';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration } from '@sentry/core';\nimport { generateInstrumentOnce } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'LruMemoizer';\n\nexport const instrumentLruMemoizer = generateInstrumentOnce(INTEGRATION_NAME, () => new LruMemoizerInstrumentation());\n\nconst _lruMemoizerIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentLruMemoizer();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [lru-memoizer](https://www.npmjs.com/package/lru-memoizer) library.\n *\n * For more information, see the [`lruMemoizerIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/lrumemoizer/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.lruMemoizerIntegration()],\n * });\n */\nexport const lruMemoizerIntegration = defineIntegration(_lruMemoizerIntegration);\n"],"names":["generateInstrumentOnce","LruMemoizerInstrumentation","defineIntegration"],"mappings":";;;;;;AAKA,MAAM,mBAAmB;AAElB,MAAM,wBAAwBA,SAAAA,sBAAsB,CAAC,kBAAkB,IAAM,IAAIC,2BAAAA,0BAA0B;AAElH,MAAM,0BAA2B;IAC/B,OAAO;QACL,MAAM;QACN;YACE;QACN;IACA;AACA;AAEA;;;;;;;;;;;;CAYA,SACa,yBAAyBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 2172, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2176, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/mongo.ts"],"sourcesContent":["import { MongoDBInstrumentation } from '@opentelemetry/instrumentation-mongodb';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration } from '@sentry/core';\nimport { addOriginToSpan, generateInstrumentOnce } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'Mongo';\n\nexport const instrumentMongo = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  () =>\n    new MongoDBInstrumentation({\n      dbStatementSerializer: _defaultDbStatementSerializer,\n      responseHook(span) {\n        addOriginToSpan(span, 'auto.db.otel.mongo');\n      },\n    }),\n);\n\n/**\n * Replaces values in document with '?', hiding PII and helping grouping.\n */\nexport function _defaultDbStatementSerializer(commandObj: Record<string, unknown>): string {\n  const resultObj = _scrubStatement(commandObj);\n  return JSON.stringify(resultObj);\n}\n\nfunction _scrubStatement(value: unknown): unknown {\n  if (Array.isArray(value)) {\n    return value.map(element => _scrubStatement(element));\n  }\n\n  if (isCommandObj(value)) {\n    const initial: Record<string, unknown> = {};\n    return Object.entries(value)\n      .map(([key, element]) => [key, _scrubStatement(element)])\n      .reduce((prev, current) => {\n        if (isCommandEntry(current)) {\n          prev[current[0]] = current[1];\n        }\n        return prev;\n      }, initial);\n  }\n\n  // A value like string or number, possible contains PII, scrub it\n  return '?';\n}\n\nfunction isCommandObj(value: Record<string, unknown> | unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !isBuffer(value);\n}\n\nfunction isBuffer(value: unknown): boolean {\n  let isBuffer = false;\n  if (typeof Buffer !== 'undefined') {\n    isBuffer = Buffer.isBuffer(value);\n  }\n  return isBuffer;\n}\n\nfunction isCommandEntry(value: [string, unknown] | unknown): value is [string, unknown] {\n  return Array.isArray(value);\n}\n\nconst _mongoIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentMongo();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [mongodb](https://www.npmjs.com/package/mongodb) library.\n *\n * For more information, see the [`mongoIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/mongo/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.mongoIntegration()],\n * });\n * ```\n */\nexport const mongoIntegration = defineIntegration(_mongoIntegration);\n"],"names":["generateInstrumentOnce","MongoDBInstrumentation","addOriginToSpan","defineIntegration"],"mappings":";;;;;;AAKA,MAAM,mBAAmB;AAElB,MAAM,kBAAkBA,SAAAA,sBAAsB,CACnD,kBACA,IACE,IAAIC,uBAAAA,sBAAsB,CAAC;QACzB,uBAAuB;QACvB,cAAa,IAAI;YACfC,SAAAA,eAAe,CAAC,MAAM;QAC9B;IACA;AAGA;;CAEA,GACO,SAAS,8BAA8B,UAAU;IACtD,MAAM,YAAY,gBAAgB;IAClC,OAAO,KAAK,SAAS,CAAC;AACxB;AAEA,SAAS,gBAAgB,KAAK;IAC5B,IAAI,MAAM,OAAO,CAAC,QAAQ;QACxB,OAAO,MAAM,GAAG,CAAC,CAAA,UAAW,gBAAgB;IAChD;IAEE,IAAI,aAAa,QAAQ;QACvB,MAAM,UAAmC,CAAA;QACzC,OAAO,OAAO,OAAO,CAAC,OACnB,GAAG,CAAC,CAAC,CAAC,KAAK,QAAQ,GAAK;gBAAC;gBAAK,gBAAgB;aAAS,EACvD,MAAM,CAAC,CAAC,MAAM;YACb,IAAI,eAAe,UAAU;gBAC3B,IAAI,CAAC,OAAO,CAAC,EAAE,CAAA,GAAI,OAAO,CAAC,EAAE;YACvC;YACQ,OAAO;QACf,GAAS;IACT;IAEA,iEAAA;IACE,OAAO;AACT;AAEA,SAAS,aAAa,KAAK;IACzB,OAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,SAAS;AAClE;AAEA,SAAS,SAAS,KAAK;IACrB,IAAI,WAAW;IACf,IAAI,OAAO,WAAW,aAAa;QACjC,WAAW,OAAO,QAAQ,CAAC;IAC/B;IACE,OAAO;AACT;AAEA,SAAS,eAAe,KAAK;IAC3B,OAAO,MAAM,OAAO,CAAC;AACvB;AAEA,MAAM,oBAAqB;IACzB,OAAO;QACL,MAAM;QACN;YACE;QACN;IACA;AACA;AAEA;;;;;;;;;;;;;CAaA,SACa,mBAAmBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 2252, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2256, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/mongoose.ts"],"sourcesContent":["import { MongooseInstrumentation } from '@opentelemetry/instrumentation-mongoose';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration } from '@sentry/core';\nimport { addOriginToSpan, generateInstrumentOnce } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'Mongoose';\n\nexport const instrumentMongoose = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  () =>\n    new MongooseInstrumentation({\n      responseHook(span) {\n        addOriginToSpan(span, 'auto.db.otel.mongoose');\n      },\n    }),\n);\n\nconst _mongooseIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentMongoose();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [mongoose](https://www.npmjs.com/package/mongoose) library.\n *\n * For more information, see the [`mongooseIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/mongoose/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.mongooseIntegration()],\n * });\n * ```\n */\nexport const mongooseIntegration = defineIntegration(_mongooseIntegration);\n"],"names":["generateInstrumentOnce","MongooseInstrumentation","addOriginToSpan","defineIntegration"],"mappings":";;;;;;AAKA,MAAM,mBAAmB;AAElB,MAAM,qBAAqBA,SAAAA,sBAAsB,CACtD,kBACA,IACE,IAAIC,wBAAAA,uBAAuB,CAAC;QAC1B,cAAa,IAAI;YACfC,SAAAA,eAAe,CAAC,MAAM;QAC9B;IACA;AAGA,MAAM,uBAAwB;IAC5B,OAAO;QACL,MAAM;QACN;YACE;QACN;IACA;AACA;AAEA;;;;;;;;;;;;;CAaA,SACa,sBAAsBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 2292, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2296, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/mysql.ts"],"sourcesContent":["import { MySQLInstrumentation } from '@opentelemetry/instrumentation-mysql';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration } from '@sentry/core';\nimport { generateInstrumentOnce } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'Mysql';\n\nexport const instrumentMysql = generateInstrumentOnce(INTEGRATION_NAME, () => new MySQLInstrumentation({}));\n\nconst _mysqlIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentMysql();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [mysql](https://www.npmjs.com/package/mysql) library.\n *\n * For more information, see the [`mysqlIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/mysql/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.mysqlIntegration()],\n * });\n * ```\n */\nexport const mysqlIntegration = defineIntegration(_mysqlIntegration);\n"],"names":["generateInstrumentOnce","MySQLInstrumentation","defineIntegration"],"mappings":";;;;;;AAKA,MAAM,mBAAmB;MAEZ,kBAAkBA,SAAAA,sBAAsB,CAAC,kBAAkB,IAAM,IAAIC,qBAAAA,oBAAoB,CAAC,CAAA;AAEvG,MAAM,oBAAqB;IACzB,OAAO;QACL,MAAM;QACN;YACE;QACN;IACA;AACA;AAEA;;;;;;;;;;;;;CAaA,SACa,mBAAmBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 2328, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2332, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/mysql2.ts"],"sourcesContent":["import { MySQL2Instrumentation } from '@opentelemetry/instrumentation-mysql2';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration } from '@sentry/core';\nimport { addOriginToSpan, generateInstrumentOnce } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'Mysql2';\n\nexport const instrumentMysql2 = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  () =>\n    new MySQL2Instrumentation({\n      responseHook(span) {\n        addOriginToSpan(span, 'auto.db.otel.mysql2');\n      },\n    }),\n);\n\nconst _mysql2Integration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentMysql2();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [mysql2](https://www.npmjs.com/package/mysql2) library.\n *\n * For more information, see the [`mysql2Integration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/mysql2/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.mysqlIntegration()],\n * });\n * ```\n */\nexport const mysql2Integration = defineIntegration(_mysql2Integration);\n"],"names":["generateInstrumentOnce","MySQL2Instrumentation","addOriginToSpan","defineIntegration"],"mappings":";;;;;;AAKA,MAAM,mBAAmB;AAElB,MAAM,mBAAmBA,SAAAA,sBAAsB,CACpD,kBACA,IACE,IAAIC,sBAAAA,qBAAqB,CAAC;QACxB,cAAa,IAAI;YACfC,SAAAA,eAAe,CAAC,MAAM;QAC9B;IACA;AAGA,MAAM,qBAAsB;IAC1B,OAAO;QACL,MAAM;QACN;YACE;QACN;IACA;AACA;AAEA;;;;;;;;;;;;;CAaA,SACa,oBAAoBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 2368, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2372, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/utils/redisCache.ts"],"sourcesContent":["import type { CommandArgs as IORedisCommandArgs } from '@opentelemetry/instrumentation-ioredis';\n\nconst SINGLE_ARG_COMMANDS = ['get', 'set', 'setex'];\n\nexport const GET_COMMANDS = ['get', 'mget'];\nexport const SET_COMMANDS = ['set', 'setex'];\n// todo: del, expire\n\n/** Checks if a given command is in the list of redis commands.\n *  Useful because commands can come in lowercase or uppercase (depending on the library). */\nexport function isInCommands(redisCommands: string[], command: string): boolean {\n  return redisCommands.includes(command.toLowerCase());\n}\n\n/** Determine cache operation based on redis statement */\nexport function getCacheOperation(\n  command: string,\n): 'cache.get' | 'cache.put' | 'cache.remove' | 'cache.flush' | undefined {\n  if (isInCommands(GET_COMMANDS, command)) {\n    return 'cache.get';\n  } else if (isInCommands(SET_COMMANDS, command)) {\n    return 'cache.put';\n  } else {\n    return undefined;\n  }\n}\n\nfunction keyHasPrefix(key: string, prefixes: string[]): boolean {\n  return prefixes.some(prefix => key.startsWith(prefix));\n}\n\n/** Safely converts a redis key to a string (comma-separated if there are multiple keys) */\nexport function getCacheKeySafely(redisCommand: string, cmdArgs: IORedisCommandArgs): string[] | undefined {\n  try {\n    if (cmdArgs.length === 0) {\n      return undefined;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const processArg = (arg: string | Buffer | number | any[]): string[] => {\n      if (typeof arg === 'string' || typeof arg === 'number' || Buffer.isBuffer(arg)) {\n        return [arg.toString()];\n      } else if (Array.isArray(arg)) {\n        return flatten(arg.map(arg => processArg(arg)));\n      } else {\n        return ['<unknown>'];\n      }\n    };\n\n    const firstArg = cmdArgs[0];\n    if (isInCommands(SINGLE_ARG_COMMANDS, redisCommand) && firstArg != null) {\n      return processArg(firstArg);\n    }\n\n    return flatten(cmdArgs.map(arg => processArg(arg)));\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/** Determines whether a redis operation should be considered as \"cache operation\" by checking if a key is prefixed.\n *  We only support certain commands (such as 'set', 'get', 'mget'). */\nexport function shouldConsiderForCache(redisCommand: string, keys: string[], prefixes: string[]): boolean {\n  if (!getCacheOperation(redisCommand)) {\n    return false;\n  }\n\n  for (const key of keys) {\n    if (keyHasPrefix(key, prefixes)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/** Calculates size based on the cache response value */\nexport function calculateCacheItemSize(response: unknown): number | undefined {\n  const getSize = (value: unknown): number | undefined => {\n    try {\n      if (Buffer.isBuffer(value)) return value.byteLength;\n      else if (typeof value === 'string') return value.length;\n      else if (typeof value === 'number') return value.toString().length;\n      else if (value === null || value === undefined) return 0;\n      return JSON.stringify(value).length;\n    } catch (e) {\n      return undefined;\n    }\n  };\n\n  return Array.isArray(response)\n    ? response.reduce((acc: number | undefined, curr) => {\n        const size = getSize(curr);\n        return typeof size === 'number' ? (acc !== undefined ? acc + size : size) : acc;\n      }, 0)\n    : getSize(response);\n}\n\ntype NestedArray<T> = Array<NestedArray<T> | T>;\n\nfunction flatten<T>(input: NestedArray<T>): T[] {\n  const result: T[] = [];\n\n  const flattenHelper = (input: NestedArray<T>): void => {\n    input.forEach((el: T | NestedArray<T>) => {\n      if (Array.isArray(el)) {\n        flattenHelper(el as NestedArray<T>);\n      } else {\n        result.push(el as T);\n      }\n    });\n  };\n\n  flattenHelper(input);\n  return result;\n}\n"],"names":[],"mappings":";;;AAEA,MAAM,sBAAsB;IAAC;IAAO;IAAO;CAAQ;MAEtC,eAAe;IAAC;IAAO;CAAM;MAC7B,eAAe;IAAC;IAAO;CAAO;AAC3C,oBAAA;AAEA;2FACA,GACO,SAAS,aAAa,aAAa,EAAY,OAAO;IAC3D,OAAO,cAAc,QAAQ,CAAC,QAAQ,WAAW;AACnD;AAEA,uDAAA,GACO,SAAS,kBACd,OAAO;IAEP,IAAI,aAAa,cAAc,UAAU;QACvC,OAAO;IACX,OAAS,IAAI,aAAa,cAAc,UAAU;QAC9C,OAAO;IACX,OAAS;QACL,OAAO;IACX;AACA;AAEA,SAAS,aAAa,GAAG,EAAU,QAAQ;IACzC,OAAO,SAAS,IAAI,CAAC,CAAA,SAAU,IAAI,UAAU,CAAC;AAChD;AAEA,yFAAA,GACO,SAAS,kBAAkB,YAAY,EAAU,OAAO;IAC7D,IAAI;QACF,IAAI,QAAQ,MAAA,KAAW,GAAG;YACxB,OAAO;QACb;QAEA,8DAAA;QACI,MAAM,aAAa,CAAC;YAClB,IAAI,OAAO,QAAQ,YAAY,OAAO,QAAQ,YAAY,OAAO,QAAQ,CAAC,MAAM;gBAC9E,OAAO;oBAAC,IAAI,QAAQ;iBAAG;YAC/B,OAAa,IAAI,MAAM,OAAO,CAAC,MAAM;gBAC7B,OAAO,QAAQ,IAAI,GAAG,CAAC,CAAA,MAAO,WAAW;YACjD,OAAa;gBACL,OAAO;oBAAC;iBAAY;YAC5B;QACA;QAEI,MAAM,WAAW,OAAO,CAAC,EAAE;QAC3B,IAAI,aAAa,qBAAqB,iBAAiB,YAAY,MAAM;YACvE,OAAO,WAAW;QACxB;QAEI,OAAO,QAAQ,QAAQ,GAAG,CAAC,CAAA,MAAO,WAAW;IACjD,EAAI,OAAO,GAAG;QACV,OAAO;IACX;AACA;AAEA;qEACA,GACO,SAAS,uBAAuB,YAAY,EAAU,IAAI,EAAY,QAAQ;IACnF,IAAI,CAAC,kBAAkB,eAAe;QACpC,OAAO;IACX;IAEE,KAAK,MAAM,OAAO,KAAM;QACtB,IAAI,aAAa,KAAK,WAAW;YAC/B,OAAO;QACb;IACA;IACE,OAAO;AACT;AAEA,sDAAA,GACO,SAAS,uBAAuB,QAAQ;IAC7C,MAAM,UAAU,CAAC;QACf,IAAI;YACF,IAAI,OAAO,QAAQ,CAAC,QAAQ,OAAO,MAAM,UAAU;iBAC9C,IAAI,OAAO,UAAU,UAAU,OAAO,MAAM,MAAM;iBAClD,IAAI,OAAO,UAAU,UAAU,OAAO,MAAM,QAAQ,GAAG,MAAM;iBAC7D,IAAI,UAAU,QAAQ,UAAU,WAAW,OAAO;YACvD,OAAO,KAAK,SAAS,CAAC,OAAO,MAAM;QACzC,EAAM,OAAO,GAAG;YACV,OAAO;QACb;IACA;IAEE,OAAO,MAAM,OAAO,CAAC,YACjB,SAAS,MAAM,CAAC,CAAC,KAAyB;QACxC,MAAM,OAAO,QAAQ;QACrB,OAAO,OAAO,SAAS,WAAY,QAAQ,YAAY,MAAM,OAAO,OAAQ;IACpF,GAAS,KACH,QAAQ;AACd;AAIA,SAAS,QAAW,KAAK;IACvB,MAAM,SAAc,EAAE;IAEtB,MAAM,gBAAgB,CAAC;QACrB,MAAM,OAAO,CAAC,CAAC;YACb,IAAI,MAAM,OAAO,CAAC,KAAK;gBACrB,cAAc;YACtB,OAAa;gBACL,OAAO,IAAI,CAAC;YACpB;QACA;IACA;IAEE,cAAc;IACd,OAAO;AACT"}},
    {"offset": {"line": 2483, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2487, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/redis.ts"],"sourcesContent":["import type { Span } from '@opentelemetry/api';\nimport type { RedisResponseCustomAttributeFunction } from '@opentelemetry/instrumentation-ioredis';\nimport { IORedisInstrumentation } from '@opentelemetry/instrumentation-ioredis';\nimport { RedisInstrumentation } from '@opentelemetry/instrumentation-redis-4';\nimport type { IntegrationFn } from '@sentry/core';\nimport {\n  defineIntegration,\n  SEMANTIC_ATTRIBUTE_CACHE_HIT,\n  SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE,\n  SEMANTIC_ATTRIBUTE_CACHE_KEY,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  spanToJSON,\n  truncate,\n} from '@sentry/core';\nimport { generateInstrumentOnce } from '@sentry/node-core';\nimport {\n  calculateCacheItemSize,\n  GET_COMMANDS,\n  getCacheKeySafely,\n  getCacheOperation,\n  isInCommands,\n  shouldConsiderForCache,\n} from '../../utils/redisCache';\n\ninterface RedisOptions {\n  cachePrefixes?: string[];\n}\n\nconst INTEGRATION_NAME = 'Redis';\n\nlet _redisOptions: RedisOptions = {};\n\nconst cacheResponseHook: RedisResponseCustomAttributeFunction = (span: Span, redisCommand, cmdArgs, response) => {\n  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.redis');\n\n  const safeKey = getCacheKeySafely(redisCommand, cmdArgs);\n  const cacheOperation = getCacheOperation(redisCommand);\n\n  if (\n    !safeKey ||\n    !cacheOperation ||\n    !_redisOptions.cachePrefixes ||\n    !shouldConsiderForCache(redisCommand, safeKey, _redisOptions.cachePrefixes)\n  ) {\n    // not relevant for cache\n    return;\n  }\n\n  // otel/ioredis seems to be using the old standard, as there was a change to those params: https://github.com/open-telemetry/opentelemetry-specification/issues/3199\n  // We are using params based on the docs: https://opentelemetry.io/docs/specs/semconv/attributes-registry/network/\n  const networkPeerAddress = spanToJSON(span).data['net.peer.name'];\n  const networkPeerPort = spanToJSON(span).data['net.peer.port'];\n  if (networkPeerPort && networkPeerAddress) {\n    span.setAttributes({ 'network.peer.address': networkPeerAddress, 'network.peer.port': networkPeerPort });\n  }\n\n  const cacheItemSize = calculateCacheItemSize(response);\n\n  if (cacheItemSize) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE, cacheItemSize);\n  }\n\n  if (isInCommands(GET_COMMANDS, redisCommand) && cacheItemSize !== undefined) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_HIT, cacheItemSize > 0);\n  }\n\n  span.setAttributes({\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: cacheOperation,\n    [SEMANTIC_ATTRIBUTE_CACHE_KEY]: safeKey,\n  });\n\n  const spanDescription = safeKey.join(', ');\n\n  span.updateName(truncate(spanDescription, 1024));\n};\n\nconst instrumentIORedis = generateInstrumentOnce('IORedis', () => {\n  return new IORedisInstrumentation({\n    responseHook: cacheResponseHook,\n  });\n});\n\nconst instrumentRedis4 = generateInstrumentOnce('Redis-4', () => {\n  return new RedisInstrumentation({\n    responseHook: cacheResponseHook,\n  });\n});\n\n/** To be able to preload all Redis OTel instrumentations with just one ID (\"Redis\"), all the instrumentations are generated in this one function  */\nexport const instrumentRedis = Object.assign(\n  (): void => {\n    instrumentIORedis();\n    instrumentRedis4();\n\n    // todo: implement them gradually\n    // new LegacyRedisInstrumentation({}),\n  },\n  { id: INTEGRATION_NAME },\n);\n\nconst _redisIntegration = ((options: RedisOptions = {}) => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      _redisOptions = options;\n      instrumentRedis();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [redis](https://www.npmjs.com/package/redis) and\n * [ioredis](https://www.npmjs.com/package/ioredis) libraries.\n *\n * For more information, see the [`redisIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/redis/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.redisIntegration()],\n * });\n * ```\n */\nexport const redisIntegration = defineIntegration(_redisIntegration);\n"],"names":["SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","getCacheKeySafely","getCacheOperation","shouldConsiderForCache","spanToJSON","calculateCacheItemSize","SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE","isInCommands","GET_COMMANDS","SEMANTIC_ATTRIBUTE_CACHE_HIT","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_CACHE_KEY","truncate","generateInstrumentOnce","IORedisInstrumentation","RedisInstrumentation","defineIntegration"],"mappings":";;;;;;;;AA6BA,MAAM,mBAAmB;AAEzB,IAAI,gBAA8B,CAAA;AAElC,MAAM,oBAA0D,CAAC,MAAY,cAAc,SAAS;IAClG,KAAK,YAAY,CAACA,KAAAA,gCAAgC,EAAE;IAEpD,MAAM,UAAUC,WAAAA,iBAAiB,CAAC,cAAc;IAChD,MAAM,iBAAiBC,WAAAA,iBAAiB,CAAC;IAEzC,IACE,CAAC,WACD,CAAC,kBACD,CAAC,cAAc,aAAA,IACf,CAACC,WAAAA,sBAAsB,CAAC,cAAc,SAAS,cAAc,aAAa,GAC1E;QACJ,yBAAA;QACI;IACJ;IAEA,oKAAA;IACA,kHAAA;IACE,MAAM,qBAAqBC,KAAAA,UAAU,CAAC,MAAM,IAAI,CAAC,gBAAgB;IACjE,MAAM,kBAAkBA,KAAAA,UAAU,CAAC,MAAM,IAAI,CAAC,gBAAgB;IAC9D,IAAI,mBAAmB,oBAAoB;QACzC,KAAK,aAAa,CAAC;YAAE,wBAAwB;YAAoB,qBAAqB;QAAA;IAC1F;IAEE,MAAM,gBAAgBC,WAAAA,sBAAsB,CAAC;IAE7C,IAAI,eAAe;QACjB,KAAK,YAAY,CAACC,KAAAA,kCAAkC,EAAE;IAC1D;IAEE,IAAIC,WAAAA,YAAY,CAACC,WAAAA,YAAY,EAAE,iBAAiB,kBAAkB,WAAW;QAC3E,KAAK,YAAY,CAACC,KAAAA,4BAA4B,EAAE,gBAAgB;IACpE;IAEE,KAAK,aAAa,CAAC;QACjB,CAACC,KAAAA,4BAA4B,CAAA,EAAG;QAChC,CAACC,KAAAA,4BAA4B,CAAA,EAAG;IACpC;IAEE,MAAM,kBAAkB,QAAQ,IAAI,CAAC;IAErC,KAAK,UAAU,CAACC,KAAAA,QAAQ,CAAC,iBAAiB;AAC5C;AAEA,MAAM,oBAAoBC,SAAAA,sBAAsB,CAAC,WAAW;IAC1D,OAAO,IAAIC,uBAAAA,sBAAsB,CAAC;QAChC,cAAc;IAClB;AACA;AAEA,MAAM,mBAAmBD,SAAAA,sBAAsB,CAAC,WAAW;IACzD,OAAO,IAAIE,sBAAAA,oBAAoB,CAAC;QAC9B,cAAc;IAClB;AACA;AAEA,mJAAA,GACO,MAAM,kBAAkB,OAAO,MAAM,CAC1C;IACE;IACA;AAEJ,iCAAA;AACA,sCAAA;AACA,GACE;IAAE,IAAI;AAAA;AAGR,MAAM,oBAAqB,CAAC,UAAwB,CAAA,CAAE;IACpD,OAAO;QACL,MAAM;QACN;YACE,gBAAgB;YAChB;QACN;IACA;AACA;AAEA;;;;;;;;;;;;;;CAcA,SACa,mBAAmBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 2573, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2577, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/postgres.ts"],"sourcesContent":["import { PgInstrumentation } from '@opentelemetry/instrumentation-pg';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration } from '@sentry/core';\nimport { addOriginToSpan, generateInstrumentOnce } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'Postgres';\n\nexport const instrumentPostgres = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  () =>\n    new PgInstrumentation({\n      requireParentSpan: true,\n      requestHook(span) {\n        addOriginToSpan(span, 'auto.db.otel.postgres');\n      },\n    }),\n);\n\nconst _postgresIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentPostgres();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [pg](https://www.npmjs.com/package/pg) library.\n *\n * For more information, see the [`postgresIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/postgres/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.postgresIntegration()],\n * });\n * ```\n */\nexport const postgresIntegration = defineIntegration(_postgresIntegration);\n"],"names":["generateInstrumentOnce","PgInstrumentation","addOriginToSpan","defineIntegration"],"mappings":";;;;;;AAKA,MAAM,mBAAmB;AAElB,MAAM,qBAAqBA,SAAAA,sBAAsB,CACtD,kBACA,IACE,IAAIC,kBAAAA,iBAAiB,CAAC;QACpB,mBAAmB;QACnB,aAAY,IAAI;YACdC,SAAAA,eAAe,CAAC,MAAM;QAC9B;IACA;AAGA,MAAM,uBAAwB;IAC5B,OAAO;QACL,MAAM;QACN;YACE;QACN;IACA;AACA;AAEA;;;;;;;;;;;;;CAaA,SACa,sBAAsBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 2614, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2618, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/postgresjs.ts"],"sourcesContent":["// Instrumentation for https://github.com/porsager/postgres\nimport { context, trace } from '@opentelemetry/api';\nimport type { InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport {\n  InstrumentationBase,\n  InstrumentationNodeModuleDefinition,\n  InstrumentationNodeModuleFile,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport {\n  ATTR_DB_NAMESPACE,\n  ATTR_DB_OPERATION_NAME,\n  ATTR_DB_QUERY_TEXT,\n  ATTR_DB_RESPONSE_STATUS_CODE,\n  ATTR_DB_SYSTEM_NAME,\n  ATTR_ERROR_TYPE,\n  ATTR_SERVER_ADDRESS,\n  ATTR_SERVER_PORT,\n} from '@opentelemetry/semantic-conventions';\nimport type { IntegrationFn, Span } from '@sentry/core';\nimport {\n  defineIntegration,\n  getCurrentScope,\n  logger,\n  SDK_VERSION,\n  SPAN_STATUS_ERROR,\n  startSpanManual,\n} from '@sentry/core';\nimport { addOriginToSpan, generateInstrumentOnce } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'PostgresJs';\nconst SUPPORTED_VERSIONS = ['>=3.0.0 <4'];\n\ntype PostgresConnectionContext = {\n  ATTR_DB_NAMESPACE?: string; // Database name\n  ATTR_SERVER_ADDRESS?: string; // Hostname or IP address of the database server\n  ATTR_SERVER_PORT?: string; // Port number of the database server\n};\n\ntype PostgresJsInstrumentationConfig = InstrumentationConfig & {\n  /**\n   * Whether to require a parent span for the instrumentation.\n   * If set to true, the instrumentation will only create spans if there is a parent span\n   * available in the current scope.\n   * @default true\n   */\n  requireParentSpan?: boolean;\n  /**\n   * Hook to modify the span before it is started.\n   * This can be used to set additional attributes or modify the span in any way.\n   */\n  requestHook?: (span: Span, sanitizedSqlQuery: string, postgresConnectionContext?: PostgresConnectionContext) => void;\n};\n\nexport const instrumentPostgresJs = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  (options?: PostgresJsInstrumentationConfig) =>\n    new PostgresJsInstrumentation({\n      requireParentSpan: options?.requireParentSpan ?? true,\n      requestHook: options?.requestHook,\n    }),\n);\n\n/**\n * Instrumentation for the [postgres](https://www.npmjs.com/package/postgres) library.\n * This instrumentation captures postgresjs queries and their attributes,\n */\nexport class PostgresJsInstrumentation extends InstrumentationBase<PostgresJsInstrumentationConfig> {\n  public constructor(config: PostgresJsInstrumentationConfig) {\n    super('sentry-postgres-js', SDK_VERSION, config);\n  }\n\n  /**\n   * Initializes the instrumentation.\n   */\n  public init(): InstrumentationNodeModuleDefinition[] {\n    const instrumentationModule = new InstrumentationNodeModuleDefinition('postgres', SUPPORTED_VERSIONS);\n\n    ['src', 'cf/src', 'cjs/src'].forEach(path => {\n      instrumentationModule.files.push(\n        new InstrumentationNodeModuleFile(\n          `postgres/${path}/connection.js`,\n          ['*'],\n          this._patchConnection.bind(this),\n          this._unwrap.bind(this),\n        ),\n      );\n\n      instrumentationModule.files.push(\n        new InstrumentationNodeModuleFile(\n          `postgres/${path}/query.js`,\n          SUPPORTED_VERSIONS,\n          this._patchQuery.bind(this),\n          this._unwrap.bind(this),\n        ),\n      );\n    });\n\n    return [instrumentationModule];\n  }\n\n  /**\n   * Determines whether a span should be created based on the current context.\n   * If `requireParentSpan` is set to true in the configuration, a span will\n   * only be created if there is a parent span available.\n   */\n  private _shouldCreateSpans(): boolean {\n    const config = this.getConfig();\n    const hasParentSpan = trace.getSpan(context.active()) !== undefined;\n    return hasParentSpan || !config.requireParentSpan;\n  }\n\n  /**\n   * Patches the reject method of the Query class to set the span status and end it\n   */\n  private _patchReject(rejectTarget: any, span: Span): any {\n    return new Proxy(rejectTarget, {\n      apply: (\n        rejectTarget,\n        rejectThisArg,\n        rejectArgs: {\n          message?: string;\n          code?: string;\n          name?: string;\n        }[],\n      ) => {\n        span.setStatus({\n          code: SPAN_STATUS_ERROR,\n          // This message is the error message from the rejectArgs, when available\n          // e.g \"relation 'User' does not exist\"\n          message: rejectArgs?.[0]?.message || 'unknown_error',\n        });\n\n        const result = Reflect.apply(rejectTarget, rejectThisArg, rejectArgs);\n\n        // This status code is PG error code, e.g. '42P01' for \"relation does not exist\"\n        // https://www.postgresql.org/docs/current/errcodes-appendix.html\n        span.setAttribute(ATTR_DB_RESPONSE_STATUS_CODE, rejectArgs?.[0]?.code || 'Unknown error');\n        // This is the error type, e.g. 'PostgresError' for a Postgres error\n        span.setAttribute(ATTR_ERROR_TYPE, rejectArgs?.[0]?.name || 'Unknown error');\n\n        span.end();\n        return result;\n      },\n    });\n  }\n\n  /**\n   * Patches the resolve method of the Query class to end the span when the query is resolved.\n   */\n  private _patchResolve(resolveTarget: any, span: Span): any {\n    return new Proxy(resolveTarget, {\n      apply: (resolveTarget, resolveThisArg, resolveArgs: [{ command?: string }]) => {\n        const result = Reflect.apply(resolveTarget, resolveThisArg, resolveArgs);\n        const sqlCommand = resolveArgs?.[0]?.command;\n\n        if (sqlCommand) {\n          // SQL command is only available when the query is resolved successfully\n          span.setAttribute(ATTR_DB_OPERATION_NAME, sqlCommand);\n        }\n        span.end();\n        return result;\n      },\n    });\n  }\n\n  /**\n   * Patches the Query class to instrument the handle method.\n   */\n  private _patchQuery(moduleExports: {\n    Query: {\n      prototype: {\n        handle: any;\n      };\n    };\n  }): any {\n    moduleExports.Query.prototype.handle = new Proxy(moduleExports.Query.prototype.handle, {\n      apply: async (\n        handleTarget,\n        handleThisArg: {\n          resolve: any;\n          reject: any;\n          strings?: string[];\n        },\n        handleArgs,\n      ) => {\n        if (!this._shouldCreateSpans()) {\n          // If we don't need to create spans, just call the original method\n          return Reflect.apply(handleTarget, handleThisArg, handleArgs);\n        }\n\n        const sanitizedSqlQuery = this._sanitizeSqlQuery(handleThisArg.strings?.[0]);\n\n        return startSpanManual(\n          {\n            name: sanitizedSqlQuery || 'postgresjs.query',\n            op: 'db',\n          },\n          (span: Span) => {\n            const scope = getCurrentScope();\n            const postgresConnectionContext = scope.getScopeData().contexts['postgresjsConnection'] as\n              | PostgresConnectionContext\n              | undefined;\n\n            addOriginToSpan(span, 'auto.db.otel.postgres');\n\n            const { requestHook } = this.getConfig();\n\n            if (requestHook) {\n              safeExecuteInTheMiddle(\n                () => requestHook(span, sanitizedSqlQuery, postgresConnectionContext),\n                error => {\n                  if (error) {\n                    logger.error(`Error in requestHook for ${INTEGRATION_NAME} integration:`, error);\n                  }\n                },\n              );\n            }\n\n            // ATTR_DB_NAMESPACE is used to indicate the database name and the schema name\n            // It's only the database name as we don't have the schema information\n            const databaseName = postgresConnectionContext?.ATTR_DB_NAMESPACE || '<unknown database>';\n            const databaseHost = postgresConnectionContext?.ATTR_SERVER_ADDRESS || '<unknown host>';\n            const databasePort = postgresConnectionContext?.ATTR_SERVER_PORT || '<unknown port>';\n\n            span.setAttribute(ATTR_DB_SYSTEM_NAME, 'postgres');\n            span.setAttribute(ATTR_DB_NAMESPACE, databaseName);\n            span.setAttribute(ATTR_SERVER_ADDRESS, databaseHost);\n            span.setAttribute(ATTR_SERVER_PORT, databasePort);\n            span.setAttribute(ATTR_DB_QUERY_TEXT, sanitizedSqlQuery);\n\n            handleThisArg.resolve = this._patchResolve(handleThisArg.resolve, span);\n            handleThisArg.reject = this._patchReject(handleThisArg.reject, span);\n\n            try {\n              return Reflect.apply(handleTarget, handleThisArg, handleArgs);\n            } catch (error) {\n              span.setStatus({\n                code: SPAN_STATUS_ERROR,\n              });\n              span.end();\n              throw error; // Re-throw the error to propagate it\n            }\n          },\n        );\n      },\n    });\n\n    return moduleExports;\n  }\n\n  /**\n   * Patches the Connection class to set the database, host, and port attributes\n   * when a new connection is created.\n   */\n  private _patchConnection(Connection: any): any {\n    return new Proxy(Connection, {\n      apply: (connectionTarget, thisArg, connectionArgs: { database: string; host: string[]; port: number[] }[]) => {\n        const databaseName = connectionArgs[0]?.database || '<unknown database>';\n        const databaseHost = connectionArgs[0]?.host?.[0] || '<unknown host>';\n        const databasePort = connectionArgs[0]?.port?.[0] || '<unknown port>';\n\n        const scope = getCurrentScope();\n        scope.setContext('postgresjsConnection', {\n          ATTR_DB_NAMESPACE: databaseName,\n          ATTR_SERVER_ADDRESS: databaseHost,\n          ATTR_SERVER_PORT: databasePort,\n        });\n\n        return Reflect.apply(connectionTarget, thisArg, connectionArgs);\n      },\n    });\n  }\n\n  /**\n   * Sanitize SQL query as per the OTEL semantic conventions\n   * https://opentelemetry.io/docs/specs/semconv/database/database-spans/#sanitization-of-dbquerytext\n   */\n  private _sanitizeSqlQuery(sqlQuery: string | undefined): string {\n    if (!sqlQuery) {\n      return 'Unknown SQL Query';\n    }\n\n    return (\n      sqlQuery\n        .replace(/\\s+/g, ' ')\n        .trim() // Remove extra spaces including newlines and trim\n        .substring(0, 1024) // Truncate to 1024 characters\n        .replace(/--.*?(\\r?\\n|$)/g, '') // Single line comments\n        .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '') // Multi-line comments\n        .replace(/;\\s*$/, '') // Remove trailing semicolons\n        .replace(/\\b\\d+\\b/g, '?') // Replace standalone numbers\n        // Collapse whitespace to a single space\n        .replace(/\\s+/g, ' ')\n        // Collapse IN and in clauses\n        // eg. IN (?, ?, ?, ?) to IN (?)\n        .replace(/\\bIN\\b\\s*\\(\\s*\\?(?:\\s*,\\s*\\?)*\\s*\\)/g, 'IN (?)')\n    );\n  }\n}\n\nconst _postgresJsIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentPostgresJs();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [postgres](https://www.npmjs.com/package/postgres) library.\n *\n * For more information, see the [`postgresIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/postgres/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.postgresJsIntegration()],\n * });\n * ```\n */\n\nexport const postgresJsIntegration = defineIntegration(_postgresJsIntegration);\n"],"names":["generateInstrumentOnce","InstrumentationBase","SDK_VERSION","InstrumentationNodeModuleDefinition","InstrumentationNodeModuleFile","trace","context","SPAN_STATUS_ERROR","ATTR_DB_RESPONSE_STATUS_CODE","ATTR_ERROR_TYPE","ATTR_DB_OPERATION_NAME","startSpanManual","getCurrentScope","addOriginToSpan","safeExecuteInTheMiddle","logger","ATTR_DB_SYSTEM_NAME","ATTR_DB_NAMESPACE","ATTR_SERVER_ADDRESS","ATTR_SERVER_PORT","ATTR_DB_QUERY_TEXT","defineIntegration"],"mappings":"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"}},
    {"offset": {"line": 2821, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2825, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/prisma.ts"],"sourcesContent":["import type { Instrumentation } from '@opentelemetry/instrumentation';\nimport { PrismaInstrumentation } from '@prisma/instrumentation';\nimport { consoleSandbox, defineIntegration, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, spanToJSON } from '@sentry/core';\nimport { generateInstrumentOnce } from '@sentry/node-core';\nimport type { PrismaV5TracingHelper } from './prisma/vendor/v5-tracing-helper';\nimport type { PrismaV6TracingHelper } from './prisma/vendor/v6-tracing-helper';\n\nconst INTEGRATION_NAME = 'Prisma';\n\ntype CompatibilityLayerTraceHelper = PrismaV5TracingHelper & PrismaV6TracingHelper;\n\nfunction isPrismaV6TracingHelper(helper: unknown): helper is PrismaV6TracingHelper {\n  return !!helper && typeof helper === 'object' && 'dispatchEngineSpans' in helper;\n}\n\nfunction getPrismaTracingHelper(): unknown | undefined {\n  const prismaInstrumentationObject = (globalThis as Record<string, unknown>).PRISMA_INSTRUMENTATION;\n  const prismaTracingHelper =\n    prismaInstrumentationObject &&\n    typeof prismaInstrumentationObject === 'object' &&\n    'helper' in prismaInstrumentationObject\n      ? prismaInstrumentationObject.helper\n      : undefined;\n\n  return prismaTracingHelper;\n}\n\nclass SentryPrismaInteropInstrumentation extends PrismaInstrumentation {\n  public constructor() {\n    super();\n  }\n\n  public enable(): void {\n    super.enable();\n\n    // The PrismaIntegration (super class) defines a global variable `global[\"PRISMA_INSTRUMENTATION\"]` when `enable()` is called. This global variable holds a \"TracingHelper\" which Prisma uses internally to create tracing data. It's their way of not depending on OTEL with their main package. The sucky thing is, prisma broke the interface of the tracing helper with the v6 major update. This means that if you use Prisma 5 with the v6 instrumentation (or vice versa) Prisma just blows up, because tries to call methods on the helper that no longer exist.\n    // Because we actually want to use the v6 instrumentation and not blow up in Prisma 5 user's faces, what we're doing here is backfilling the v5 method (`createEngineSpan`) with a noop so that no longer crashes when it attempts to call that function.\n    // We still won't fully emit all the spans, but this could potentially be implemented in the future.\n    const prismaTracingHelper = getPrismaTracingHelper();\n\n    let emittedWarning = false;\n\n    if (isPrismaV6TracingHelper(prismaTracingHelper)) {\n      (prismaTracingHelper as CompatibilityLayerTraceHelper).createEngineSpan = () => {\n        consoleSandbox(() => {\n          if (!emittedWarning) {\n            emittedWarning = true;\n            // eslint-disable-next-line no-console\n            console.warn(\n              '[Sentry] The Sentry SDK supports tracing with Prisma version 5 only with limited capabilities. For full tracing capabilities pass `prismaInstrumentation` for version 5 to the Sentry `prismaIntegration`. Read more: https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/prisma/',\n            );\n          }\n        });\n      };\n    }\n  }\n}\n\nexport const instrumentPrisma = generateInstrumentOnce<{ prismaInstrumentation?: Instrumentation }>(\n  INTEGRATION_NAME,\n  options => {\n    // Use a passed instrumentation instance to support older Prisma versions\n    if (options?.prismaInstrumentation) {\n      return options.prismaInstrumentation;\n    }\n\n    return new SentryPrismaInteropInstrumentation();\n  },\n);\n\n/**\n * Adds Sentry tracing instrumentation for the [prisma](https://www.npmjs.com/package/prisma) library.\n * For more information, see the [`prismaIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/prisma/).\n *\n * NOTE: By default, this integration works with Prisma version 6.\n * To get performance instrumentation for other Prisma versions,\n * 1. Install the `@prisma/instrumentation` package with the desired version.\n * 1. Pass a `new PrismaInstrumentation()` instance as exported from `@prisma/instrumentation` to the `prismaInstrumentation` option of this integration:\n *\n *    ```js\n *    import { PrismaInstrumentation } from '@prisma/instrumentation'\n *\n *    Sentry.init({\n *      integrations: [\n *        prismaIntegration({\n *          // Override the default instrumentation that Sentry uses\n *          prismaInstrumentation: new PrismaInstrumentation()\n *        })\n *      ]\n *    })\n *    ```\n *\n *    The passed instrumentation instance will override the default instrumentation instance the integration would use, while the `prismaIntegration` will still ensure data compatibility for the various Prisma versions.\n * 1. Depending on your Prisma version (prior to version 6), add `previewFeatures = [\"tracing\"]` to the client generator block of your Prisma schema:\n *\n *    ```\n *    generator client {\n *      provider = \"prisma-client-js\"\n *      previewFeatures = [\"tracing\"]\n *    }\n *    ```\n */\nexport const prismaIntegration = defineIntegration(\n  ({\n    prismaInstrumentation,\n  }: {\n    /**\n     * Overrides the instrumentation used by the Sentry SDK with the passed in instrumentation instance.\n     *\n     * NOTE: By default, the Sentry SDK uses the Prisma v6 instrumentation. Use this option if you need performance instrumentation different Prisma versions.\n     *\n     * For more information refer to the documentation of `prismaIntegration()` or see https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/prisma/\n     */\n    prismaInstrumentation?: Instrumentation;\n  } = {}) => {\n    return {\n      name: INTEGRATION_NAME,\n      setupOnce() {\n        instrumentPrisma({ prismaInstrumentation });\n      },\n      setup(client) {\n        // If no tracing helper exists, we skip any work here\n        // this means that prisma is not being used\n        if (!getPrismaTracingHelper()) {\n          return;\n        }\n\n        client.on('spanStart', span => {\n          const spanJSON = spanToJSON(span);\n          if (spanJSON.description?.startsWith('prisma:')) {\n            span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.prisma');\n          }\n\n          // Make sure we use the query text as the span name, for ex. SELECT * FROM \"User\" WHERE \"id\" = $1\n          if (spanJSON.description === 'prisma:engine:db_query' && spanJSON.data['db.query.text']) {\n            span.updateName(spanJSON.data['db.query.text'] as string);\n          }\n\n          // In Prisma v5.22+, the `db.system` attribute is automatically set\n          // On older versions, this is missing, so we add it here\n          if (spanJSON.description === 'prisma:engine:db_query' && !spanJSON.data['db.system']) {\n            span.setAttribute('db.system', 'prisma');\n          }\n        });\n      },\n    };\n  },\n);\n"],"names":["PrismaInstrumentation","consoleSandbox","generateInstrumentOnce","defineIntegration","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN"],"mappings":";;;;;;AAOA,MAAM,mBAAmB;AAIzB,SAAS,wBAAwB,MAAM;IACrC,OAAO,CAAC,CAAC,UAAU,OAAO,WAAW,YAAY,yBAAyB;AAC5E;AAEA,SAAS;IACP,MAAM,8BAA8B,AAAC,WAAuC,sBAAsB;IAClG,MAAM,sBACJ,+BACA,OAAO,gCAAgC,YACvC,YAAY,8BACR,4BAA4B,MAAA,GAC5B;IAEN,OAAO;AACT;AAEA,MAAM,2CAA2CA,gBAAAA,qBAAA;IACxC,aAAc;QACnB,KAAK;IACT;IAES,SAAe;QACpB,KAAK,CAAC;QAEV,wiBAAA;QACA,yPAAA;QACA,oGAAA;QACI,MAAM,sBAAsB;QAE5B,IAAI,iBAAiB;QAErB,IAAI,wBAAwB,sBAAsB;YAC/C,oBAAsD,gBAAA,GAAmB;gBACxEC,KAAAA,cAAc,CAAC;oBACb,IAAI,CAAC,gBAAgB;wBACnB,iBAAiB;wBAC7B,sCAAA;wBACY,QAAQ,IAAI,CACV;oBAEd;gBACA;YACA;QACA;IACA;AACA;AAEO,MAAM,mBAAmBC,SAAAA,sBAAsB,CACpD,kBACA,CAAA;IACF,yEAAA;IACI,IAAI,SAAS,uBAAuB;QAClC,OAAO,QAAQ,qBAAqB;IAC1C;IAEI,OAAO,IAAI;AACf;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+BA,GACO,MAAM,oBAAoBC,KAAAA,iBAAiB,CAChD,CAAC,EACC,qBAAqB,EACzB,GASM,CAAA,CAAE;IACJ,OAAO;QACL,MAAM;QACN;YACE,iBAAiB;gBAAE;YAAA;QAC3B;QACM,OAAM,MAAM;YAClB,qDAAA;YACA,2CAAA;YACQ,IAAI,CAAC,0BAA0B;gBAC7B;YACV;YAEQ,OAAO,EAAE,CAAC,aAAa,CAAA;gBACrB,MAAM,WAAWC,KAAAA,UAAU,CAAC;gBAC5B,IAAI,SAAS,WAAW,EAAE,WAAW,YAAY;oBAC/C,KAAK,YAAY,CAACC,KAAAA,gCAAgC,EAAE;gBAChE;gBAEA,iGAAA;gBACU,IAAI,SAAS,WAAA,KAAgB,4BAA4B,SAAS,IAAI,CAAC,gBAAgB,EAAE;oBACvF,KAAK,UAAU,CAAC,SAAS,IAAI,CAAC,gBAAe;gBACzD;gBAEA,mEAAA;gBACA,wDAAA;gBACU,IAAI,SAAS,WAAA,KAAgB,4BAA4B,CAAC,SAAS,IAAI,CAAC,YAAY,EAAE;oBACpF,KAAK,YAAY,CAAC,aAAa;gBAC3C;YACA;QACA;IACA;AACA"}},
    {"offset": {"line": 2936, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2940, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/hapi/index.ts"],"sourcesContent":["import { HapiInstrumentation } from '@opentelemetry/instrumentation-hapi';\nimport type { IntegrationFn, Span } from '@sentry/core';\nimport {\n  captureException,\n  defineIntegration,\n  getClient,\n  getDefaultIsolationScope,\n  getIsolationScope,\n  logger,\n  SDK_VERSION,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  spanToJSON,\n} from '@sentry/core';\nimport { ensureIsWrapped, generateInstrumentOnce } from '@sentry/node-core';\nimport { DEBUG_BUILD } from '../../../debug-build';\nimport type { Request, RequestEvent, Server } from './types';\n\nconst INTEGRATION_NAME = 'Hapi';\n\nexport const instrumentHapi = generateInstrumentOnce(INTEGRATION_NAME, () => new HapiInstrumentation());\n\nconst _hapiIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentHapi();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for [Hapi](https://hapi.dev/).\n *\n * If you also want to capture errors, you need to call `setupHapiErrorHandler(server)` after you set up your server.\n *\n * For more information, see the [hapi documentation](https://docs.sentry.io/platforms/javascript/guides/hapi/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *   integrations: [Sentry.hapiIntegration()],\n * })\n * ```\n */\nexport const hapiIntegration = defineIntegration(_hapiIntegration);\n\nfunction isErrorEvent(event: unknown): event is RequestEvent {\n  return !!(event && typeof event === 'object' && 'error' in event && event.error);\n}\n\nfunction sendErrorToSentry(errorData: object): void {\n  captureException(errorData, {\n    mechanism: {\n      type: 'hapi',\n      handled: false,\n      data: {\n        function: 'hapiErrorPlugin',\n      },\n    },\n  });\n}\n\nexport const hapiErrorPlugin = {\n  name: 'SentryHapiErrorPlugin',\n  version: SDK_VERSION,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  register: async function (serverArg: Record<any, any>) {\n    const server = serverArg as unknown as Server;\n\n    server.events.on({ name: 'request', channels: ['error'] }, (request: Request, event: RequestEvent) => {\n      if (getIsolationScope() !== getDefaultIsolationScope()) {\n        const route = request.route;\n        if (route.path) {\n          getIsolationScope().setTransactionName(`${route.method.toUpperCase()} ${route.path}`);\n        }\n      } else {\n        DEBUG_BUILD &&\n          logger.warn('Isolation scope is still the default isolation scope - skipping setting transactionName');\n      }\n\n      if (isErrorEvent(event)) {\n        sendErrorToSentry(event.error);\n      }\n    });\n  },\n};\n\n/**\n * Add a Hapi plugin to capture errors to Sentry.\n *\n * @param server The Hapi server to attach the error handler to\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n * const Hapi = require('@hapi/hapi');\n *\n * const init = async () => {\n *   const server = Hapi.server();\n *\n *   // all your routes here\n *\n *   await Sentry.setupHapiErrorHandler(server);\n *\n *   await server.start();\n * };\n * ```\n */\nexport async function setupHapiErrorHandler(server: Server): Promise<void> {\n  await server.register(hapiErrorPlugin);\n\n  // Sadly, middleware spans do not go through `requestHook`, so we handle those here\n  // We register this hook in this method, because if we register it in the integration `setup`,\n  // it would always run even for users that are not even using hapi\n  const client = getClient();\n  if (client) {\n    client.on('spanStart', span => {\n      addHapiSpanAttributes(span);\n    });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  ensureIsWrapped(server.register, 'hapi');\n}\n\nfunction addHapiSpanAttributes(span: Span): void {\n  const attributes = spanToJSON(span).data;\n\n  // this is one of: router, plugin, server.ext\n  const type = attributes['hapi.type'];\n\n  // If this is already set, or we have no Hapi span, no need to process again...\n  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] || !type) {\n    return;\n  }\n\n  span.setAttributes({\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.hapi',\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${type}.hapi`,\n  });\n}\n"],"names":["generateInstrumentOnce","HapiInstrumentation","defineIntegration","captureException","SDK_VERSION","getIsolationScope","getDefaultIsolationScope","DEBUG_BUILD","logger","getClient","ensureIsWrapped","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN"],"mappings":";;;;;;;AAkBA,MAAM,mBAAmB;AAElB,MAAM,iBAAiBA,SAAAA,sBAAsB,CAAC,kBAAkB,IAAM,IAAIC,oBAAAA,mBAAmB;AAEpG,MAAM,mBAAoB;IACxB,OAAO;QACL,MAAM;QACN;YACE;QACN;IACA;AACA;AAEA;;;;;;;;;;;;;;;CAeA,SACa,kBAAkBC,KAAAA,iBAAiB,CAAC;AAEjD,SAAS,aAAa,KAAK;IACzB,OAAO,CAAC,CAAA,CAAE,SAAS,OAAO,UAAU,YAAY,WAAW,SAAS,MAAM,KAAK;AACjF;AAEA,SAAS,kBAAkB,SAAS;IAClCC,KAAAA,gBAAgB,CAAC,WAAW;QAC1B,WAAW;YACT,MAAM;YACN,SAAS;YACT,MAAM;gBACJ,UAAU;YAClB;QACA;IACA;AACA;AAEO,MAAM,kBAAkB;IAC7B,MAAM;IACN,SAASC,KAAAA,WAAW;IACtB,8DAAA;IACE,UAAU,eAAgB,SAAS;QACjC,MAAM,SAAS;QAEf,OAAO,MAAM,CAAC,EAAE,CAAC;YAAE,MAAM;YAAW,UAAU;gBAAC;aAAO;QAAA,GAAK,CAAC,SAAkB;YAC5E,IAAIC,KAAAA,iBAAiB,OAAOC,KAAAA,wBAAwB,IAAI;gBACtD,MAAM,QAAQ,QAAQ,KAAK;gBAC3B,IAAI,MAAM,IAAI,EAAE;oBACdD,KAAAA,iBAAiB,GAAG,kBAAkB,CAAC,CAAC,EAAA,MAAA,MAAA,CAAA,WAAA,GAAA,CAAA,EAAA,MAAA,IAAA,CAAA,CAAA;gBACA;YACA,OAAA;gBACAE,WAAAA,WAAA,IACAC,KAAAA,MAAA,CAAA,IAAA,CAAA;YACA;YAEA,IAAA,aAAA,QAAA;gBACA,kBAAA,MAAA,KAAA;YACA;QACA;IACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;CAoBA,GACA,eAAA,sBAAA,MAAA;IACA,MAAA,OAAA,QAAA,CAAA;IAEA,mFAAA;IACA,8FAAA;IACA,kEAAA;IACA,MAAA,SAAAC,KAAAA,SAAA;IACA,IAAA,QAAA;QACA,OAAA,EAAA,CAAA,aAAA,CAAA;YACA,sBAAA;QACA;IACA;IAEA,6DAAA;IACAC,SAAAA,eAAA,CAAA,OAAA,QAAA,EAAA;AACA;AAEA,SAAA,sBAAA,IAAA;IACA,MAAA,aAAAC,KAAAA,UAAA,CAAA,MAAA,IAAA;IAEA,6CAAA;IACA,MAAA,OAAA,UAAA,CAAA,YAAA;IAEA,+EAAA;IACA,IAAA,UAAA,CAAAC,KAAAA,4BAAA,CAAA,IAAA,CAAA,MAAA;QACA;IACA;IAEA,KAAA,aAAA,CAAA;QACA,CAAAC,KAAAA,gCAAA,CAAA,EAAA;QACA,CAAAD,KAAAA,4BAAA,CAAA,EAAA,CAAA,EAAA,KAAA,KAAA,CAAA;IACA;AACA"}},
    {"offset": {"line": 3064, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3068, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/koa.ts"],"sourcesContent":["import type { KoaInstrumentationConfig, KoaLayerType } from '@opentelemetry/instrumentation-koa';\nimport { KoaInstrumentation } from '@opentelemetry/instrumentation-koa';\nimport { ATTR_HTTP_ROUTE } from '@opentelemetry/semantic-conventions';\nimport type { IntegrationFn } from '@sentry/core';\nimport {\n  captureException,\n  defineIntegration,\n  getDefaultIsolationScope,\n  getIsolationScope,\n  logger,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  spanToJSON,\n} from '@sentry/core';\nimport { addOriginToSpan, ensureIsWrapped, generateInstrumentOnce } from '@sentry/node-core';\nimport { DEBUG_BUILD } from '../../debug-build';\n\ninterface KoaOptions {\n  /**\n   * Ignore layers of specified types\n   */\n  ignoreLayersType?: Array<'middleware' | 'router'>;\n}\n\nconst INTEGRATION_NAME = 'Koa';\n\nexport const instrumentKoa = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  KoaInstrumentation,\n  (options: KoaOptions = {}) => {\n    return {\n      ignoreLayersType: options.ignoreLayersType as KoaLayerType[],\n      requestHook(span, info) {\n        addOriginToSpan(span, 'auto.http.otel.koa');\n\n        const attributes = spanToJSON(span).data;\n\n        // this is one of: middleware, router\n        const type = attributes['koa.type'];\n        if (type) {\n          span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, `${type}.koa`);\n        }\n\n        // Also update the name\n        const name = attributes['koa.name'];\n        if (typeof name === 'string') {\n          // Somehow, name is sometimes `''` for middleware spans\n          // See: https://github.com/open-telemetry/opentelemetry-js-contrib/issues/2220\n          span.updateName(name || '< unknown >');\n        }\n\n        if (getIsolationScope() === getDefaultIsolationScope()) {\n          DEBUG_BUILD && logger.warn('Isolation scope is default isolation scope - skipping setting transactionName');\n          return;\n        }\n        const route = attributes[ATTR_HTTP_ROUTE];\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        const method = info.context?.request?.method?.toUpperCase() || 'GET';\n        if (route) {\n          getIsolationScope().setTransactionName(`${method} ${route}`);\n        }\n      },\n    } satisfies KoaInstrumentationConfig;\n  },\n);\n\nconst _koaIntegration = ((options: KoaOptions = {}) => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentKoa(options);\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for [Koa](https://koajs.com/).\n *\n * If you also want to capture errors, you need to call `setupKoaErrorHandler(app)` after you set up your Koa server.\n *\n * For more information, see the [koa documentation](https://docs.sentry.io/platforms/javascript/guides/koa/).\n *\n * @param {KoaOptions} options Configuration options for the Koa integration.\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *   integrations: [Sentry.koaIntegration()],\n * })\n * ```\n *\n * @example\n * ```javascript\n * // To ignore middleware spans\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *   integrations: [\n *     Sentry.koaIntegration({\n *       ignoreLayersType: ['middleware']\n *     })\n *   ],\n * })\n * ```\n */\nexport const koaIntegration = defineIntegration(_koaIntegration);\n\n/**\n * Add an Koa error handler to capture errors to Sentry.\n *\n * The error handler must be before any other middleware and after all controllers.\n *\n * @param app The Express instances\n * @param options {ExpressHandlerOptions} Configuration options for the handler\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n * const Koa = require(\"koa\");\n *\n * const app = new Koa();\n *\n * Sentry.setupKoaErrorHandler(app);\n *\n * // Add your routes, etc.\n *\n * app.listen(3000);\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const setupKoaErrorHandler = (app: { use: (arg0: (ctx: any, next: any) => Promise<void>) => void }): void => {\n  app.use(async (ctx, next) => {\n    try {\n      await next();\n    } catch (error) {\n      captureException(error);\n      throw error;\n    }\n  });\n\n  ensureIsWrapped(app.use, 'koa');\n};\n"],"names":["generateInstrumentOnce","KoaInstrumentation","addOriginToSpan","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_OP","getIsolationScope","getDefaultIsolationScope","DEBUG_BUILD","logger","ATTR_HTTP_ROUTE","defineIntegration","captureException","ensureIsWrapped"],"mappings":";;;;;;;;AAuBA,MAAM,mBAAmB;AAElB,MAAM,gBAAgBA,SAAAA,sBAAsB,CACjD,kBACAC,mBAAAA,kBAAkB,EAClB,CAAC,UAAsB,CAAA,CAAE;IACvB,OAAO;QACL,kBAAkB,QAAQ,gBAAA;QAC1B,aAAY,IAAI,EAAE,IAAI;YACpBC,SAAAA,eAAe,CAAC,MAAM;YAEtB,MAAM,aAAaC,KAAAA,UAAU,CAAC,MAAM,IAAI;YAEhD,qCAAA;YACQ,MAAM,OAAO,UAAU,CAAC,WAAW;YACnC,IAAI,MAAM;gBACR,KAAK,YAAY,CAACC,KAAAA,4BAA4B,EAAE,CAAC,EAAA,KAAA,IAAA,CAAA;YACA;YAEA,uBAAA;YACA,MAAA,OAAA,UAAA,CAAA,WAAA;YACA,IAAA,OAAA,SAAA,UAAA;gBACA,uDAAA;gBACA,8EAAA;gBACA,KAAA,UAAA,CAAA,QAAA;YACA;YAEA,IAAAC,KAAAA,iBAAA,OAAAC,KAAAA,wBAAA,IAAA;gBACAC,WAAAA,WAAA,IAAAC,KAAAA,MAAA,CAAA,IAAA,CAAA;gBACA;YACA;YACA,MAAA,QAAA,UAAA,CAAAC,oBAAAA,eAAA,CAAA;YACA,sEAAA;YACA,MAAA,SAAA,KAAA,OAAA,EAAA,SAAA,QAAA,iBAAA;YACA,IAAA,OAAA;gBACAJ,KAAAA,iBAAA,GAAA,kBAAA,CAAA,CAAA,EAAA,OAAA,CAAA,EAAA,MAAA,CAAA;YACA;QACA;IACA;AACA;AAGA,MAAA,kBAAA,CAAA,UAAA,CAAA,CAAA;IACA,OAAA;QACA,MAAA;QACA;YACA,cAAA;QACA;IACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+BA,GACA,MAAA,iBAAAK,KAAAA,iBAAA,CAAA;AAEA;;;;;;;;;;;;;;;;;;;;;CAqBA,GACA,8DAAA;AACA,MAAA,uBAAA,CAAA;IACA,IAAA,GAAA,CAAA,OAAA,KAAA;QACA,IAAA;YACA,MAAA;QACA,EAAA,OAAA,OAAA;YACAC,KAAAA,gBAAA,CAAA;YACA,MAAA;QACA;IACA;IAEAC,SAAAA,eAAA,CAAA,IAAA,GAAA,EAAA;AACA"}},
    {"offset": {"line": 3184, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3188, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/connect.ts"],"sourcesContent":["import { ConnectInstrumentation } from '@opentelemetry/instrumentation-connect';\nimport type { IntegrationFn, Span } from '@sentry/core';\nimport {\n  captureException,\n  defineIntegration,\n  getClient,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  spanToJSON,\n} from '@sentry/core';\nimport { ensureIsWrapped, generateInstrumentOnce } from '@sentry/node-core';\n\ntype ConnectApp = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  use: (middleware: any) => void;\n};\n\nconst INTEGRATION_NAME = 'Connect';\n\nexport const instrumentConnect = generateInstrumentOnce(INTEGRATION_NAME, () => new ConnectInstrumentation());\n\nconst _connectIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentConnect();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for [Connect](https://github.com/senchalabs/connect/).\n *\n * If you also want to capture errors, you need to call `setupConnectErrorHandler(app)` after you initialize your connect app.\n *\n * For more information, see the [connect documentation](https://docs.sentry.io/platforms/javascript/guides/connect/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *   integrations: [Sentry.connectIntegration()],\n * })\n * ```\n */\nexport const connectIntegration = defineIntegration(_connectIntegration);\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction connectErrorMiddleware(err: any, req: any, res: any, next: any): void {\n  captureException(err);\n  next(err);\n}\n\n/**\n * Add a Connect middleware to capture errors to Sentry.\n *\n * @param app The Connect app to attach the error handler to\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n * const connect = require(\"connect\");\n *\n * const app = connect();\n *\n * Sentry.setupConnectErrorHandler(app);\n *\n * // Add you connect routes here\n *\n * app.listen(3000);\n * ```\n */\nexport const setupConnectErrorHandler = (app: ConnectApp): void => {\n  app.use(connectErrorMiddleware);\n\n  // Sadly, ConnectInstrumentation has no requestHook, so we need to add the attributes here\n  // We register this hook in this method, because if we register it in the integration `setup`,\n  // it would always run even for users that are not even using connect\n  const client = getClient();\n  if (client) {\n    client.on('spanStart', span => {\n      addConnectSpanAttributes(span);\n    });\n  }\n\n  ensureIsWrapped(app.use, 'connect');\n};\n\nfunction addConnectSpanAttributes(span: Span): void {\n  const attributes = spanToJSON(span).data;\n\n  // this is one of: middleware, request_handler\n  const type = attributes['connect.type'];\n\n  // If this is already set, or we have no connect span, no need to process again...\n  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] || !type) {\n    return;\n  }\n\n  span.setAttributes({\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.connect',\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${type}.connect`,\n  });\n\n  // Also update the name, we don't need the \"middleware - \" prefix\n  const name = attributes['connect.name'];\n  if (typeof name === 'string') {\n    span.updateName(name);\n  }\n}\n"],"names":["generateInstrumentOnce","ConnectInstrumentation","defineIntegration","captureException","getClient","ensureIsWrapped","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN"],"mappings":";;;;;;AAiBA,MAAM,mBAAmB;AAElB,MAAM,oBAAoBA,SAAAA,sBAAsB,CAAC,kBAAkB,IAAM,IAAIC,uBAAAA,sBAAsB;AAE1G,MAAM,sBAAuB;IAC3B,OAAO;QACL,MAAM;QACN;YACE;QACN;IACA;AACA;AAEA;;;;;;;;;;;;;;;CAeA,SACa,qBAAqBC,KAAAA,iBAAiB,CAAC;AAEpD,8DAAA;AACA,SAAS,uBAAuB,GAAG,EAAO,GAAG,EAAO,GAAG,EAAO,IAAI;IAChEC,KAAAA,gBAAgB,CAAC;IACjB,KAAK;AACP;AAEA;;;;;;;;;;;;;;;;;;CAkBA,GACO,MAAM,2BAA2B,CAAC;IACvC,IAAI,GAAG,CAAC;IAEV,0FAAA;IACA,8FAAA;IACA,qEAAA;IACE,MAAM,SAASC,KAAAA,SAAS;IACxB,IAAI,QAAQ;QACV,OAAO,EAAE,CAAC,aAAa,CAAA;YACrB,yBAAyB;QAC/B;IACA;IAEEC,SAAAA,eAAe,CAAC,IAAI,GAAG,EAAE;AAC3B;AAEA,SAAS,yBAAyB,IAAI;IACpC,MAAM,aAAaC,KAAAA,UAAU,CAAC,MAAM,IAAI;IAE1C,8CAAA;IACE,MAAM,OAAO,UAAU,CAAC,eAAe;IAEzC,kFAAA;IACE,IAAI,UAAU,CAACC,KAAAA,4BAA4B,CAAA,IAAK,CAAC,MAAM;QACrD;IACJ;IAEE,KAAK,aAAa,CAAC;QACjB,CAACC,KAAAA,gCAAgC,CAAA,EAAG;QACpC,CAACD,KAAAA,4BAA4B,CAAA,EAAG,CAAC,EAAA,KAAA,QAAA,CAAA;IACA;IAEA,iEAAA;IACA,MAAA,OAAA,UAAA,CAAA,eAAA;IACA,IAAA,OAAA,SAAA,UAAA;QACA,KAAA,UAAA,CAAA;IACA;AACA"}},
    {"offset": {"line": 3277, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3281, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/knex.ts"],"sourcesContent":["import { KnexInstrumentation } from '@opentelemetry/instrumentation-knex';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, spanToJSON } from '@sentry/core';\nimport { generateInstrumentOnce, instrumentWhenWrapped } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'Knex';\n\nexport const instrumentKnex = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  () => new KnexInstrumentation({ requireParentSpan: true }),\n);\n\nconst _knexIntegration = (() => {\n  let instrumentationWrappedCallback: undefined | ((callback: () => void) => void);\n\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      const instrumentation = instrumentKnex();\n      instrumentationWrappedCallback = instrumentWhenWrapped(instrumentation);\n    },\n\n    setup(client) {\n      instrumentationWrappedCallback?.(() =>\n        client.on('spanStart', span => {\n          const { data } = spanToJSON(span);\n          // knex.version is always set in the span data\n          // https://github.com/open-telemetry/opentelemetry-js-contrib/blob/0309caeafc44ac9cb13a3345b790b01b76d0497d/plugins/node/opentelemetry-instrumentation-knex/src/instrumentation.ts#L138\n          if ('knex.version' in data) {\n            span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.knex');\n          }\n        }),\n      );\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Knex integration\n *\n * Capture tracing data for [Knex](https://knexjs.org/).\n *\n * @example\n * ```javascript\n * import * as Sentry from '@sentry/node';\n *\n * Sentry.init({\n *  integrations: [Sentry.knexIntegration()],\n * });\n * ```\n */\nexport const knexIntegration = defineIntegration(_knexIntegration);\n"],"names":["generateInstrumentOnce","KnexInstrumentation","instrumentWhenWrapped","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","defineIntegration"],"mappings":";;;;;;AAKA,MAAM,mBAAmB;AAElB,MAAM,iBAAiBA,SAAAA,sBAAsB,CAClD,kBACA,IAAM,IAAIC,oBAAAA,mBAAmB,CAAC;QAAE,mBAAmB;IAAA;AAGrD,MAAM,mBAAoB;IACxB,IAAI;IAEJ,OAAO;QACL,MAAM;QACN;YACE,MAAM,kBAAkB;YACxB,iCAAiCC,SAAAA,qBAAqB,CAAC;QAC7D;QAEI,OAAM,MAAM;YACV,iCAAiC,IAC/B,OAAO,EAAE,CAAC,aAAa,CAAA;oBACrB,MAAM,EAAE,IAAA,EAAK,GAAIC,KAAAA,UAAU,CAAC;oBACtC,8CAAA;oBACA,uLAAA;oBACU,IAAI,kBAAkB,MAAM;wBAC1B,KAAK,YAAY,CAACC,KAAAA,gCAAgC,EAAE;oBAChE;gBACA;QAEA;IACA;AACA;AAEA;;;;;;;;;;;;;CAaA,SACa,kBAAkBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 3327, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3331, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/tedious.ts"],"sourcesContent":["import { TediousInstrumentation } from '@opentelemetry/instrumentation-tedious';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, spanToJSON } from '@sentry/core';\nimport { generateInstrumentOnce, instrumentWhenWrapped } from '@sentry/node-core';\n\nconst TEDIUS_INSTRUMENTED_METHODS = new Set([\n  'callProcedure',\n  'execSql',\n  'execSqlBatch',\n  'execBulkLoad',\n  'prepare',\n  'execute',\n]);\n\nconst INTEGRATION_NAME = 'Tedious';\n\nexport const instrumentTedious = generateInstrumentOnce(INTEGRATION_NAME, () => new TediousInstrumentation({}));\n\nconst _tediousIntegration = (() => {\n  let instrumentationWrappedCallback: undefined | ((callback: () => void) => void);\n\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      const instrumentation = instrumentTedious();\n      instrumentationWrappedCallback = instrumentWhenWrapped(instrumentation);\n    },\n\n    setup(client) {\n      instrumentationWrappedCallback?.(() =>\n        client.on('spanStart', span => {\n          const { description, data } = spanToJSON(span);\n          // Tedius integration always set a span name and `db.system` attribute to `mssql`.\n          if (!description || data['db.system'] !== 'mssql') {\n            return;\n          }\n\n          const operation = description.split(' ')[0] || '';\n          if (TEDIUS_INSTRUMENTED_METHODS.has(operation)) {\n            span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.tedious');\n          }\n        }),\n      );\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [tedious](https://www.npmjs.com/package/tedious) library.\n *\n * For more information, see the [`tediousIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/tedious/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.tediousIntegration()],\n * });\n * ```\n */\nexport const tediousIntegration = defineIntegration(_tediousIntegration);\n"],"names":["generateInstrumentOnce","TediousInstrumentation","instrumentWhenWrapped","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","defineIntegration"],"mappings":";;;;;;AAKA,MAAM,8BAA8B,IAAI,IAAI;IAC1C;IACA;IACA;IACA;IACA;IACA;CACD;AAED,MAAM,mBAAmB;MAEZ,oBAAoBA,SAAAA,sBAAsB,CAAC,kBAAkB,IAAM,IAAIC,uBAAAA,sBAAsB,CAAC,CAAA;AAE3G,MAAM,sBAAuB;IAC3B,IAAI;IAEJ,OAAO;QACL,MAAM;QACN;YACE,MAAM,kBAAkB;YACxB,iCAAiCC,SAAAA,qBAAqB,CAAC;QAC7D;QAEI,OAAM,MAAM;YACV,iCAAiC,IAC/B,OAAO,EAAE,CAAC,aAAa,CAAA;oBACrB,MAAM,EAAE,WAAW,EAAE,IAAA,EAAA,GAASC,KAAAA,UAAU,CAAC;oBACnD,kFAAA;oBACU,IAAI,CAAC,eAAe,IAAI,CAAC,YAAW,KAAM,SAAS;wBACjD;oBACZ;oBAEU,MAAM,YAAY,YAAY,KAAK,CAAC,IAAI,CAAC,EAAC,IAAK;oBAC/C,IAAI,4BAA4B,GAAG,CAAC,YAAY;wBAC9C,KAAK,YAAY,CAACC,KAAAA,gCAAgC,EAAE;oBAChE;gBACA;QAEA;IACA;AACA;AAEA;;;;;;;;;;;;;CAaA,SACa,qBAAqBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 3386, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3390, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/genericPool.ts"],"sourcesContent":["import { GenericPoolInstrumentation } from '@opentelemetry/instrumentation-generic-pool';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, spanToJSON } from '@sentry/core';\nimport { generateInstrumentOnce, instrumentWhenWrapped } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'GenericPool';\n\nexport const instrumentGenericPool = generateInstrumentOnce(INTEGRATION_NAME, () => new GenericPoolInstrumentation({}));\n\nconst _genericPoolIntegration = (() => {\n  let instrumentationWrappedCallback: undefined | ((callback: () => void) => void);\n\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      const instrumentation = instrumentGenericPool();\n      instrumentationWrappedCallback = instrumentWhenWrapped(instrumentation);\n    },\n\n    setup(client) {\n      instrumentationWrappedCallback?.(() =>\n        client.on('spanStart', span => {\n          const spanJSON = spanToJSON(span);\n\n          const spanDescription = spanJSON.description;\n\n          // typo in emitted span for version <= 0.38.0 of @opentelemetry/instrumentation-generic-pool\n          const isGenericPoolSpan =\n            spanDescription === 'generic-pool.aquire' || spanDescription === 'generic-pool.acquire';\n\n          if (isGenericPoolSpan) {\n            span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.generic_pool');\n          }\n        }),\n      );\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [generic-pool](https://www.npmjs.com/package/generic-pool) library.\n *\n * For more information, see the [`genericPoolIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/genericpool/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.genericPoolIntegration()],\n * });\n * ```\n */\nexport const genericPoolIntegration = defineIntegration(_genericPoolIntegration);\n"],"names":["generateInstrumentOnce","GenericPoolInstrumentation","instrumentWhenWrapped","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","defineIntegration"],"mappings":";;;;;;AAKA,MAAM,mBAAmB;MAEZ,wBAAwBA,SAAAA,sBAAsB,CAAC,kBAAkB,IAAM,IAAIC,2BAAAA,0BAA0B,CAAC,CAAA;AAEnH,MAAM,0BAA2B;IAC/B,IAAI;IAEJ,OAAO;QACL,MAAM;QACN;YACE,MAAM,kBAAkB;YACxB,iCAAiCC,SAAAA,qBAAqB,CAAC;QAC7D;QAEI,OAAM,MAAM;YACV,iCAAiC,IAC/B,OAAO,EAAE,CAAC,aAAa,CAAA;oBACrB,MAAM,WAAWC,KAAAA,UAAU,CAAC;oBAE5B,MAAM,kBAAkB,SAAS,WAAW;oBAEtD,4FAAA;oBACU,MAAM,oBACJ,oBAAoB,yBAAyB,oBAAoB;oBAEnE,IAAI,mBAAmB;wBACrB,KAAK,YAAY,CAACC,KAAAA,gCAAgC,EAAE;oBAChE;gBACA;QAEA;IACA;AACA;AAEA;;;;;;;;;;;;;CAaA,SACa,yBAAyBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 3435, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3439, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/dataloader.ts"],"sourcesContent":["import { DataloaderInstrumentation } from '@opentelemetry/instrumentation-dataloader';\nimport type { IntegrationFn } from '@sentry/core';\nimport {\n  defineIntegration,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  spanToJSON,\n} from '@sentry/core';\nimport { generateInstrumentOnce, instrumentWhenWrapped } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'Dataloader';\n\nexport const instrumentDataloader = generateInstrumentOnce(\n  INTEGRATION_NAME,\n  () =>\n    new DataloaderInstrumentation({\n      requireParentSpan: true,\n    }),\n);\n\nconst _dataloaderIntegration = (() => {\n  let instrumentationWrappedCallback: undefined | ((callback: () => void) => void);\n\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      const instrumentation = instrumentDataloader();\n      instrumentationWrappedCallback = instrumentWhenWrapped(instrumentation);\n    },\n\n    setup(client) {\n      // This is called either immediately or when the instrumentation is wrapped\n      instrumentationWrappedCallback?.(() => {\n        client.on('spanStart', span => {\n          const spanJSON = spanToJSON(span);\n          if (spanJSON.description?.startsWith('dataloader')) {\n            span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.dataloader');\n          }\n\n          // These are all possible dataloader span descriptions\n          // Still checking for the future versions\n          // in case they add support for `clear` and `prime`\n          if (\n            spanJSON.description === 'dataloader.load' ||\n            spanJSON.description === 'dataloader.loadMany' ||\n            spanJSON.description === 'dataloader.batch'\n          ) {\n            span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'cache.get');\n            // TODO: We can try adding `key` to the `data` attribute upstream.\n            // Or alternatively, we can add `requestHook` to the dataloader instrumentation.\n          }\n        });\n      });\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [dataloader](https://www.npmjs.com/package/dataloader) library.\n *\n * For more information, see the [`dataloaderIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/dataloader/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.dataloaderIntegration()],\n * });\n * ```\n */\nexport const dataloaderIntegration = defineIntegration(_dataloaderIntegration);\n"],"names":["generateInstrumentOnce","DataloaderInstrumentation","instrumentWhenWrapped","spanToJSON","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","defineIntegration"],"mappings":";;;;;;AAUA,MAAM,mBAAmB;AAElB,MAAM,uBAAuBA,SAAAA,sBAAsB,CACxD,kBACA,IACE,IAAIC,0BAAAA,yBAAyB,CAAC;QAC5B,mBAAmB;IACzB;AAGA,MAAM,yBAA0B;IAC9B,IAAI;IAEJ,OAAO;QACL,MAAM;QACN;YACE,MAAM,kBAAkB;YACxB,iCAAiCC,SAAAA,qBAAqB,CAAC;QAC7D;QAEI,OAAM,MAAM;YAChB,2EAAA;YACM,iCAAiC;gBAC/B,OAAO,EAAE,CAAC,aAAa,CAAA;oBACrB,MAAM,WAAWC,KAAAA,UAAU,CAAC;oBAC5B,IAAI,SAAS,WAAW,EAAE,WAAW,eAAe;wBAClD,KAAK,YAAY,CAACC,KAAAA,gCAAgC,EAAE;oBAChE;oBAEA,sDAAA;oBACA,yCAAA;oBACA,mDAAA;oBACU,IACE,SAAS,WAAA,KAAgB,qBACzB,SAAS,WAAA,KAAgB,yBACzB,SAAS,WAAA,KAAgB,oBACzB;wBACA,KAAK,YAAY,CAACC,KAAAA,4BAA4B,EAAE;oBAC5D,kEAAA;oBACA,gFAAA;oBACA;gBACA;YACA;QACA;IACA;AACA;AAEA;;;;;;;;;;;;;CAaA,SACa,wBAAwBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 3494, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3498, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/amqplib.ts"],"sourcesContent":["import type { Span } from '@opentelemetry/api';\nimport { type AmqplibInstrumentationConfig, AmqplibInstrumentation } from '@opentelemetry/instrumentation-amqplib';\nimport type { IntegrationFn } from '@sentry/core';\nimport { defineIntegration } from '@sentry/core';\nimport { addOriginToSpan, generateInstrumentOnce } from '@sentry/node-core';\n\nconst INTEGRATION_NAME = 'Amqplib';\n\nconst config: AmqplibInstrumentationConfig = {\n  consumeEndHook: (span: Span) => {\n    addOriginToSpan(span, 'auto.amqplib.otel.consumer');\n  },\n  publishHook: (span: Span) => {\n    addOriginToSpan(span, 'auto.amqplib.otel.publisher');\n  },\n};\n\nexport const instrumentAmqplib = generateInstrumentOnce(INTEGRATION_NAME, () => new AmqplibInstrumentation(config));\n\nconst _amqplibIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      instrumentAmqplib();\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [amqplib](https://www.npmjs.com/package/amqplib) library.\n *\n * For more information, see the [`amqplibIntegration` documentation](https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/amqplib/).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.amqplibIntegration()],\n * });\n * ```\n */\nexport const amqplibIntegration = defineIntegration(_amqplibIntegration);\n"],"names":["addOriginToSpan","generateInstrumentOnce","AmqplibInstrumentation","defineIntegration"],"mappings":";;;;;;AAMA,MAAM,mBAAmB;AAEzB,MAAM,SAAuC;IAC3C,gBAAgB,CAAC;QACfA,SAAAA,eAAe,CAAC,MAAM;IAC1B;IACE,aAAa,CAAC;QACZA,SAAAA,eAAe,CAAC,MAAM;IAC1B;AACA;AAEO,MAAM,oBAAoBC,SAAAA,sBAAsB,CAAC,kBAAkB,IAAM,IAAIC,uBAAAA,sBAAsB,CAAC;AAE3G,MAAM,sBAAuB;IAC3B,OAAO;QACL,MAAM;QACN;YACE;QACN;IACA;AACA;AAEA;;;;;;;;;;;;;CAaA,SACa,qBAAqBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 3538, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3542, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/vercelai/constants.ts"],"sourcesContent":["export const INTEGRATION_NAME = 'VercelAI';\n"],"names":[],"mappings":";;;AAAO,MAAM,mBAAmB"}},
    {"offset": {"line": 3547, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3551, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/vercelai/instrumentation.ts"],"sourcesContent":["import type { InstrumentationConfig, InstrumentationModuleDefinition } from '@opentelemetry/instrumentation';\nimport { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';\nimport { getCurrentScope, SDK_VERSION } from '@sentry/core';\nimport { INTEGRATION_NAME } from './constants';\nimport type { TelemetrySettings, VercelAiIntegration } from './types';\n\n// List of patched methods\n// From: https://sdk.vercel.ai/docs/ai-sdk-core/telemetry#collected-data\nconst INSTRUMENTED_METHODS = [\n  'generateText',\n  'streamText',\n  'generateObject',\n  'streamObject',\n  'embed',\n  'embedMany',\n] as const;\n\ninterface MethodFirstArg extends Record<string, unknown> {\n  experimental_telemetry?: TelemetrySettings;\n}\n\ntype MethodArgs = [MethodFirstArg, ...unknown[]];\n\ntype PatchedModuleExports = Record<(typeof INSTRUMENTED_METHODS)[number], (...args: MethodArgs) => unknown> &\n  Record<string, unknown>;\n\ninterface RecordingOptions {\n  recordInputs?: boolean;\n  recordOutputs?: boolean;\n}\n\n/**\n * Determines whether to record inputs and outputs for Vercel AI telemetry based on the configuration hierarchy.\n *\n * The order of precedence is:\n * 1. The vercel ai integration options\n * 2. The experimental_telemetry options in the vercel ai method calls\n * 3. When telemetry is explicitly enabled (isEnabled: true), default to recording\n * 4. Otherwise, use the sendDefaultPii option from client options\n */\nexport function determineRecordingSettings(\n  integrationRecordingOptions: RecordingOptions | undefined,\n  methodTelemetryOptions: RecordingOptions,\n  telemetryExplicitlyEnabled: boolean | undefined,\n  defaultRecordingEnabled: boolean,\n): { recordInputs: boolean; recordOutputs: boolean } {\n  const recordInputs =\n    integrationRecordingOptions?.recordInputs !== undefined\n      ? integrationRecordingOptions.recordInputs\n      : methodTelemetryOptions.recordInputs !== undefined\n        ? methodTelemetryOptions.recordInputs\n        : telemetryExplicitlyEnabled === true\n          ? true // When telemetry is explicitly enabled, default to recording inputs\n          : defaultRecordingEnabled;\n\n  const recordOutputs =\n    integrationRecordingOptions?.recordOutputs !== undefined\n      ? integrationRecordingOptions.recordOutputs\n      : methodTelemetryOptions.recordOutputs !== undefined\n        ? methodTelemetryOptions.recordOutputs\n        : telemetryExplicitlyEnabled === true\n          ? true // When telemetry is explicitly enabled, default to recording inputs\n          : defaultRecordingEnabled;\n\n  return { recordInputs, recordOutputs };\n}\n\n/**\n * This detects is added by the Sentry Vercel AI Integration to detect if the integration should\n * be enabled.\n *\n * It also patches the `ai` module to enable Vercel AI telemetry automatically for all methods.\n */\nexport class SentryVercelAiInstrumentation extends InstrumentationBase {\n  private _isPatched = false;\n  private _callbacks: (() => void)[] = [];\n\n  public constructor(config: InstrumentationConfig = {}) {\n    super('@sentry/instrumentation-vercel-ai', SDK_VERSION, config);\n  }\n\n  /**\n   * Initializes the instrumentation by defining the modules to be patched.\n   */\n  public init(): InstrumentationModuleDefinition {\n    const module = new InstrumentationNodeModuleDefinition('ai', ['>=3.0.0 <5'], this._patch.bind(this));\n    return module;\n  }\n\n  /**\n   * Call the provided callback when the module is patched.\n   * If it has already been patched, the callback will be called immediately.\n   */\n  public callWhenPatched(callback: () => void): void {\n    if (this._isPatched) {\n      callback();\n    } else {\n      this._callbacks.push(callback);\n    }\n  }\n\n  /**\n   * Patches module exports to enable Vercel AI telemetry.\n   */\n  private _patch(moduleExports: PatchedModuleExports): unknown {\n    this._isPatched = true;\n\n    this._callbacks.forEach(callback => callback());\n    this._callbacks = [];\n\n    function generatePatch(originalMethod: (...args: MethodArgs) => unknown) {\n      return (...args: MethodArgs) => {\n        const existingExperimentalTelemetry = args[0].experimental_telemetry || {};\n        const isEnabled = existingExperimentalTelemetry.isEnabled;\n\n        const client = getCurrentScope().getClient();\n        const integration = client?.getIntegrationByName<VercelAiIntegration>(INTEGRATION_NAME);\n        const integrationOptions = integration?.options;\n        const shouldRecordInputsAndOutputs = integration ? Boolean(client?.getOptions().sendDefaultPii) : false;\n\n        const { recordInputs, recordOutputs } = determineRecordingSettings(\n          integrationOptions,\n          existingExperimentalTelemetry,\n          isEnabled,\n          shouldRecordInputsAndOutputs,\n        );\n\n        args[0].experimental_telemetry = {\n          ...existingExperimentalTelemetry,\n          isEnabled: isEnabled !== undefined ? isEnabled : true,\n          recordInputs,\n          recordOutputs,\n        };\n\n        // @ts-expect-error we know that the method exists\n        return originalMethod.apply(this, args);\n      };\n    }\n\n    // Is this an ESM module?\n    // https://tc39.es/ecma262/#sec-module-namespace-objects\n    if (Object.prototype.toString.call(moduleExports) === '[object Module]') {\n      // In ESM we take the usual route and just replace the exports we want to instrument\n      for (const method of INSTRUMENTED_METHODS) {\n        moduleExports[method] = generatePatch(moduleExports[method]);\n      }\n\n      return moduleExports;\n    } else {\n      // In CJS we can't replace the exports in the original module because they\n      // don't have setters, so we create a new object with the same properties\n      const patchedModuleExports = INSTRUMENTED_METHODS.reduce((acc, curr) => {\n        acc[curr] = generatePatch(moduleExports[curr]);\n        return acc;\n      }, {} as PatchedModuleExports);\n\n      return { ...moduleExports, ...patchedModuleExports };\n    }\n  }\n}\n"],"names":["InstrumentationBase","SDK_VERSION","InstrumentationNodeModuleDefinition","getCurrentScope","INTEGRATION_NAME"],"mappings":"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"}},
    {"offset": {"line": 3669, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3673, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/vercelai/index.ts"],"sourcesContent":["import type { Client, IntegrationFn } from '@sentry/core';\nimport { addVercelAiProcessors, defineIntegration } from '@sentry/core';\nimport { type modulesIntegration, generateInstrumentOnce } from '@sentry/node-core';\nimport { INTEGRATION_NAME } from './constants';\nimport { SentryVercelAiInstrumentation } from './instrumentation';\nimport type { VercelAiOptions } from './types';\n\nexport const instrumentVercelAi = generateInstrumentOnce(INTEGRATION_NAME, () => new SentryVercelAiInstrumentation({}));\n\n/**\n * Determines if the integration should be forced based on environment and package availability.\n * Returns true if the 'ai' package is available.\n */\nfunction shouldForceIntegration(client: Client): boolean {\n  const modules = client.getIntegrationByName<ReturnType<typeof modulesIntegration>>('Modules');\n  return !!modules?.getModules?.()?.ai;\n}\n\nconst _vercelAIIntegration = ((options: VercelAiOptions = {}) => {\n  let instrumentation: undefined | SentryVercelAiInstrumentation;\n\n  return {\n    name: INTEGRATION_NAME,\n    options,\n    setupOnce() {\n      instrumentation = instrumentVercelAi();\n    },\n    afterAllSetup(client) {\n      // Auto-detect if we should force the integration when running with 'ai' package available\n      // Note that this can only be detected if the 'Modules' integration is available, and running in CJS mode\n      const shouldForce = options.force ?? shouldForceIntegration(client);\n\n      if (shouldForce) {\n        addVercelAiProcessors(client);\n      } else {\n        instrumentation?.callWhenPatched(() => addVercelAiProcessors(client));\n      }\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds Sentry tracing instrumentation for the [ai](https://www.npmjs.com/package/ai) library.\n * This integration is not enabled by default, you need to manually add it.\n *\n * For more information, see the [`ai` documentation](https://sdk.vercel.ai/docs/ai-sdk-core/telemetry).\n *\n * @example\n * ```javascript\n * const Sentry = require('@sentry/node');\n *\n * Sentry.init({\n *  integrations: [Sentry.vercelAIIntegration()],\n * });\n * ```\n *\n * This integration adds tracing support to all `ai` function calls.\n * You need to opt-in to collecting spans for a specific call,\n * you can do so by setting `experimental_telemetry.isEnabled` to `true` in the first argument of the function call.\n *\n * ```javascript\n * const result = await generateText({\n *   model: openai('gpt-4-turbo'),\n *   experimental_telemetry: { isEnabled: true },\n * });\n * ```\n *\n * If you want to collect inputs and outputs for a specific call, you must specifically opt-in to each\n * function call by setting `experimental_telemetry.recordInputs` and `experimental_telemetry.recordOutputs`\n * to `true`.\n *\n * ```javascript\n * const result = await generateText({\n *  model: openai('gpt-4-turbo'),\n *  experimental_telemetry: { isEnabled: true, recordInputs: true, recordOutputs: true },\n * });\n */\nexport const vercelAIIntegration = defineIntegration(_vercelAIIntegration);\n"],"names":["generateInstrumentOnce","INTEGRATION_NAME","SentryVercelAiInstrumentation","addVercelAiProcessors","defineIntegration"],"mappings":";;;;;;;MAOa,qBAAqBA,SAAAA,sBAAsB,CAACC,UAAAA,gBAAgB,EAAE,IAAM,IAAIC,gBAAAA,6BAA6B,CAAC,CAAA;AAEnH;;;CAGA,GACA,SAAS,uBAAuB,MAAM;IACpC,MAAM,UAAU,OAAO,oBAAoB,CAAwC;IACnF,OAAO,CAAC,CAAC,SAAS,gBAAgB;AACpC;AAEA,MAAM,uBAAwB,CAAC,UAA2B,CAAA,CAAE;IAC1D,IAAI;IAEJ,OAAO;QACL,MAAMD,UAAAA,gBAAgB;QACtB;QACA;YACE,kBAAkB;QACxB;QACI,eAAc,MAAM;YACxB,0FAAA;YACA,yGAAA;YACM,MAAM,cAAc,QAAQ,KAAA,IAAS,uBAAuB;YAE5D,IAAI,aAAa;gBACfE,KAAAA,qBAAqB,CAAC;YAC9B,OAAa;gBACL,iBAAiB,gBAAgB,IAAMA,KAAAA,qBAAqB,CAAC;YACrE;QACA;IACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCA,SACa,sBAAsBC,KAAAA,iBAAiB,CAAC"}},
    {"offset": {"line": 3746, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3750, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/featureFlagShims/launchDarkly.ts"],"sourcesContent":["import { consoleSandbox, defineIntegration, isBrowser } from '@sentry/core';\n\n/**\n * This is a shim for the LaunchDarkly integration.\n * We need this in order to not throw runtime errors when accidentally importing this on the server through a meta framework like Next.js.\n */\nexport const launchDarklyIntegrationShim = defineIntegration((_options?: unknown) => {\n  if (!isBrowser()) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('The launchDarklyIntegration() can only be used in the browser.');\n    });\n  }\n\n  return {\n    name: 'LaunchDarkly',\n  };\n});\n\n/**\n * This is a shim for the LaunchDarkly flag used handler.\n */\nexport function buildLaunchDarklyFlagUsedHandlerShim(): unknown {\n  if (!isBrowser()) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('The buildLaunchDarklyFlagUsedHandler() can only be used in the browser.');\n    });\n  }\n\n  return {\n    name: 'sentry-flag-auditor',\n    type: 'flag-used',\n    synchronous: true,\n    method: () => null,\n  };\n}\n"],"names":["defineIntegration","isBrowser","consoleSandbox"],"mappings":";;;;AAEA;;;CAGA,GACO,MAAM,8BAA8BA,KAAAA,iBAAiB,CAAC,CAAC;IAC5D,IAAI,CAACC,KAAAA,SAAS,IAAI;QAChBC,KAAAA,cAAc,CAAC;YACnB,sCAAA;YACM,QAAQ,IAAI,CAAC;QACnB;IACA;IAEE,OAAO;QACL,MAAM;IACV;AACA;AAEA;;CAEA,GACO,SAAS;IACd,IAAI,CAACD,KAAAA,SAAS,IAAI;QAChBC,KAAAA,cAAc,CAAC;YACnB,sCAAA;YACM,QAAQ,IAAI,CAAC;QACnB;IACA;IAEE,OAAO;QACL,MAAM;QACN,MAAM;QACN,aAAa;QACb,QAAQ,IAAM;IAClB;AACA"}},
    {"offset": {"line": 3786, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3790, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/featureFlagShims/openFeature.ts"],"sourcesContent":["import { consoleSandbox, defineIntegration, isBrowser } from '@sentry/core';\n\n/**\n * This is a shim for the OpenFeature integration.\n * We need this in order to not throw runtime errors when accidentally importing this on the server through a meta framework like Next.js.\n */\nexport const openFeatureIntegrationShim = defineIntegration((_options?: unknown) => {\n  if (!isBrowser()) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('The openFeatureIntegration() can only be used in the browser.');\n    });\n  }\n\n  return {\n    name: 'OpenFeature',\n  };\n});\n\n/**\n * This is a shim for the OpenFeature integration hook.\n */\nexport class OpenFeatureIntegrationHookShim {\n  /**\n   *\n   */\n  public constructor() {\n    if (!isBrowser()) {\n      consoleSandbox(() => {\n        // eslint-disable-next-line no-console\n        console.warn('The OpenFeatureIntegrationHook can only be used in the browser.');\n      });\n    }\n  }\n\n  /**\n   *\n   */\n  public after(): void {\n    // No-op\n  }\n\n  /**\n   *\n   */\n  public error(): void {\n    // No-op\n  }\n}\n"],"names":["defineIntegration","isBrowser","consoleSandbox"],"mappings":";;;;AAEA;;;CAGA,GACO,MAAM,6BAA6BA,KAAAA,iBAAiB,CAAC,CAAC;IAC3D,IAAI,CAACC,KAAAA,SAAS,IAAI;QAChBC,KAAAA,cAAc,CAAC;YACnB,sCAAA;YACM,QAAQ,IAAI,CAAC;QACnB;IACA;IAEE,OAAO;QACL,MAAM;IACV;AACA;AAEA;;CAEA,GACO,MAAM;IACb;;GAEA,GACS,aAAc;QACnB,IAAI,CAACD,KAAAA,SAAS,IAAI;YAChBC,KAAAA,cAAc,CAAC;gBACrB,sCAAA;gBACQ,QAAQ,IAAI,CAAC;YACrB;QACA;IACA;IAEA;;GAEA,GACS,QAAc;IACvB,QAAA;IACA;IAEA;;GAEA,GACS,QAAc;IACvB,QAAA;IACA;AACA"}},
    {"offset": {"line": 3834, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3838, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/featureFlagShims/statsig.ts"],"sourcesContent":["import { consoleSandbox, defineIntegration, isBrowser } from '@sentry/core';\n\n/**\n * This is a shim for the Statsig integration.\n * We need this in order to not throw runtime errors when accidentally importing this on the server through a meta framework like Next.js.\n */\nexport const statsigIntegrationShim = defineIntegration((_options?: unknown) => {\n  if (!isBrowser()) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('The statsigIntegration() can only be used in the browser.');\n    });\n  }\n\n  return {\n    name: 'Statsig',\n  };\n});\n"],"names":["defineIntegration","isBrowser","consoleSandbox"],"mappings":";;;;AAEA;;;CAGA,GACO,MAAM,yBAAyBA,KAAAA,iBAAiB,CAAC,CAAC;IACvD,IAAI,CAACC,KAAAA,SAAS,IAAI;QAChBC,KAAAA,cAAc,CAAC;YACnB,sCAAA;YACM,QAAQ,IAAI,CAAC;QACnB;IACA;IAEE,OAAO;QACL,MAAM;IACV;AACA"}},
    {"offset": {"line": 3857, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3861, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/featureFlagShims/unleash.ts"],"sourcesContent":["import { consoleSandbox, defineIntegration, isBrowser } from '@sentry/core';\n\n/**\n * This is a shim for the Unleash integration.\n * We need this in order to not throw runtime errors when accidentally importing this on the server through a meta framework like Next.js.\n */\nexport const unleashIntegrationShim = defineIntegration((_options?: unknown) => {\n  if (!isBrowser()) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('The unleashIntegration() can only be used in the browser.');\n    });\n  }\n\n  return {\n    name: 'Unleash',\n  };\n});\n"],"names":["defineIntegration","isBrowser","consoleSandbox"],"mappings":";;;;AAEA;;;CAGA,GACO,MAAM,yBAAyBA,KAAAA,iBAAiB,CAAC,CAAC;IACvD,IAAI,CAACC,KAAAA,SAAS,IAAI;QAChBC,KAAAA,cAAc,CAAC;YACnB,sCAAA;YACM,QAAQ,IAAI,CAAC;QACnB;IACA;IAEE,OAAO;QACL,MAAM;IACV;AACA"}},
    {"offset": {"line": 3880, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3884, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/integrations/tracing/index.ts"],"sourcesContent":["import type { Integration } from '@sentry/core';\nimport { instrumentOtelHttp } from '../http';\nimport { amqplibIntegration, instrumentAmqplib } from './amqplib';\nimport { connectIntegration, instrumentConnect } from './connect';\nimport { expressIntegration, instrumentExpress, instrumentExpressV5 } from './express';\nimport { fastifyIntegration, instrumentFastify, instrumentFastifyV3 } from './fastify';\nimport { genericPoolIntegration, instrumentGenericPool } from './genericPool';\nimport { graphqlIntegration, instrumentGraphql } from './graphql';\nimport { hapiIntegration, instrumentHapi } from './hapi';\nimport { instrumentKafka, kafkaIntegration } from './kafka';\nimport { instrumentKoa, koaIntegration } from './koa';\nimport { instrumentLruMemoizer, lruMemoizerIntegration } from './lrumemoizer';\nimport { instrumentMongo, mongoIntegration } from './mongo';\nimport { instrumentMongoose, mongooseIntegration } from './mongoose';\nimport { instrumentMysql, mysqlIntegration } from './mysql';\nimport { instrumentMysql2, mysql2Integration } from './mysql2';\nimport { instrumentPostgres, postgresIntegration } from './postgres';\nimport { instrumentPostgresJs, postgresJsIntegration } from './postgresjs';\nimport { prismaIntegration } from './prisma';\nimport { instrumentRedis, redisIntegration } from './redis';\nimport { instrumentTedious, tediousIntegration } from './tedious';\nimport { instrumentVercelAi, vercelAIIntegration } from './vercelai';\n\n/**\n * With OTEL, all performance integrations will be added, as OTEL only initializes them when the patched package is actually required.\n */\nexport function getAutoPerformanceIntegrations(): Integration[] {\n  return [\n    expressIntegration(),\n    fastifyIntegration(),\n    graphqlIntegration(),\n    mongoIntegration(),\n    mongooseIntegration(),\n    mysqlIntegration(),\n    mysql2Integration(),\n    redisIntegration(),\n    postgresIntegration(),\n    prismaIntegration(),\n    hapiIntegration(),\n    koaIntegration(),\n    connectIntegration(),\n    tediousIntegration(),\n    genericPoolIntegration(),\n    kafkaIntegration(),\n    amqplibIntegration(),\n    lruMemoizerIntegration(),\n    vercelAIIntegration(),\n    postgresJsIntegration(),\n  ];\n}\n\n/**\n * Get a list of methods to instrument OTEL, when preload instrumentation.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getOpenTelemetryInstrumentationToPreload(): (((options?: any) => void) & { id: string })[] {\n  return [\n    instrumentOtelHttp,\n    instrumentExpress,\n    instrumentExpressV5,\n    instrumentConnect,\n    instrumentFastify,\n    instrumentFastifyV3,\n    instrumentHapi,\n    instrumentKafka,\n    instrumentKoa,\n    instrumentLruMemoizer,\n    instrumentMongo,\n    instrumentMongoose,\n    instrumentMysql,\n    instrumentMysql2,\n    instrumentPostgres,\n    instrumentHapi,\n    instrumentGraphql,\n    instrumentRedis,\n    instrumentTedious,\n    instrumentGenericPool,\n    instrumentAmqplib,\n    instrumentVercelAi,\n    instrumentPostgresJs,\n  ];\n}\n"],"names":["expressIntegration","fastifyIntegration","graphqlIntegration","mongoIntegration","mongooseIntegration","mysqlIntegration","mysql2Integration","redisIntegration","postgresIntegration","prismaIntegration","hapiIntegration","koaIntegration","connectIntegration","tediousIntegration","genericPoolIntegration","kafkaIntegration","amqplibIntegration","lruMemoizerIntegration","vercelAIIntegration","postgresJsIntegration","instrumentOtelHttp","instrumentExpress","instrumentExpressV5","instrumentConnect","instrumentFastify","instrumentFastifyV3","instrumentHapi","instrumentKafka","instrumentKoa","instrumentLruMemoizer","instrumentMongo","instrumentMongoose","instrumentMysql","instrumentMysql2","instrumentPostgres","instrumentGraphql","instrumentRedis","instrumentTedious","instrumentGenericPool","instrumentAmqplib","instrumentVercelAi","instrumentPostgresJs"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;CAEA,GACO,SAAS;IACd,OAAO;QACLA,QAAAA,kBAAkB;QAClBC,QAAAA,kBAAkB;QAClBC,QAAAA,kBAAkB;QAClBC,MAAAA,gBAAgB;QAChBC,SAAAA,mBAAmB;QACnBC,MAAAA,gBAAgB;QAChBC,OAAAA,iBAAiB;QACjBC,MAAAA,gBAAgB;QAChBC,SAAAA,mBAAmB;QACnBC,OAAAA,iBAAiB;QACjBC,QAAAA,eAAe;QACfC,IAAAA,cAAc;QACdC,QAAAA,kBAAkB;QAClBC,QAAAA,kBAAkB;QAClBC,YAAAA,sBAAsB;QACtBC,MAAAA,gBAAgB;QAChBC,QAAAA,kBAAkB;QAClBC,YAAAA,sBAAsB;QACtBC,QAAAA,mBAAmB;QACnBC,WAAAA,qBAAqB;KACtB;AACH;AAEA;;CAEA,GACA,8DAAA;AACO,SAAS;IACd,OAAO;QACLC,MAAAA,kBAAkB;QAClBC,QAAAA,iBAAiB;QACjBC,QAAAA,mBAAmB;QACnBC,QAAAA,iBAAiB;QACjBC,QAAAA,iBAAiB;QACjBC,QAAAA,mBAAmB;QACnBC,QAAAA,cAAc;QACdC,MAAAA,eAAe;QACfC,IAAAA,aAAa;QACbC,YAAAA,qBAAqB;QACrBC,MAAAA,eAAe;QACfC,SAAAA,kBAAkB;QAClBC,MAAAA,eAAe;QACfC,OAAAA,gBAAgB;QAChBC,SAAAA,kBAAkB;QAClBR,QAAAA,cAAc;QACdS,QAAAA,iBAAiB;QACjBC,MAAAA,eAAe;QACfC,QAAAA,iBAAiB;QACjBC,YAAAA,qBAAqB;QACrBC,QAAAA,iBAAiB;QACjBC,QAAAA,kBAAkB;QAClBC,WAAAA,oBAAoB;KACrB;AACH"}},
    {"offset": {"line": 3966, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3970, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/sdk/initOtel.ts"],"sourcesContent":["import { context, propagation, trace } from '@opentelemetry/api';\nimport { Resource } from '@opentelemetry/resources';\nimport type { SpanProcessor } from '@opentelemetry/sdk-trace-base';\nimport { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport {\n  ATTR_SERVICE_NAME,\n  ATTR_SERVICE_VERSION,\n  SEMRESATTRS_SERVICE_NAMESPACE,\n} from '@opentelemetry/semantic-conventions';\nimport { consoleSandbox, GLOBAL_OBJ, logger, SDK_VERSION } from '@sentry/core';\nimport { type NodeClient, isCjs, SentryContextManager, setupOpenTelemetryLogger } from '@sentry/node-core';\nimport { SentryPropagator, SentrySampler, SentrySpanProcessor } from '@sentry/opentelemetry';\nimport { createAddHookMessageChannel } from 'import-in-the-middle';\nimport moduleModule from 'module';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { getOpenTelemetryInstrumentationToPreload } from '../integrations/tracing';\n\n// About 277h - this must fit into new Array(len)!\nconst MAX_MAX_SPAN_WAIT_DURATION = 1_000_000;\n\ninterface AdditionalOpenTelemetryOptions {\n  /** Additional SpanProcessor instances that should be used. */\n  spanProcessors?: SpanProcessor[];\n}\n\n/**\n * Initialize OpenTelemetry for Node.\n */\nexport function initOpenTelemetry(client: NodeClient, options: AdditionalOpenTelemetryOptions = {}): void {\n  if (client.getOptions().debug) {\n    setupOpenTelemetryLogger();\n  }\n\n  const provider = setupOtel(client, options);\n  client.traceProvider = provider;\n}\n\n/** Initialize the ESM loader. */\nexport function maybeInitializeEsmLoader(): void {\n  const [nodeMajor = 0, nodeMinor = 0] = process.versions.node.split('.').map(Number);\n\n  // Register hook was added in v20.6.0 and v18.19.0\n  if (nodeMajor >= 21 || (nodeMajor === 20 && nodeMinor >= 6) || (nodeMajor === 18 && nodeMinor >= 19)) {\n    if (!GLOBAL_OBJ._sentryEsmLoaderHookRegistered) {\n      try {\n        const { addHookMessagePort } = createAddHookMessageChannel();\n        // @ts-expect-error register is available in these versions\n        moduleModule.register('import-in-the-middle/hook.mjs', import.meta.url, {\n          data: { addHookMessagePort, include: [] },\n          transferList: [addHookMessagePort],\n        });\n      } catch (error) {\n        logger.warn('Failed to register ESM hook', error);\n      }\n    }\n  } else {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `[Sentry] You are using Node.js v${process.versions.node} in ESM mode (\"import syntax\"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS (\"require() syntax\"), or upgrade your Node.js version.`,\n      );\n    });\n  }\n}\n\ninterface NodePreloadOptions {\n  debug?: boolean;\n  integrations?: string[];\n}\n\n/**\n * Preload OpenTelemetry for Node.\n * This can be used to preload instrumentation early, but set up Sentry later.\n * By preloading the OTEL instrumentation wrapping still happens early enough that everything works.\n */\nexport function preloadOpenTelemetry(options: NodePreloadOptions = {}): void {\n  const { debug } = options;\n\n  if (debug) {\n    logger.enable();\n  }\n\n  if (!isCjs()) {\n    maybeInitializeEsmLoader();\n  }\n\n  // These are all integrations that we need to pre-load to ensure they are set up before any other code runs\n  getPreloadMethods(options.integrations).forEach(fn => {\n    fn();\n\n    if (debug) {\n      logger.log(`[Sentry] Preloaded ${fn.id} instrumentation`);\n    }\n  });\n}\n\nfunction getPreloadMethods(integrationNames?: string[]): ((() => void) & { id: string })[] {\n  const instruments = getOpenTelemetryInstrumentationToPreload();\n\n  if (!integrationNames) {\n    return instruments;\n  }\n\n  return instruments.filter(instrumentation => integrationNames.includes(instrumentation.id));\n}\n\n/** Just exported for tests. */\nexport function setupOtel(client: NodeClient, options: AdditionalOpenTelemetryOptions = {}): BasicTracerProvider {\n  // Create and configure NodeTracerProvider\n  const provider = new BasicTracerProvider({\n    sampler: new SentrySampler(client),\n    resource: new Resource({\n      [ATTR_SERVICE_NAME]: 'node',\n      // eslint-disable-next-line deprecation/deprecation\n      [SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',\n      [ATTR_SERVICE_VERSION]: SDK_VERSION,\n    }),\n    forceFlushTimeoutMillis: 500,\n    spanProcessors: [\n      new SentrySpanProcessor({\n        timeout: _clampSpanProcessorTimeout(client.getOptions().maxSpanWaitDuration),\n      }),\n      ...(options.spanProcessors || []),\n    ],\n  });\n\n  // Register as globals\n  trace.setGlobalTracerProvider(provider);\n  propagation.setGlobalPropagator(new SentryPropagator());\n  context.setGlobalContextManager(new SentryContextManager());\n\n  return provider;\n}\n\n/** Just exported for tests. */\nexport function _clampSpanProcessorTimeout(maxSpanWaitDuration: number | undefined): number | undefined {\n  if (maxSpanWaitDuration == null) {\n    return undefined;\n  }\n\n  // We guard for a max. value here, because we create an array with this length\n  // So if this value is too large, this would fail\n  if (maxSpanWaitDuration > MAX_MAX_SPAN_WAIT_DURATION) {\n    DEBUG_BUILD &&\n      logger.warn(`\\`maxSpanWaitDuration\\` is too high, using the maximum value of ${MAX_MAX_SPAN_WAIT_DURATION}`);\n    return MAX_MAX_SPAN_WAIT_DURATION;\n  } else if (maxSpanWaitDuration <= 0 || Number.isNaN(maxSpanWaitDuration)) {\n    DEBUG_BUILD && logger.warn('`maxSpanWaitDuration` must be a positive number, using default value instead.');\n    return undefined;\n  }\n\n  return maxSpanWaitDuration;\n}\n"],"names":["setupOpenTelemetryLogger","GLOBAL_OBJ","createAddHookMessageChannel","moduleModule","logger","consoleSandbox","isCjs","getOpenTelemetryInstrumentationToPreload","BasicTracerProvider","SentrySampler","Resource","ATTR_SERVICE_NAME","SEMRESATTRS_SERVICE_NAMESPACE","ATTR_SERVICE_VERSION","SDK_VERSION","SentrySpanProcessor","trace","propagation","SentryPropagator","context","SentryContextManager","DEBUG_BUILD"],"mappings":"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"}},
    {"offset": {"line": 4095, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4099, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry+node@9.37.0/node_modules/@sentry/node/src/sdk/index.ts"],"sourcesContent":["import type { Integration, Options } from '@sentry/core';\nimport { hasSpansEnabled } from '@sentry/core';\nimport type { NodeClient } from '@sentry/node-core';\nimport {\n  getDefaultIntegrations as getNodeCoreDefaultIntegrations,\n  init as initNodeCore,\n  validateOpenTelemetrySetup,\n} from '@sentry/node-core';\nimport { httpIntegration } from '../integrations/http';\nimport { nativeNodeFetchIntegration } from '../integrations/node-fetch';\nimport { getAutoPerformanceIntegrations } from '../integrations/tracing';\nimport type { NodeOptions } from '../types';\nimport { initOpenTelemetry } from './initOtel';\n\n/**\n * Get default integrations, excluding performance.\n */\nexport function getDefaultIntegrationsWithoutPerformance(): Integration[] {\n  const nodeCoreIntegrations = getNodeCoreDefaultIntegrations();\n\n  // Filter out the node-core HTTP and NodeFetch integrations and replace them with Node SDK's composite versions\n  return nodeCoreIntegrations\n    .filter(integration => integration.name !== 'Http' && integration.name !== 'NodeFetch')\n    .concat(httpIntegration(), nativeNodeFetchIntegration());\n}\n\n/** Get the default integrations for the Node SDK. */\nexport function getDefaultIntegrations(options: Options): Integration[] {\n  return [\n    ...getDefaultIntegrationsWithoutPerformance(),\n    // We only add performance integrations if tracing is enabled\n    // Note that this means that without tracing enabled, e.g. `expressIntegration()` will not be added\n    // This means that generally request isolation will work (because that is done by httpIntegration)\n    // But `transactionName` will not be set automatically\n    ...(hasSpansEnabled(options) ? getAutoPerformanceIntegrations() : []),\n  ];\n}\n\n/**\n * Initialize Sentry for Node.\n */\nexport function init(options: NodeOptions | undefined = {}): NodeClient | undefined {\n  return _init(options, getDefaultIntegrations);\n}\n\n/**\n * Internal initialization function.\n */\nfunction _init(\n  options: NodeOptions | undefined = {},\n  getDefaultIntegrationsImpl: (options: Options) => Integration[],\n): NodeClient | undefined {\n  const client = initNodeCore({\n    ...options,\n    // Only use Node SDK defaults if none provided\n    defaultIntegrations: options.defaultIntegrations ?? getDefaultIntegrationsImpl(options),\n  });\n\n  // Add Node SDK specific OpenTelemetry setup\n  if (client && !options.skipOpenTelemetrySetup) {\n    initOpenTelemetry(client, {\n      spanProcessors: options.openTelemetrySpanProcessors,\n    });\n    validateOpenTelemetrySetup();\n  }\n\n  return client;\n}\n\n/**\n * Initialize Sentry for Node, without any integrations added by default.\n */\nexport function initWithoutDefaultIntegrations(options: NodeOptions | undefined = {}): NodeClient | undefined {\n  return _init(options, () => []);\n}\n"],"names":["getNodeCoreDefaultIntegrations","httpIntegration","nativeNodeFetchIntegration","hasSpansEnabled","getAutoPerformanceIntegrations","initNodeCore","initOpenTelemetry","validateOpenTelemetrySetup"],"mappings":";;;;;;;;;AAcA;;CAEA,GACO,SAAS;IACd,MAAM,uBAAuBA,SAAAA,sBAA8B;IAE7D,+GAAA;IACE,OAAO,qBACJ,MAAM,CAAC,CAAA,cAAe,YAAY,IAAA,KAAS,UAAU,YAAY,IAAA,KAAS,aAC1E,MAAM,CAACC,QAAAA,eAAe,IAAIC,QAAAA,0BAA0B;AACzD;AAEA,mDAAA,GACO,SAAS,uBAAuB,OAAO;IAC5C,OAAO;WACF;QACP,6DAAA;QACA,mGAAA;QACA,kGAAA;QACA,sDAAA;WACQC,KAAAA,eAAe,CAAC,WAAWC,MAAAA,8BAA8B,KAAK,EAAE;KACrE;AACH;AAEA;;CAEA,GACO,SAAS,KAAK,UAAmC,CAAA,CAAE;IACxD,OAAO,MAAM,SAAS;AACxB;AAEA;;CAEA,GACA,SAAS,MACP,UAAmC,CAAA,CAAE,EACrC,0BAA0B;IAE1B,MAAM,SAASC,SAAAA,IAAY,CAAC;QAC1B,GAAG,OAAO;QACd,8CAAA;QACI,qBAAqB,QAAQ,mBAAA,IAAuB,2BAA2B;IACnF;IAEA,4CAAA;IACE,IAAI,UAAU,CAAC,QAAQ,sBAAsB,EAAE;QAC7CC,SAAAA,iBAAiB,CAAC,QAAQ;YACxB,gBAAgB,QAAQ,2BAA2B;QACzD;QACIC,SAAAA,0BAA0B;IAC9B;IAEE,OAAO;AACT;AAEA;;CAEA,GACO,SAAS,+BAA+B,UAAmC,CAAA,CAAE;IAClF,OAAO,MAAM,SAAS,IAAM,EAAE;AAChC"}},
    {"offset": {"line": 4156, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4160, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 4340, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}