{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/next-themes@0.2.1_next@14.2.30_react-dom@18.3.1_react@18.3.1/node_modules/next-themes/dist/index.module.js"],"sourcesContent":["import e,{useContext as t,Fragment as n,useState as r,useCallback as o,useEffect as a,useMemo as s,memo as l,createContext as m}from\"react\";const c=[\"light\",\"dark\"],i=\"(prefers-color-scheme: dark)\",d=\"undefined\"==typeof window,u=/*#__PURE__*/m(void 0),h={setTheme:e=>{},themes:[]},y=()=>{var e;return null!==(e=t(u))&&void 0!==e?e:h},$=r=>t(u)?/*#__PURE__*/e.createElement(n,null,r.children):/*#__PURE__*/e.createElement(f,r),v=[\"light\",\"dark\"],f=({forcedTheme:t,disableTransitionOnChange:n=!1,enableSystem:l=!0,enableColorScheme:m=!0,storageKey:d=\"theme\",themes:h=v,defaultTheme:y=(l?\"system\":\"light\"),attribute:$=\"data-theme\",value:f,children:w,nonce:T})=>{const[E,k]=r(()=>S(d,y)),[C,L]=r(()=>S(d)),x=f?Object.values(f):h,I=o(e=>{let t=e;if(!t)return;\"system\"===e&&l&&(t=p());const r=f?f[t]:t,o=n?b():null,a=document.documentElement;if(\"class\"===$?(a.classList.remove(...x),r&&a.classList.add(r)):r?a.setAttribute($,r):a.removeAttribute($),m){const e=c.includes(y)?y:null,n=c.includes(t)?t:e;a.style.colorScheme=n}null==o||o()},[]),O=o(e=>{k(e);try{localStorage.setItem(d,e)}catch(e){}},[t]),M=o(e=>{const n=p(e);L(n),\"system\"===E&&l&&!t&&I(\"system\")},[E,t]);a(()=>{const e=window.matchMedia(i);return e.addListener(M),M(e),()=>e.removeListener(M)},[M]),a(()=>{const e=e=>{e.key===d&&O(e.newValue||y)};return window.addEventListener(\"storage\",e),()=>window.removeEventListener(\"storage\",e)},[O]),a(()=>{I(null!=t?t:E)},[t,E]);const A=s(()=>({theme:E,setTheme:O,forcedTheme:t,resolvedTheme:\"system\"===E?C:E,themes:l?[...h,\"system\"]:h,systemTheme:l?C:void 0}),[E,O,t,C,l,h]);/*#__PURE__*/return e.createElement(u.Provider,{value:A},/*#__PURE__*/e.createElement(g,{forcedTheme:t,disableTransitionOnChange:n,enableSystem:l,enableColorScheme:m,storageKey:d,themes:h,defaultTheme:y,attribute:$,value:f,children:w,attrs:x,nonce:T}),w)},g=/*#__PURE__*/l(({forcedTheme:t,storageKey:n,attribute:r,enableSystem:o,enableColorScheme:a,defaultTheme:s,value:l,attrs:m,nonce:d})=>{const u=\"system\"===s,h=\"class\"===r?`var d=document.documentElement,c=d.classList;c.remove(${m.map(e=>`'${e}'`).join(\",\")});`:`var d=document.documentElement,n='${r}',s='setAttribute';`,y=a?c.includes(s)&&s?`if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${s}'`:\"if(e==='light'||e==='dark')d.style.colorScheme=e\":\"\",$=(e,t=!1,n=!0)=>{const o=l?l[e]:e,s=t?e+\"|| ''\":`'${o}'`;let m=\"\";return a&&n&&!t&&c.includes(e)&&(m+=`d.style.colorScheme = '${e}';`),\"class\"===r?m+=t||o?`c.add(${s})`:\"null\":o&&(m+=`d[s](n,${s})`),m},v=t?`!function(){${h}${$(t)}}()`:o?`!function(){try{${h}var e=localStorage.getItem('${n}');if('system'===e||(!e&&${u})){var t='${i}',m=window.matchMedia(t);if(m.media!==t||m.matches){${$(\"dark\")}}else{${$(\"light\")}}}else if(e){${l?`var x=${JSON.stringify(l)};`:\"\"}${$(l?\"x[e]\":\"e\",!0)}}${u?\"\":\"else{\"+$(s,!1,!1)+\"}\"}${y}}catch(e){}}()`:`!function(){try{${h}var e=localStorage.getItem('${n}');if(e){${l?`var x=${JSON.stringify(l)};`:\"\"}${$(l?\"x[e]\":\"e\",!0)}}else{${$(s,!1,!1)};}${y}}catch(t){}}();`;/*#__PURE__*/return e.createElement(\"script\",{nonce:d,dangerouslySetInnerHTML:{__html:v}})},()=>!0),S=(e,t)=>{if(d)return;let n;try{n=localStorage.getItem(e)||void 0}catch(e){}return n||t},b=()=>{const e=document.createElement(\"style\");return e.appendChild(document.createTextNode(\"*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\")),document.head.appendChild(e),()=>{window.getComputedStyle(document.body),setTimeout(()=>{document.head.removeChild(e)},1)}},p=e=>(e||(e=window.matchMedia(i)),e.matches?\"dark\":\"light\");export{$ as ThemeProvider,y as useTheme};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/lucide-react@0.294.0_react@18.3.1/node_modules/lucide-react/src/defaultAttributes.ts"],"sourcesContent":["export default {\n  xmlns: 'http://www.w3.org/2000/svg',\n  width: 24,\n  height: 24,\n  viewBox: '0 0 24 24',\n  fill: 'none',\n  stroke: 'currentColor',\n  strokeWidth: 2,\n  strokeLinecap: 'round',\n  strokeLinejoin: 'round',\n};\n"],"names":[],"mappings":";;;;;;;;AAAA,IAAe,oBAAA;IACb,OAAO;IACP,OAAO;IACP,QAAQ;IACR,SAAS;IACT,MAAM;IACN,QAAQ;IACR,aAAa;IACb,eAAe;IACf,gBAAgB;AAClB"}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/lucide-react@0.294.0_react@18.3.1/node_modules/lucide-react/src/createLucideIcon.ts"],"sourcesContent":["import {\n  forwardRef,\n  createElement,\n  ReactSVG,\n  SVGProps,\n  ForwardRefExoticComponent,\n  RefAttributes,\n} from 'react';\nimport defaultAttributes from './defaultAttributes';\n\nexport type IconNode = [elementName: keyof ReactSVG, attrs: Record<string, string>][];\n\nexport type SVGAttributes = Partial<SVGProps<SVGSVGElement>>;\ntype ComponentAttributes = RefAttributes<SVGSVGElement> & SVGAttributes;\n\nexport interface LucideProps extends ComponentAttributes {\n  size?: string | number;\n  absoluteStrokeWidth?: boolean;\n}\n\nexport type LucideIcon = ForwardRefExoticComponent<LucideProps>;\n/**\n * Converts string to KebabCase\n * Copied from scripts/helper. If anyone knows how to properly import it here\n * then please fix it.\n *\n * @param {string} string\n * @returns {string} A kebabized string\n */\nexport const toKebabCase = (string: string) =>\n  string\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .toLowerCase()\n    .trim();\n\nconst createLucideIcon = (iconName: string, iconNode: IconNode): LucideIcon => {\n  const Component = forwardRef<SVGSVGElement, LucideProps>(\n    ({ color = 'currentColor', size = 24, strokeWidth = 2, absoluteStrokeWidth, className = '', children, ...rest }, ref) =>\n      createElement(\n        'svg',\n        {\n          ref,\n          ...defaultAttributes,\n          width: size,\n          height: size,\n          stroke: color,\n          strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n          className: ['lucide', `lucide-${toKebabCase(iconName)}`, className].join(' '),\n          ...rest,\n        },\n        [\n          ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),\n          ...(Array.isArray(children) ? children : [children]),\n        ]\n      )\n  );\n\n  Component.displayName = `${iconName}`;\n\n  return Component;\n};\n\nexport default createLucideIcon;\n"],"names":[],"mappings":";;;;;;;;;;;;;;AA6Ba,MAAA,cAAc,CAAC,SAC1B,OACG,OAAA,CAAQ,sBAAsB,SAC9B,WAAY,GACZ,IAAK;AAEJ,MAAA,mBAAmB,CAAC,UAAkB;IAC1C,MAAM,YAAY,CAAA,GAAA,6UAAA,CAAA,aAAA,EAChB,CAAC,EAAE,QAAQ,cAAA,EAAgB,OAAO,EAAI,EAAA,cAAc,CAAG,EAAA,mBAAA,EAAqB,YAAY,EAAA,EAAI,QAAa,EAAA,GAAA,MAAA,EAAQ,MAC/G,CAAA,GAAA,6UAAA,CAAA,gBAAA,EACE,OACA;YACE;YACA,GAAG,0PAAA,CAAA,UAAA;YACH,OAAO;YACP,QAAQ;YACR,QAAQ;YACR,aAAa,sBAAsB,OAAO,eAAe,KAAK,OAAO,QAAQ;YAC7E,WAAW;gBAAC;gBAAU,CAAU,OAAA,EAAA,YAAY,UAAa,CAAA;gBAAA;aAAW,CAAA,IAAA,CAAK;YACzE,GAAG,IAAA;QACL,GACA;eACK,SAAS,GAAA,CAAI,CAAC,CAAC,KAAK,MAAW,GAAA,CAAA,GAAA,6UAAA,CAAA,gBAAA,EAAc,KAAK;eACjD,MAAM,OAAA,CAAQ,YAAY,WAAW;gBAAC;aAAQ;SACpD;IAIN,UAAU,WAAA,GAAc,CAAG,EAAA,SAAA,CAAA;IAEpB,OAAA;AACT"}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 205, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/lucide-react@0.294.0_react@18.3.1/node_modules/lucide-react/src/icons/alert-triangle.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name AlertTriangle\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMjEuNzMgMTgtOC0xNGEyIDIgMCAwIDAtMy40OCAwbC04IDE0QTIgMiAwIDAgMCA0IDIxaDE2YTIgMiAwIDAgMCAxLjczLTNaIiAvPgogIDxwYXRoIGQ9Ik0xMiA5djQiIC8+CiAgPHBhdGggZD0iTTEyIDE3aC4wMSIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/alert-triangle\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst AlertTriangle = createLucideIcon('AlertTriangle', [\n  [\n    'path',\n    {\n      d: 'm21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z',\n      key: 'c3ski4',\n    },\n  ],\n  ['path', { d: 'M12 9v4', key: 'juzpu7' }],\n  ['path', { d: 'M12 17h.01', key: 'p32p05' }],\n]);\n\nexport default AlertTriangle;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,MAAA,gBAAgB,CAAA,GAAA,yPAAA,CAAA,UAAA,EAAiB,iBAAiB;IACtD;QACE;QACA;YACE,GAAG;YACH,KAAK;QACP;KACF;IACA;QAAC;QAAQ;YAAE,GAAG;YAAW,KAAK;QAAA;KAAU;IACxC;QAAC;QAAQ;YAAE,GAAG;YAAc,KAAK;QAAA;KAAU;CAC5C"}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 256, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/lucide-react@0.294.0_react@18.3.1/node_modules/lucide-react/src/icons/refresh-cw.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name RefreshCw\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMyAxMmE5IDkgMCAwIDEgOS05IDkuNzUgOS43NSAwIDAgMSA2Ljc0IDIuNzRMMjEgOCIgLz4KICA8cGF0aCBkPSJNMjEgM3Y1aC01IiAvPgogIDxwYXRoIGQ9Ik0yMSAxMmE5IDkgMCAwIDEtOSA5IDkuNzUgOS43NSAwIDAgMS02Ljc0LTIuNzRMMyAxNiIgLz4KICA8cGF0aCBkPSJNOCAxNkgzdjUiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/refresh-cw\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst RefreshCw = createLucideIcon('RefreshCw', [\n  ['path', { d: 'M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8', key: 'v9h5vc' }],\n  ['path', { d: 'M21 3v5h-5', key: '1q7to0' }],\n  ['path', { d: 'M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16', key: '3uifl3' }],\n  ['path', { d: 'M8 16H3v5', key: '1cv678' }],\n]);\n\nexport default RefreshCw;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,MAAA,YAAY,CAAA,GAAA,yPAAA,CAAA,UAAA,EAAiB,aAAa;IAC9C;QAAC;QAAQ;YAAE,GAAG;YAAsD,KAAK;QAAA;KAAU;IACnF;QAAC;QAAQ;YAAE,GAAG;YAAc,KAAK;QAAA;KAAU;IAC3C;QAAC;QAAQ;YAAE,GAAG;YAAuD,KAAK;QAAA;KAAU;IACpF;QAAC;QAAQ;YAAE,GAAG;YAAa,KAAK;QAAA;KAAU;CAC3C"}},
    {"offset": {"line": 299, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 314, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/lucide-react@0.294.0_react@18.3.1/node_modules/lucide-react/src/icons/home.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Home\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMyA5IDktNyA5IDd2MTFhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJ6IiAvPgogIDxwb2x5bGluZSBwb2ludHM9IjkgMjIgOSAxMiAxNSAxMiAxNSAyMiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/home\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Home = createLucideIcon('Home', [\n  ['path', { d: 'm3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z', key: 'y5dka4' }],\n  ['polyline', { points: '9 22 9 12 15 12 15 22', key: 'e2us08' }],\n]);\n\nexport default Home;\n"],"names":[],"mappings":";;;;;;;;;;;AAaM,MAAA,OAAO,CAAA,GAAA,yPAAA,CAAA,UAAA,EAAiB,QAAQ;IACpC;QAAC;QAAQ;YAAE,GAAG;YAAkD,KAAK;QAAA;KAAU;IAC/E;QAAC;QAAY;YAAE,QAAQ;YAAyB,KAAK;QAAA;KAAU;CAChE"}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@18.3.23_react@18.3.1/node_modules/@radix-ui/react-compose-refs/src/compose-refs.tsx"],"sourcesContent":["import * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    return ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup == 'function') {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup == 'function') {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n"],"names":[],"mappings":";;;;;;;;AAQA,SAAS,OAAU,GAAA,EAAqB,KAAA;IACtC,IAAI,OAAO,QAAQ,YAAY;QAC7B,OAAO,IAAI;IACb,OAAA,IAAW,QAAQ,QAAQ,QAAQ,KAAA,GAAW;QAC5C,IAAI,OAAA,GAAU;IAChB;AACF;AAMA,SAAS,YAAA,GAAkB,IAAA;IACzB,OAAO,CAAC;QACN,IAAI,aAAa;QACjB,MAAM,WAAW,KAAK,GAAA,CAAI,CAAC;YACzB,MAAM,UAAU,OAAO,KAAK;YAC5B,IAAI,CAAC,cAAc,OAAO,WAAW,YAAY;gBAC/C,aAAa;YACf;YACA,OAAO;QACT;QAMA,IAAI,YAAY;YACd,OAAO;gBACL,IAAA,IAAS,IAAI,GAAG,IAAI,SAAS,MAAA,EAAQ,IAAK;oBACxC,MAAM,UAAU,QAAA,CAAS,EAAC;oBAC1B,IAAI,OAAO,WAAW,YAAY;wBAChC;oBACF,OAAO;wBACL,OAAO,IAAA,CAAK,EAAC,EAAG;oBAClB;gBACF;YACF;QACF;IACF;AACF;AAMA,SAAS,gBAAA,GAAsB,IAAA;IAE7B,OAAa,8UAAA,WAAA,CAAY,eAAe,OAAO;AACjD"}},
    {"offset": {"line": 402, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 407, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@18.3.23_react@18.3.1/node_modules/@radix-ui/react-slot/src/slot.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n  const Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n\n    if (slottable) {\n      // the new element to render is the one passed as a child of `Slottable`\n      const newElement = slottable.props.children;\n\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          // because the new element will be the one rendered, we are only interested\n          // in grabbing its children (`newElement.props.children`)\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement)\n            ? (newElement.props as { children: React.ReactNode }).children\n            : null;\n        } else {\n          return child;\n        }\n      });\n\n      return (\n        <SlotClone {...slotProps} ref={forwardedRef}>\n          {React.isValidElement(newElement)\n            ? React.cloneElement(newElement, undefined, newChildren)\n            : null}\n        </SlotClone>\n      );\n    }\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {children}\n      </SlotClone>\n    );\n  });\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot('Slot');\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ function createSlotClone(ownerName: string) {\n  const SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props = mergeProps(slotProps, children.props as AnyProps);\n      // do not pass ref to React.Fragment for React 19 compatibility\n      if (children.type !== React.Fragment) {\n        props.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props);\n    }\n\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol('radix.slottable');\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __radixId: symbol;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable('Slottable');\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<SlottableProps, typeof Slottable> {\n  return (\n    React.isValidElement(child) &&\n    typeof child.type === 'function' &&\n    '__radixId' in child.type &&\n    child.type.__radixId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Slot as Root,\n};\nexport type { SlotProps };\n"],"names":["Slot","props","Slottable","Fragment"],"mappings":"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"}},
    {"offset": {"line": 538, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 543, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs"],"sourcesContent":["function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;"],"names":[],"mappings":";;;;AAAA,SAAS,EAAE,CAAC;IAAE,IAAI,GAAE,GAAE,IAAE;IAAG,IAAG,YAAU,OAAO,KAAG,YAAU,OAAO,GAAE,KAAG;SAAO,IAAG,YAAU,OAAO,GAAE,IAAG,MAAM,OAAO,CAAC,IAAG;QAAC,IAAI,IAAE,EAAE,MAAM;QAAC,IAAI,IAAE,GAAE,IAAE,GAAE,IAAI,CAAC,CAAC,EAAE,IAAE,CAAC,IAAE,EAAE,CAAC,CAAC,EAAE,CAAC,KAAG,CAAC,KAAG,CAAC,KAAG,GAAG,GAAE,KAAG,CAAC;IAAC,OAAM,IAAI,KAAK,EAAE,CAAC,CAAC,EAAE,IAAE,CAAC,KAAG,CAAC,KAAG,GAAG,GAAE,KAAG,CAAC;IAAE,OAAO;AAAC;AAAQ,SAAS;IAAO,IAAI,IAAI,GAAE,GAAE,IAAE,GAAE,IAAE,IAAG,IAAE,UAAU,MAAM,EAAC,IAAE,GAAE,IAAI,CAAC,IAAE,SAAS,CAAC,EAAE,KAAG,CAAC,IAAE,EAAE,EAAE,KAAG,CAAC,KAAG,CAAC,KAAG,GAAG,GAAE,KAAG,CAAC;IAAE,OAAO;AAAC;uCAAgB"}},
    {"offset": {"line": 561, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 566, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/class-variance-authority@0.7.1/node_modules/class-variance-authority/dist/index.mjs"],"sourcesContent":["/**\n * Copyright 2022 Joe Bell. All rights reserved.\n *\n * This file is licensed to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with the\n * License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */ import { clsx } from \"clsx\";\nconst falsyToString = (value)=>typeof value === \"boolean\" ? `${value}` : value === 0 ? \"0\" : value;\nexport const cx = clsx;\nexport const cva = (base, config)=>(props)=>{\n        var _config_compoundVariants;\n        if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);\n        const { variants, defaultVariants } = config;\n        const getVariantClassNames = Object.keys(variants).map((variant)=>{\n            const variantProp = props === null || props === void 0 ? void 0 : props[variant];\n            const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];\n            if (variantProp === null) return null;\n            const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);\n            return variants[variant][variantKey];\n        });\n        const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param)=>{\n            let [key, value] = param;\n            if (value === undefined) {\n                return acc;\n            }\n            acc[key] = value;\n            return acc;\n        }, {});\n        const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param)=>{\n            let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;\n            return Object.entries(compoundVariantOptions).every((param)=>{\n                let [key, value] = param;\n                return Array.isArray(value) ? value.includes({\n                    ...defaultVariants,\n                    ...propsWithoutUndefined\n                }[key]) : ({\n                    ...defaultVariants,\n                    ...propsWithoutUndefined\n                })[key] === value;\n            }) ? [\n                ...acc,\n                cvClass,\n                cvClassName\n            ] : acc;\n        }, []);\n        return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);\n    };\n\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;CAcC;;;;;;;AACD,MAAM,gBAAgB,CAAC,QAAQ,OAAO,UAAU,YAAY,CAAC,EAAE,MAAM,CAAC,GAAG,UAAU,IAAI,MAAM;AACtF,MAAM,KAAK,yLAAA,CAAA,OAAI;AACf,MAAM,MAAM,CAAC,MAAM,SAAS,CAAC;QAC5B,IAAI;QACJ,IAAI,CAAC,WAAW,QAAQ,WAAW,KAAK,IAAI,KAAK,IAAI,OAAO,QAAQ,KAAK,MAAM,OAAO,GAAG,MAAM,UAAU,QAAQ,UAAU,KAAK,IAAI,KAAK,IAAI,MAAM,KAAK,EAAE,UAAU,QAAQ,UAAU,KAAK,IAAI,KAAK,IAAI,MAAM,SAAS;QACvN,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE,GAAG;QACtC,MAAM,uBAAuB,OAAO,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;YACpD,MAAM,cAAc,UAAU,QAAQ,UAAU,KAAK,IAAI,KAAK,IAAI,KAAK,CAAC,QAAQ;YAChF,MAAM,qBAAqB,oBAAoB,QAAQ,oBAAoB,KAAK,IAAI,KAAK,IAAI,eAAe,CAAC,QAAQ;YACrH,IAAI,gBAAgB,MAAM,OAAO;YACjC,MAAM,aAAa,cAAc,gBAAgB,cAAc;YAC/D,OAAO,QAAQ,CAAC,QAAQ,CAAC,WAAW;QACxC;QACA,MAAM,wBAAwB,SAAS,OAAO,OAAO,CAAC,OAAO,MAAM,CAAC,CAAC,KAAK;YACtE,IAAI,CAAC,KAAK,MAAM,GAAG;YACnB,IAAI,UAAU,WAAW;gBACrB,OAAO;YACX;YACA,GAAG,CAAC,IAAI,GAAG;YACX,OAAO;QACX,GAAG,CAAC;QACJ,MAAM,+BAA+B,WAAW,QAAQ,WAAW,KAAK,IAAI,KAAK,IAAI,CAAC,2BAA2B,OAAO,gBAAgB,MAAM,QAAQ,6BAA6B,KAAK,IAAI,KAAK,IAAI,yBAAyB,MAAM,CAAC,CAAC,KAAK;YACvO,IAAI,EAAE,OAAO,OAAO,EAAE,WAAW,WAAW,EAAE,GAAG,wBAAwB,GAAG;YAC5E,OAAO,OAAO,OAAO,CAAC,wBAAwB,KAAK,CAAC,CAAC;gBACjD,IAAI,CAAC,KAAK,MAAM,GAAG;gBACnB,OAAO,MAAM,OAAO,CAAC,SAAS,MAAM,QAAQ,CAAC;oBACzC,GAAG,eAAe;oBAClB,GAAG,qBAAqB;gBAC5B,CAAC,CAAC,IAAI,IAAI,CAAC;oBACP,GAAG,eAAe;oBAClB,GAAG,qBAAqB;gBAC5B,CAAC,CAAC,CAAC,IAAI,KAAK;YAChB,KAAK;mBACE;gBACH;gBACA;aACH,GAAG;QACR,GAAG,EAAE;QACL,OAAO,GAAG,MAAM,sBAAsB,8BAA8B,UAAU,QAAQ,UAAU,KAAK,IAAI,KAAK,IAAI,MAAM,KAAK,EAAE,UAAU,QAAQ,UAAU,KAAK,IAAI,KAAK,IAAI,MAAM,SAAS;IAChM"}},
    {"offset": {"line": 627, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 632, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/stacktrace-parser@0.1.11/node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js"],"sourcesContent":["var UNKNOWN_FUNCTION = '<unknown>';\n/**\n * This parses the different stack traces and puts them into one format\n * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)\n */\n\nfunction parse(stackString) {\n  var lines = stackString.split('\\n');\n  return lines.reduce(function (stack, line) {\n    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);\n\n    if (parseResult) {\n      stack.push(parseResult);\n    }\n\n    return stack;\n  }, []);\n}\nvar chromeRe = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\\/|[a-z]:\\\\|\\\\\\\\).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar chromeEvalRe = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\nfunction parseChrome(line) {\n  var parts = chromeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n\n  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n  var submatch = chromeEvalRe.exec(parts[2]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1]; // url\n\n    parts[3] = submatch[2]; // line\n\n    parts[4] = submatch[3]; // column\n  }\n\n  return {\n    file: !isNative ? parts[2] : null,\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: isNative ? [parts[2]] : [],\n    lineNumber: parts[3] ? +parts[3] : null,\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar winjsRe = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseWinjs(line) {\n  var parts = winjsRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar geckoRe = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar geckoEvalRe = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nfunction parseGecko(line) {\n  var parts = geckoRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n  var submatch = geckoEvalRe.exec(parts[3]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1];\n    parts[4] = submatch[2];\n    parts[5] = null; // no column when eval\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: parts[2] ? parts[2].split(',') : [],\n    lineNumber: parts[4] ? +parts[4] : null,\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar javaScriptCoreRe = /^\\s*(?:([^@]*)(?:\\((.*?)\\))?@)?(\\S.*?):(\\d+)(?::(\\d+))?\\s*$/i;\n\nfunction parseJSC(line) {\n  var parts = javaScriptCoreRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[4],\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar nodeRe = /^\\s*at (?:((?:\\[object object\\])?[^\\\\/]+(?: \\[as \\S+\\])?) )?\\(?(.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseNode(line) {\n  var parts = nodeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nexport { parse };\n"],"names":[],"mappings":";;;AAAA,IAAI,mBAAmB;AACvB;;;CAGC,GAED,SAAS,MAAM,WAAW;IACxB,IAAI,QAAQ,YAAY,KAAK,CAAC;IAC9B,OAAO,MAAM,MAAM,CAAC,SAAU,KAAK,EAAE,IAAI;QACvC,IAAI,cAAc,YAAY,SAAS,WAAW,SAAS,WAAW,SAAS,UAAU,SAAS,SAAS;QAE3G,IAAI,aAAa;YACf,MAAM,IAAI,CAAC;QACb;QAEA,OAAO;IACT,GAAG,EAAE;AACP;AACA,IAAI,WAAW;AACf,IAAI,eAAe;AAEnB,SAAS,YAAY,IAAI;IACvB,IAAI,QAAQ,SAAS,IAAI,CAAC;IAE1B,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,IAAI,WAAW,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC,cAAc,GAAG,gBAAgB;IAE7E,IAAI,SAAS,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC,YAAY,GAAG,gBAAgB;IAEzE,IAAI,WAAW,aAAa,IAAI,CAAC,KAAK,CAAC,EAAE;IAEzC,IAAI,UAAU,YAAY,MAAM;QAC9B,iEAAiE;QACjE,KAAK,CAAC,EAAE,GAAG,QAAQ,CAAC,EAAE,EAAE,MAAM;QAE9B,KAAK,CAAC,EAAE,GAAG,QAAQ,CAAC,EAAE,EAAE,OAAO;QAE/B,KAAK,CAAC,EAAE,GAAG,QAAQ,CAAC,EAAE,EAAE,SAAS;IACnC;IAEA,OAAO;QACL,MAAM,CAAC,WAAW,KAAK,CAAC,EAAE,GAAG;QAC7B,YAAY,KAAK,CAAC,EAAE,IAAI;QACxB,WAAW,WAAW;YAAC,KAAK,CAAC,EAAE;SAAC,GAAG,EAAE;QACrC,YAAY,KAAK,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG;QACnC,QAAQ,KAAK,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG;IACjC;AACF;AAEA,IAAI,UAAU;AAEd,SAAS,WAAW,IAAI;IACtB,IAAI,QAAQ,QAAQ,IAAI,CAAC;IAEzB,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,OAAO;QACL,MAAM,KAAK,CAAC,EAAE;QACd,YAAY,KAAK,CAAC,EAAE,IAAI;QACxB,WAAW,EAAE;QACb,YAAY,CAAC,KAAK,CAAC,EAAE;QACrB,QAAQ,KAAK,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG;IACjC;AACF;AAEA,IAAI,UAAU;AACd,IAAI,cAAc;AAElB,SAAS,WAAW,IAAI;IACtB,IAAI,QAAQ,QAAQ,IAAI,CAAC;IAEzB,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,IAAI,SAAS,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC,aAAa,CAAC;IACxD,IAAI,WAAW,YAAY,IAAI,CAAC,KAAK,CAAC,EAAE;IAExC,IAAI,UAAU,YAAY,MAAM;QAC9B,0DAA0D;QAC1D,KAAK,CAAC,EAAE,GAAG,QAAQ,CAAC,EAAE;QACtB,KAAK,CAAC,EAAE,GAAG,QAAQ,CAAC,EAAE;QACtB,KAAK,CAAC,EAAE,GAAG,MAAM,sBAAsB;IACzC;IAEA,OAAO;QACL,MAAM,KAAK,CAAC,EAAE;QACd,YAAY,KAAK,CAAC,EAAE,IAAI;QACxB,WAAW,KAAK,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,EAAE;QAC9C,YAAY,KAAK,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG;QACnC,QAAQ,KAAK,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG;IACjC;AACF;AAEA,IAAI,mBAAmB;AAEvB,SAAS,SAAS,IAAI;IACpB,IAAI,QAAQ,iBAAiB,IAAI,CAAC;IAElC,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,OAAO;QACL,MAAM,KAAK,CAAC,EAAE;QACd,YAAY,KAAK,CAAC,EAAE,IAAI;QACxB,WAAW,EAAE;QACb,YAAY,CAAC,KAAK,CAAC,EAAE;QACrB,QAAQ,KAAK,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG;IACjC;AACF;AAEA,IAAI,SAAS;AAEb,SAAS,UAAU,IAAI;IACrB,IAAI,QAAQ,OAAO,IAAI,CAAC;IAExB,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,OAAO;QACL,MAAM,KAAK,CAAC,EAAE;QACd,YAAY,KAAK,CAAC,EAAE,IAAI;QACxB,WAAW,EAAE;QACb,YAAY,CAAC,KAAK,CAAC,EAAE;QACrB,QAAQ,KAAK,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG;IACjC;AACF"}},
    {"offset": {"line": 741, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 745, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js"],"sourcesContent":["/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 906, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 910, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js"],"sourcesContent":["'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-is.production.min.js');\n} else {\n  module.exports = require('./cjs/react-is.development.js');\n}\n"],"names":[],"mappings":";;AAAA;AAEA;;OAEO;IACL,OAAO,OAAO;AAChB"}},
    {"offset": {"line": 918, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 922, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hoist-non-react-statics@3.3.2/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"],"sourcesContent":["'use strict';\n\nvar reactIs = require('react-is');\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n"],"names":[],"mappings":"AAAA;AAEA,IAAI;AAEJ;;;CAGC,GACD,IAAI,gBAAgB;IAClB,mBAAmB;IACnB,aAAa;IACb,cAAc;IACd,cAAc;IACd,aAAa;IACb,iBAAiB;IACjB,0BAA0B;IAC1B,0BAA0B;IAC1B,QAAQ;IACR,WAAW;IACX,MAAM;AACR;AACA,IAAI,gBAAgB;IAClB,MAAM;IACN,QAAQ;IACR,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,WAAW;IACX,OAAO;AACT;AACA,IAAI,sBAAsB;IACxB,YAAY;IACZ,QAAQ;IACR,cAAc;IACd,aAAa;IACb,WAAW;AACb;AACA,IAAI,eAAe;IACjB,YAAY;IACZ,SAAS;IACT,cAAc;IACd,aAAa;IACb,WAAW;IACX,MAAM;AACR;AACA,IAAI,eAAe,CAAC;AACpB,YAAY,CAAC,QAAQ,UAAU,CAAC,GAAG;AACnC,YAAY,CAAC,QAAQ,IAAI,CAAC,GAAG;AAE7B,SAAS,WAAW,SAAS;IAC3B,yBAAyB;IACzB,IAAI,QAAQ,MAAM,CAAC,YAAY;QAC7B,OAAO;IACT,EAAE,yBAAyB;IAG3B,OAAO,YAAY,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI;AAChD;AAEA,IAAI,iBAAiB,OAAO,cAAc;AAC1C,IAAI,sBAAsB,OAAO,mBAAmB;AACpD,IAAI,wBAAwB,OAAO,qBAAqB;AACxD,IAAI,2BAA2B,OAAO,wBAAwB;AAC9D,IAAI,iBAAiB,OAAO,cAAc;AAC1C,IAAI,kBAAkB,OAAO,SAAS;AACtC,SAAS,qBAAqB,eAAe,EAAE,eAAe,EAAE,SAAS;IACvE,IAAI,OAAO,oBAAoB,UAAU;QACvC,4CAA4C;QAC5C,IAAI,iBAAiB;YACnB,IAAI,qBAAqB,eAAe;YAExC,IAAI,sBAAsB,uBAAuB,iBAAiB;gBAChE,qBAAqB,iBAAiB,oBAAoB;YAC5D;QACF;QAEA,IAAI,OAAO,oBAAoB;QAE/B,IAAI,uBAAuB;YACzB,OAAO,KAAK,MAAM,CAAC,sBAAsB;QAC3C;QAEA,IAAI,gBAAgB,WAAW;QAC/B,IAAI,gBAAgB,WAAW;QAE/B,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,EAAE,EAAG;YACpC,IAAI,MAAM,IAAI,CAAC,EAAE;YAEjB,IAAI,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC,CAAC,aAAa,SAAS,CAAC,IAAI,KAAK,CAAC,CAAC,iBAAiB,aAAa,CAAC,IAAI,KAAK,CAAC,CAAC,iBAAiB,aAAa,CAAC,IAAI,GAAG;gBAC7I,IAAI,aAAa,yBAAyB,iBAAiB;gBAE3D,IAAI;oBACF,2CAA2C;oBAC3C,eAAe,iBAAiB,KAAK;gBACvC,EAAE,OAAO,GAAG,CAAC;YACf;QACF;IACF;IAEA,OAAO;AACT;AAEA,OAAO,OAAO,GAAG"}},
    {"offset": {"line": 1009, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1014, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/constants/index.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/core/sendFeedback.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/util/debug-build.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/util/isScreenshotSupported.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/util/mergeOptions.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/core/components/Actor.css.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/util/setAttributesNS.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/core/components/FeedbackIcon.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/core/components/Actor.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/core/createMainStyles.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/core/integration.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/core/getFeedback.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/node_modules/preact/dist/preact.mjs","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/node_modules/preact/hooks/dist/hooks.mjs","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/modal/components/SentryLogo.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/modal/components/DialogHeader.tsx","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/util/validate.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/modal/components/Form.tsx","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/modal/components/SuccessIcon.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/modal/components/Dialog.tsx","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/modal/components/Dialog.css.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/modal/integration.tsx","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/screenshot/components/IconClose.tsx","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/screenshot/components/ScreenshotInput.css.ts","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/screenshot/components/Toolbar.tsx","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/screenshot/components/useTakeScreenshot.tsx","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/screenshot/components/ScreenshotEditor.tsx","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+feedback@9.37.0/node_modules/@sentry-internal/feedback/src/screenshot/integration.ts"],"sourcesContent":["import { GLOBAL_OBJ } from '@sentry/core';\n\n// exporting a separate copy of `WINDOW` rather than exporting the one from `@sentry/browser`\n// prevents the browser package from being bundled in the CDN bundle, and avoids a\n// circular dependency between the browser and feedback packages\nexport const WINDOW = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\nexport const DOCUMENT = WINDOW.document;\nexport const NAVIGATOR = WINDOW.navigator;\n\nexport const TRIGGER_LABEL = 'Report a Bug';\nexport const CANCEL_BUTTON_LABEL = 'Cancel';\nexport const SUBMIT_BUTTON_LABEL = 'Send Bug Report';\nexport const CONFIRM_BUTTON_LABEL = 'Confirm';\nexport const FORM_TITLE = 'Report a Bug';\nexport const EMAIL_PLACEHOLDER = 'your.email@example.org';\nexport const EMAIL_LABEL = 'Email';\nexport const MESSAGE_PLACEHOLDER = \"What's the bug? What did you expect?\";\nexport const MESSAGE_LABEL = 'Description';\nexport const NAME_PLACEHOLDER = 'Your Name';\nexport const NAME_LABEL = 'Name';\nexport const SUCCESS_MESSAGE_TEXT = 'Thank you for your report!';\nexport const IS_REQUIRED_LABEL = '(required)';\nexport const ADD_SCREENSHOT_LABEL = 'Add a screenshot';\nexport const REMOVE_SCREENSHOT_LABEL = 'Remove screenshot';\n\nexport const FEEDBACK_WIDGET_SOURCE = 'widget';\nexport const FEEDBACK_API_SOURCE = 'api';\n\nexport const SUCCESS_MESSAGE_TIMEOUT = 5000;\n","import type { Event, EventHint, SendFeedback, SendFeedbackParams, TransportMakeRequestResponse } from '@sentry/core';\nimport { captureFeedback, getClient, getCurrentScope, getLocationHref } from '@sentry/core';\nimport { FEEDBACK_API_SOURCE } from '../constants';\n\n/**\n * Public API to send a Feedback item to Sentry\n */\nexport const sendFeedback: SendFeedback = (\n  params: SendFeedbackParams,\n  hint: EventHint & { includeReplay?: boolean } = { includeReplay: true },\n): Promise<string> => {\n  if (!params.message) {\n    throw new Error('Unable to submit feedback with empty message');\n  }\n\n  // We want to wait for the feedback to be sent (or not)\n  const client = getClient();\n\n  if (!client) {\n    throw new Error('No client setup, cannot send feedback.');\n  }\n\n  if (params.tags && Object.keys(params.tags).length) {\n    getCurrentScope().setTags(params.tags);\n  }\n  const eventId = captureFeedback(\n    {\n      source: FEEDBACK_API_SOURCE,\n      url: getLocationHref(),\n      ...params,\n    },\n    hint,\n  );\n\n  // We want to wait for the feedback to be sent (or not)\n  return new Promise<string>((resolve, reject) => {\n    // After 5s, we want to clear anyhow\n    const timeout = setTimeout(() => reject('Unable to determine if Feedback was correctly sent.'), 5_000);\n\n    const cleanup = client.on('afterSendEvent', (event: Event, response: TransportMakeRequestResponse) => {\n      if (event.event_id !== eventId) {\n        return;\n      }\n\n      clearTimeout(timeout);\n      cleanup();\n\n      // Require valid status codes, otherwise can assume feedback was not sent successfully\n      if (\n        response &&\n        typeof response.statusCode === 'number' &&\n        response.statusCode >= 200 &&\n        response.statusCode < 300\n      ) {\n        return resolve(eventId);\n      }\n\n      if (response && typeof response.statusCode === 'number' && response.statusCode === 0) {\n        return reject(\n          'Unable to send Feedback. This is because of network issues, or because you are using an ad-blocker.',\n        );\n      }\n\n      if (response && typeof response.statusCode === 'number' && response.statusCode === 403) {\n        return reject(\n          'Unable to send Feedback. This could be because this domain is not in your list of allowed domains.',\n        );\n      }\n\n      return reject(\n        'Unable to send Feedback. This could be because of network issues, or because you are using an ad-blocker',\n      );\n    });\n  });\n};\n\n/*\n * For reference, the fully built event looks something like this:\n * {\n *     \"type\": \"feedback\",\n *     \"event_id\": \"d2132d31b39445f1938d7e21b6bf0ec4\",\n *     \"timestamp\": 1597977777.6189718,\n *     \"dist\": \"1.12\",\n *     \"platform\": \"javascript\",\n *     \"environment\": \"production\",\n *     \"release\": 42,\n *     \"tags\": {\"transaction\": \"/organizations/:orgId/performance/:eventSlug/\"},\n *     \"sdk\": {\"name\": \"name\", \"version\": \"version\"},\n *     \"user\": {\n *         \"id\": \"123\",\n *         \"username\": \"user\",\n *         \"email\": \"user@site.com\",\n *         \"ip_address\": \"192.168.11.12\",\n *     },\n *     \"request\": {\n *         \"url\": None,\n *         \"headers\": {\n *             \"user-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Safari/605.1.15\"\n *         },\n *     },\n *     \"contexts\": {\n *         \"feedback\": {\n *             \"message\": \"test message\",\n *             \"contact_email\": \"test@example.com\",\n *             \"type\": \"feedback\",\n *         },\n *         \"trace\": {\n *             \"trace_id\": \"4C79F60C11214EB38604F4AE0781BFB2\",\n *             \"span_id\": \"FA90FDEAD5F74052\",\n *             \"type\": \"trace\",\n *         },\n *         \"replay\": {\n *             \"replay_id\": \"e2d42047b1c5431c8cba85ee2a8ab25d\",\n *         },\n *     },\n *   }\n */\n","declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n","import { NAVIGATOR } from '../constants';\n\n/**\n * Mobile browsers do not support `mediaDevices.getDisplayMedia` even though they have the api implemented\n * Instead they return things like `NotAllowedError` when called.\n *\n * It's simpler for us to browser sniff first, and avoid loading the integration if we can.\n *\n * https://stackoverflow.com/a/58879212\n * https://stackoverflow.com/a/3540295\n *\n * `mediaDevices.getDisplayMedia` is also only supported in secure contexts, and return a `mediaDevices is not supported` error, so we should also avoid loading the integration if we can.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia\n */\nexport function isScreenshotSupported(): boolean {\n  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(NAVIGATOR.userAgent)) {\n    return false;\n  }\n  /**\n   * User agent on iPads show as Macintosh, so we need extra checks\n   *\n   * https://forums.developer.apple.com/forums/thread/119186\n   * https://stackoverflow.com/questions/60482650/how-to-detect-ipad-useragent-on-safari-browser\n   */\n  if (/Macintosh/i.test(NAVIGATOR.userAgent) && NAVIGATOR.maxTouchPoints && NAVIGATOR.maxTouchPoints > 1) {\n    return false;\n  }\n  if (!isSecureContext) {\n    return false;\n  }\n  return true;\n}\n","import type { FeedbackFormData, FeedbackInternalOptions } from '@sentry/core';\nimport type { OptionalFeedbackConfiguration } from '../core/types';\n\n/**\n * Quick and dirty deep merge for the Feedback integration options\n */\nexport function mergeOptions(\n  defaultOptions: FeedbackInternalOptions,\n  optionOverrides: OptionalFeedbackConfiguration,\n): FeedbackInternalOptions {\n  return {\n    ...defaultOptions,\n    ...optionOverrides,\n    tags: {\n      ...defaultOptions.tags,\n      ...optionOverrides.tags,\n    },\n    onFormOpen: () => {\n      optionOverrides.onFormOpen?.();\n      defaultOptions.onFormOpen?.();\n    },\n    onFormClose: () => {\n      optionOverrides.onFormClose?.();\n      defaultOptions.onFormClose?.();\n    },\n    onSubmitSuccess: (data: FeedbackFormData, eventId: string) => {\n      optionOverrides.onSubmitSuccess?.(data, eventId);\n      defaultOptions.onSubmitSuccess?.(data, eventId);\n    },\n    onSubmitError: (error: Error) => {\n      optionOverrides.onSubmitError?.(error);\n      defaultOptions.onSubmitError?.(error);\n    },\n    onFormSubmitted: () => {\n      optionOverrides.onFormSubmitted?.();\n      defaultOptions.onFormSubmitted?.();\n    },\n    themeDark: {\n      ...defaultOptions.themeDark,\n      ...optionOverrides.themeDark,\n    },\n    themeLight: {\n      ...defaultOptions.themeLight,\n      ...optionOverrides.themeLight,\n    },\n  };\n}\n","import { DOCUMENT } from '../../constants';\n\n/**\n * Creates <style> element for widget actor (button that opens the dialog)\n */\nexport function createActorStyles(styleNonce?: string): HTMLStyleElement {\n  const style = DOCUMENT.createElement('style');\n  style.textContent = `\n.widget__actor {\n  position: fixed;\n  z-index: var(--z-index);\n  margin: var(--page-margin);\n  inset: var(--actor-inset);\n\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  padding: 16px;\n\n  font-family: inherit;\n  font-size: var(--font-size);\n  font-weight: 600;\n  line-height: 1.14em;\n  text-decoration: none;\n\n  background: var(--actor-background, var(--background));\n  border-radius: var(--actor-border-radius, 1.7em/50%);\n  border: var(--actor-border, var(--border));\n  box-shadow: var(--actor-box-shadow, var(--box-shadow));\n  color: var(--actor-color, var(--foreground));\n  fill: var(--actor-color, var(--foreground));\n  cursor: pointer;\n  opacity: 1;\n  transition: transform 0.2s ease-in-out;\n  transform: translate(0, 0) scale(1);\n}\n.widget__actor[aria-hidden=\"true\"] {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n  transform: translate(0, 16px) scale(0.98);\n}\n\n.widget__actor:hover {\n  background: var(--actor-hover-background, var(--background));\n  filter: var(--interactive-filter);\n}\n\n.widget__actor svg {\n  width: 1.14em;\n  height: 1.14em;\n}\n\n@media (max-width: 600px) {\n  .widget__actor span {\n    display: none;\n  }\n}\n`;\n\n  if (styleNonce) {\n    style.setAttribute('nonce', styleNonce);\n  }\n\n  return style;\n}\n","/**\n * Helper function to set a dict of attributes on element (w/ specified namespace)\n */\nexport function setAttributesNS<T extends SVGElement>(el: T, attributes: Record<string, string>): T {\n  Object.entries(attributes).forEach(([key, val]) => {\n    el.setAttributeNS(null, key, val);\n  });\n  return el;\n}\n","import { WINDOW } from '../../constants';\nimport { setAttributesNS } from '../../util/setAttributesNS';\n\nconst SIZE = 20;\nconst XMLNS = 'http://www.w3.org/2000/svg';\n\n/**\n * Feedback Icon\n */\nexport function FeedbackIcon(): SVGElement {\n  const createElementNS = <K extends keyof SVGElementTagNameMap>(tagName: K): SVGElementTagNameMap[K] =>\n    WINDOW.document.createElementNS(XMLNS, tagName);\n  const svg = setAttributesNS(createElementNS('svg'), {\n    width: `${SIZE}`,\n    height: `${SIZE}`,\n    viewBox: `0 0 ${SIZE} ${SIZE}`,\n    fill: 'var(--actor-color, var(--foreground))',\n  });\n\n  const g = setAttributesNS(createElementNS('g'), {\n    clipPath: 'url(#clip0_57_80)',\n  });\n\n  const path = setAttributesNS(createElementNS('path'), {\n    ['fill-rule']: 'evenodd',\n    ['clip-rule']: 'evenodd',\n    d: 'M15.6622 15H12.3997C12.2129 14.9959 12.031 14.9396 11.8747 14.8375L8.04965 12.2H7.49956V19.1C7.4875 19.3348 7.3888 19.5568 7.22256 19.723C7.05632 19.8892 6.83435 19.9879 6.59956 20H2.04956C1.80193 19.9968 1.56535 19.8969 1.39023 19.7218C1.21511 19.5467 1.1153 19.3101 1.11206 19.0625V12.2H0.949652C0.824431 12.2017 0.700142 12.1783 0.584123 12.1311C0.468104 12.084 0.362708 12.014 0.274155 11.9255C0.185602 11.8369 0.115689 11.7315 0.0685419 11.6155C0.0213952 11.4995 -0.00202913 11.3752 -0.00034808 11.25V3.75C-0.00900498 3.62067 0.0092504 3.49095 0.0532651 3.36904C0.0972798 3.24712 0.166097 3.13566 0.255372 3.04168C0.344646 2.94771 0.452437 2.87327 0.571937 2.82307C0.691437 2.77286 0.82005 2.74798 0.949652 2.75H8.04965L11.8747 0.1625C12.031 0.0603649 12.2129 0.00407221 12.3997 0H15.6622C15.9098 0.00323746 16.1464 0.103049 16.3215 0.278167C16.4966 0.453286 16.5964 0.689866 16.5997 0.9375V3.25269C17.3969 3.42959 18.1345 3.83026 18.7211 4.41679C19.5322 5.22788 19.9878 6.32796 19.9878 7.47502C19.9878 8.62209 19.5322 9.72217 18.7211 10.5333C18.1345 11.1198 17.3969 11.5205 16.5997 11.6974V14.0125C16.6047 14.1393 16.5842 14.2659 16.5395 14.3847C16.4948 14.5035 16.4268 14.6121 16.3394 14.7042C16.252 14.7962 16.147 14.8698 16.0307 14.9206C15.9144 14.9714 15.7891 14.9984 15.6622 15ZM1.89695 10.325H1.88715V4.625H8.33715C8.52423 4.62301 8.70666 4.56654 8.86215 4.4625L12.6872 1.875H14.7247V13.125H12.6872L8.86215 10.4875C8.70666 10.3835 8.52423 10.327 8.33715 10.325H2.20217C2.15205 10.3167 2.10102 10.3125 2.04956 10.3125C1.9981 10.3125 1.94708 10.3167 1.89695 10.325ZM2.98706 12.2V18.1625H5.66206V12.2H2.98706ZM16.5997 9.93612V5.01393C16.6536 5.02355 16.7072 5.03495 16.7605 5.04814C17.1202 5.13709 17.4556 5.30487 17.7425 5.53934C18.0293 5.77381 18.2605 6.06912 18.4192 6.40389C18.578 6.73866 18.6603 7.10452 18.6603 7.47502C18.6603 7.84552 18.578 8.21139 18.4192 8.54616C18.2605 8.88093 18.0293 9.17624 17.7425 9.41071C17.4556 9.64518 17.1202 9.81296 16.7605 9.90191C16.7072 9.91509 16.6536 9.9265 16.5997 9.93612Z',\n  });\n  svg.appendChild(g).appendChild(path);\n\n  const speakerDefs = createElementNS('defs');\n  const speakerClipPathDef = setAttributesNS(createElementNS('clipPath'), {\n    id: 'clip0_57_80',\n  });\n\n  const speakerRect = setAttributesNS(createElementNS('rect'), {\n    width: `${SIZE}`,\n    height: `${SIZE}`,\n    fill: 'white',\n  });\n\n  speakerClipPathDef.appendChild(speakerRect);\n  speakerDefs.appendChild(speakerClipPathDef);\n\n  svg.appendChild(speakerDefs).appendChild(speakerClipPathDef).appendChild(speakerRect);\n\n  return svg;\n}\n","import { DOCUMENT, TRIGGER_LABEL } from '../../constants';\nimport { createActorStyles } from './Actor.css';\nimport { FeedbackIcon } from './FeedbackIcon';\n\nexport interface ActorProps {\n  triggerLabel: string;\n  triggerAriaLabel: string;\n  shadow: ShadowRoot;\n  styleNonce?: string;\n}\n\nexport interface ActorComponent {\n  el: HTMLElement;\n\n  appendToDom: () => void;\n\n  removeFromDom: () => void;\n\n  show: () => void;\n\n  hide: () => void;\n}\n\n/**\n * The sentry-provided button to open the feedback modal\n */\nexport function Actor({ triggerLabel, triggerAriaLabel, shadow, styleNonce }: ActorProps): ActorComponent {\n  const el = DOCUMENT.createElement('button');\n  el.type = 'button';\n  el.className = 'widget__actor';\n  el.ariaHidden = 'false';\n  el.ariaLabel = triggerAriaLabel || triggerLabel || TRIGGER_LABEL;\n  el.appendChild(FeedbackIcon());\n  if (triggerLabel) {\n    const label = DOCUMENT.createElement('span');\n    label.appendChild(DOCUMENT.createTextNode(triggerLabel));\n    el.appendChild(label);\n  }\n\n  const style = createActorStyles(styleNonce);\n\n  return {\n    el,\n    appendToDom(): void {\n      shadow.appendChild(style);\n      shadow.appendChild(el);\n    },\n    removeFromDom(): void {\n      el.remove();\n      style.remove();\n    },\n    show(): void {\n      el.ariaHidden = 'false';\n    },\n    hide(): void {\n      el.ariaHidden = 'true';\n    },\n  };\n}\n","import type { FeedbackInternalOptions } from '@sentry/core';\nimport { DOCUMENT } from '../constants';\n\nconst PURPLE = 'rgba(88, 74, 192, 1)';\n\ninterface InternalTheme extends NonNullable<FeedbackInternalOptions['themeLight']> {\n  border: string;\n  interactiveFilter: string;\n}\n\nconst DEFAULT_LIGHT: InternalTheme = {\n  foreground: '#2b2233',\n  background: '#ffffff',\n  accentForeground: 'white',\n  accentBackground: PURPLE,\n  successColor: '#268d75',\n  errorColor: '#df3338',\n  border: '1.5px solid rgba(41, 35, 47, 0.13)',\n  boxShadow: '0px 4px 24px 0px rgba(43, 34, 51, 0.12)',\n  outline: '1px auto var(--accent-background)',\n  interactiveFilter: 'brightness(95%)',\n};\nconst DEFAULT_DARK: InternalTheme = {\n  foreground: '#ebe6ef',\n  background: '#29232f',\n  accentForeground: 'white',\n  accentBackground: PURPLE,\n  successColor: '#2da98c',\n  errorColor: '#f55459',\n  border: '1.5px solid rgba(235, 230, 239, 0.15)',\n  boxShadow: '0px 4px 24px 0px rgba(43, 34, 51, 0.12)',\n  outline: '1px auto var(--accent-background)',\n  interactiveFilter: 'brightness(150%)',\n};\n\nfunction getThemedCssVariables(theme: InternalTheme): string {\n  return `\n  --foreground: ${theme.foreground};\n  --background: ${theme.background};\n  --accent-foreground: ${theme.accentForeground};\n  --accent-background: ${theme.accentBackground};\n  --success-color: ${theme.successColor};\n  --error-color: ${theme.errorColor};\n  --border: ${theme.border};\n  --box-shadow: ${theme.boxShadow};\n  --outline: ${theme.outline};\n  --interactive-filter: ${theme.interactiveFilter};\n  `;\n}\n\n/**\n * Creates <style> element for widget actor (button that opens the dialog)\n */\nexport function createMainStyles({\n  colorScheme,\n  themeDark,\n  themeLight,\n  styleNonce,\n}: FeedbackInternalOptions): HTMLStyleElement {\n  const style = DOCUMENT.createElement('style');\n  style.textContent = `\n:host {\n  --font-family: system-ui, 'Helvetica Neue', Arial, sans-serif;\n  --font-size: 14px;\n  --z-index: 100000;\n\n  --page-margin: 16px;\n  --inset: auto 0 0 auto;\n  --actor-inset: var(--inset);\n\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n\n  ${colorScheme !== 'system' ? 'color-scheme: only light;' : ''}\n\n  ${getThemedCssVariables(\n    colorScheme === 'dark' ? { ...DEFAULT_DARK, ...themeDark } : { ...DEFAULT_LIGHT, ...themeLight },\n  )}\n}\n\n${\n  colorScheme === 'system'\n    ? `\n@media (prefers-color-scheme: dark) {\n  :host {\n    ${getThemedCssVariables({ ...DEFAULT_DARK, ...themeDark })}\n  }\n}`\n    : ''\n}\n}\n`;\n\n  if (styleNonce) {\n    style.setAttribute('nonce', styleNonce);\n  }\n\n  return style;\n}\n","import type {\n  FeedbackInternalOptions,\n  FeedbackModalIntegration,\n  FeedbackScreenshotIntegration,\n  Integration,\n  IntegrationFn,\n} from '@sentry/core';\nimport { addIntegration, isBrowser, logger } from '@sentry/core';\nimport {\n  ADD_SCREENSHOT_LABEL,\n  CANCEL_BUTTON_LABEL,\n  CONFIRM_BUTTON_LABEL,\n  DOCUMENT,\n  EMAIL_LABEL,\n  EMAIL_PLACEHOLDER,\n  FORM_TITLE,\n  IS_REQUIRED_LABEL,\n  MESSAGE_LABEL,\n  MESSAGE_PLACEHOLDER,\n  NAME_LABEL,\n  NAME_PLACEHOLDER,\n  REMOVE_SCREENSHOT_LABEL,\n  SUBMIT_BUTTON_LABEL,\n  SUCCESS_MESSAGE_TEXT,\n  TRIGGER_LABEL,\n} from '../constants';\nimport { DEBUG_BUILD } from '../util/debug-build';\nimport { isScreenshotSupported } from '../util/isScreenshotSupported';\nimport { mergeOptions } from '../util/mergeOptions';\nimport type { ActorComponent } from './components/Actor';\nimport { Actor } from './components/Actor';\nimport { createMainStyles } from './createMainStyles';\nimport { sendFeedback } from './sendFeedback';\nimport type { OptionalFeedbackConfiguration, OverrideFeedbackConfiguration } from './types';\n\ntype Unsubscribe = () => void;\n\n/**\n * Allow users to capture user feedback and send it to Sentry.\n */\n\ntype BuilderOptions =\n  | {\n      lazyLoadIntegration?: never;\n      getModalIntegration: () => IntegrationFn;\n      getScreenshotIntegration: () => IntegrationFn;\n    }\n  | {\n      // The type here should be `keyof typeof LazyLoadableIntegrations`, but that'll cause a cicrular\n      // dependency with @sentry/core\n      lazyLoadIntegration: (\n        name: 'feedbackModalIntegration' | 'feedbackScreenshotIntegration',\n        scriptNonce?: string,\n      ) => Promise<IntegrationFn>;\n      getModalIntegration?: never;\n      getScreenshotIntegration?: never;\n    };\n\nexport const buildFeedbackIntegration = ({\n  lazyLoadIntegration,\n  getModalIntegration,\n  getScreenshotIntegration,\n}: BuilderOptions): IntegrationFn<\n  Integration & {\n    attachTo(el: Element | string, optionOverrides?: OverrideFeedbackConfiguration): Unsubscribe;\n    createForm(\n      optionOverrides?: OverrideFeedbackConfiguration,\n    ): Promise<ReturnType<FeedbackModalIntegration['createDialog']>>;\n    createWidget(optionOverrides?: OverrideFeedbackConfiguration): ActorComponent;\n    remove(): void;\n  }\n> => {\n  const feedbackIntegration = (({\n    // FeedbackGeneralConfiguration\n    id = 'sentry-feedback',\n    autoInject = true,\n    showBranding = true,\n    isEmailRequired = false,\n    isNameRequired = false,\n    showEmail = true,\n    showName = true,\n    enableScreenshot = true,\n    useSentryUser = {\n      email: 'email',\n      name: 'username',\n    },\n    tags,\n    styleNonce,\n    scriptNonce,\n\n    // FeedbackThemeConfiguration\n    colorScheme = 'system',\n    themeLight = {},\n    themeDark = {},\n\n    // FeedbackTextConfiguration\n    addScreenshotButtonLabel = ADD_SCREENSHOT_LABEL,\n    cancelButtonLabel = CANCEL_BUTTON_LABEL,\n    confirmButtonLabel = CONFIRM_BUTTON_LABEL,\n    emailLabel = EMAIL_LABEL,\n    emailPlaceholder = EMAIL_PLACEHOLDER,\n    formTitle = FORM_TITLE,\n    isRequiredLabel = IS_REQUIRED_LABEL,\n    messageLabel = MESSAGE_LABEL,\n    messagePlaceholder = MESSAGE_PLACEHOLDER,\n    nameLabel = NAME_LABEL,\n    namePlaceholder = NAME_PLACEHOLDER,\n    removeScreenshotButtonLabel = REMOVE_SCREENSHOT_LABEL,\n    submitButtonLabel = SUBMIT_BUTTON_LABEL,\n    successMessageText = SUCCESS_MESSAGE_TEXT,\n    triggerLabel = TRIGGER_LABEL,\n    triggerAriaLabel = '',\n\n    // FeedbackCallbacks\n    onFormOpen,\n    onFormClose,\n    onSubmitSuccess,\n    onSubmitError,\n    onFormSubmitted,\n  }: OptionalFeedbackConfiguration = {}) => {\n    const _options = {\n      id,\n      autoInject,\n      showBranding,\n      isEmailRequired,\n      isNameRequired,\n      showEmail,\n      showName,\n      enableScreenshot,\n      useSentryUser,\n      tags,\n      styleNonce,\n      scriptNonce,\n\n      colorScheme,\n      themeDark,\n      themeLight,\n\n      triggerLabel,\n      triggerAriaLabel,\n      cancelButtonLabel,\n      submitButtonLabel,\n      confirmButtonLabel,\n      formTitle,\n      emailLabel,\n      emailPlaceholder,\n      messageLabel,\n      messagePlaceholder,\n      nameLabel,\n      namePlaceholder,\n      successMessageText,\n      isRequiredLabel,\n      addScreenshotButtonLabel,\n      removeScreenshotButtonLabel,\n\n      onFormClose,\n      onFormOpen,\n      onSubmitError,\n      onSubmitSuccess,\n      onFormSubmitted,\n    };\n\n    let _shadow: ShadowRoot | null = null;\n    let _subscriptions: Unsubscribe[] = [];\n\n    /**\n     * Get the shadow root where we will append css\n     */\n    const _createShadow = (options: FeedbackInternalOptions): ShadowRoot => {\n      if (!_shadow) {\n        const host = DOCUMENT.createElement('div');\n        host.id = String(options.id);\n        DOCUMENT.body.appendChild(host);\n\n        _shadow = host.attachShadow({ mode: 'open' });\n        _shadow.appendChild(createMainStyles(options));\n      }\n      return _shadow as ShadowRoot;\n    };\n\n    const _loadAndRenderDialog = async (\n      options: FeedbackInternalOptions,\n    ): Promise<ReturnType<FeedbackModalIntegration['createDialog']>> => {\n      const screenshotRequired = options.enableScreenshot && isScreenshotSupported();\n\n      let modalIntegration: FeedbackModalIntegration;\n      let screenshotIntegration: FeedbackScreenshotIntegration | undefined;\n\n      try {\n        const modalIntegrationFn = getModalIntegration\n          ? getModalIntegration()\n          : await lazyLoadIntegration('feedbackModalIntegration', scriptNonce);\n        modalIntegration = modalIntegrationFn() as FeedbackModalIntegration;\n        addIntegration(modalIntegration);\n      } catch {\n        DEBUG_BUILD &&\n          logger.error(\n            '[Feedback] Error when trying to load feedback integrations. Try using `feedbackSyncIntegration` in your `Sentry.init`.',\n          );\n        throw new Error('[Feedback] Missing feedback modal integration!');\n      }\n\n      try {\n        const screenshotIntegrationFn = screenshotRequired\n          ? getScreenshotIntegration\n            ? getScreenshotIntegration()\n            : await lazyLoadIntegration('feedbackScreenshotIntegration', scriptNonce)\n          : undefined;\n\n        if (screenshotIntegrationFn) {\n          screenshotIntegration = screenshotIntegrationFn() as FeedbackScreenshotIntegration;\n          addIntegration(screenshotIntegration);\n        }\n      } catch {\n        DEBUG_BUILD &&\n          logger.error('[Feedback] Missing feedback screenshot integration. Proceeding without screenshots.');\n      }\n\n      const dialog = modalIntegration.createDialog({\n        options: {\n          ...options,\n          onFormClose: () => {\n            dialog?.close();\n            options.onFormClose?.();\n          },\n          onFormSubmitted: () => {\n            dialog?.close();\n            options.onFormSubmitted?.();\n          },\n        },\n        screenshotIntegration,\n        sendFeedback,\n        shadow: _createShadow(options),\n      });\n\n      return dialog;\n    };\n\n    const _attachTo = (el: Element | string, optionOverrides: OverrideFeedbackConfiguration = {}): Unsubscribe => {\n      const mergedOptions = mergeOptions(_options, optionOverrides);\n\n      const targetEl =\n        typeof el === 'string' ? DOCUMENT.querySelector(el) : typeof el.addEventListener === 'function' ? el : null;\n\n      if (!targetEl) {\n        DEBUG_BUILD && logger.error('[Feedback] Unable to attach to target element');\n        throw new Error('Unable to attach to target element');\n      }\n\n      let dialog: ReturnType<FeedbackModalIntegration['createDialog']> | null = null;\n      const handleClick = async (): Promise<void> => {\n        if (!dialog) {\n          dialog = await _loadAndRenderDialog({\n            ...mergedOptions,\n            onFormSubmitted: () => {\n              dialog?.removeFromDom();\n              mergedOptions.onFormSubmitted?.();\n            },\n          });\n        }\n        dialog.appendToDom();\n        dialog.open();\n      };\n      targetEl.addEventListener('click', handleClick);\n      const unsubscribe = (): void => {\n        _subscriptions = _subscriptions.filter(sub => sub !== unsubscribe);\n        dialog?.removeFromDom();\n        dialog = null;\n        targetEl.removeEventListener('click', handleClick);\n      };\n      _subscriptions.push(unsubscribe);\n      return unsubscribe;\n    };\n\n    const _createActor = (optionOverrides: OverrideFeedbackConfiguration = {}): ActorComponent => {\n      const mergedOptions = mergeOptions(_options, optionOverrides);\n      const shadow = _createShadow(mergedOptions);\n      const actor = Actor({\n        triggerLabel: mergedOptions.triggerLabel,\n        triggerAriaLabel: mergedOptions.triggerAriaLabel,\n        shadow,\n        styleNonce,\n      });\n      _attachTo(actor.el, {\n        ...mergedOptions,\n        onFormOpen() {\n          actor.hide();\n        },\n        onFormClose() {\n          actor.show();\n        },\n        onFormSubmitted() {\n          actor.show();\n        },\n      });\n      return actor;\n    };\n\n    return {\n      name: 'Feedback',\n      setupOnce() {\n        if (!isBrowser() || !_options.autoInject) {\n          return;\n        }\n\n        if (DOCUMENT.readyState === 'loading') {\n          DOCUMENT.addEventListener('DOMContentLoaded', () => _createActor().appendToDom());\n        } else {\n          _createActor().appendToDom();\n        }\n      },\n\n      /**\n       * Adds click listener to the element to open a feedback dialog\n       *\n       * The returned function can be used to remove the click listener\n       */\n      attachTo: _attachTo,\n\n      /**\n       * Creates a new widget which is composed of a Button which triggers a Dialog.\n       * Accepts partial options to override any options passed to constructor.\n       */\n      createWidget(optionOverrides: OverrideFeedbackConfiguration = {}): ActorComponent {\n        const actor = _createActor(mergeOptions(_options, optionOverrides));\n        actor.appendToDom();\n        return actor;\n      },\n\n      /**\n       * Creates a new Form which you can\n       * Accepts partial options to override any options passed to constructor.\n       */\n      async createForm(\n        optionOverrides: OverrideFeedbackConfiguration = {},\n      ): Promise<ReturnType<FeedbackModalIntegration['createDialog']>> {\n        return _loadAndRenderDialog(mergeOptions(_options, optionOverrides));\n      },\n\n      /**\n       * Removes the Feedback integration (including host, shadow DOM, and all widgets)\n       */\n      remove(): void {\n        if (_shadow) {\n          _shadow.parentElement?.remove();\n          _shadow = null;\n        }\n        // Remove any lingering subscriptions\n        _subscriptions.forEach(sub => sub());\n        _subscriptions = [];\n      },\n    };\n  }) satisfies IntegrationFn;\n\n  return feedbackIntegration;\n};\n","import { getClient } from '@sentry/core';\nimport type { buildFeedbackIntegration } from './integration';\n\ntype FeedbackIntegration = ReturnType<typeof buildFeedbackIntegration>;\n\n/**\n * This is a small utility to get a type-safe instance of the Feedback integration.\n */\nexport function getFeedback(): ReturnType<FeedbackIntegration> | undefined {\n  const client = getClient();\n  return client?.getIntegrationByName<ReturnType<FeedbackIntegration>>('Feedback');\n}\n","var n,l,u,t,i,o,r,f,e,c={},s=[],a=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,h=Array.isArray;function v(n,l){for(var u in l)n[u]=l[u];return n}function p(n){var l=n.parentNode;l&&l.removeChild(n)}function y(l,u,t){var i,o,r,f={};for(r in u)\"key\"==r?i=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),\"function\"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return d(l,f,i,o,null)}function d(n,t,i,o,r){var f={type:n,props:t,key:i,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:null==r?++u:r,__i:-1,__u:0};return null==r&&null!=l.vnode&&l.vnode(f),f}function _(){return{current:null}}function g(n){return n.children}function b(n,l){this.props=n,this.context=l}function m(n,l){if(null==l)return n.__?m(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?m(n):null}function w(n,u,t){var i,o=n.__v,r=o.__e,f=n.__P;if(f)return(i=v({},o)).__v=o.__v+1,l.vnode&&l.vnode(i),M(f,i,o,n.__n,void 0!==f.ownerSVGElement,32&o.__u?[r]:null,u,null==r?m(o):r,!!(32&o.__u),t),i.__.__k[i.__i]=i,i.__d=void 0,i.__e!=r&&k(i),i}function k(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return k(n)}}function x(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!C.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||r)(C)}function C(){var n,u,t,o=[],r=[];for(i.sort(f);n=i.shift();)n.__d&&(t=i.length,u=w(n,o,r)||u,0===t||i.length>t?(j(o,u,r),r.length=o.length=0,u=void 0,i.sort(f)):u&&l.__c&&l.__c(u,s));u&&j(o,u,r),C.__r=0}function P(n,l,u,t,i,o,r,f,e,a,h){var v,p,y,d,_,g=t&&t.__k||s,b=l.length;for(u.__d=e,S(u,l,g),e=u.__d,v=0;v<b;v++)null!=(y=u.__k[v])&&\"boolean\"!=typeof y&&\"function\"!=typeof y&&(p=-1===y.__i?c:g[y.__i]||c,y.__i=v,M(n,y,p,i,o,r,f,e,a,h),d=y.__e,y.ref&&p.ref!=y.ref&&(p.ref&&N(p.ref,null,y),h.push(y.ref,y.__c||d,y)),null==_&&null!=d&&(_=d),65536&y.__u||p.__k===y.__k?e=$(y,e,n):\"function\"==typeof y.type&&void 0!==y.__d?e=y.__d:d&&(e=d.nextSibling),y.__d=void 0,y.__u&=-196609);u.__d=e,u.__e=_}function S(n,l,u){var t,i,o,r,f,e=l.length,c=u.length,s=c,a=0;for(n.__k=[],t=0;t<e;t++)null!=(i=n.__k[t]=null==(i=l[t])||\"boolean\"==typeof i||\"function\"==typeof i?null:\"string\"==typeof i||\"number\"==typeof i||\"bigint\"==typeof i||i.constructor==String?d(null,i,null,null,i):h(i)?d(g,{children:i},null,null,null):void 0===i.constructor&&i.__b>0?d(i.type,i.props,i.key,i.ref?i.ref:null,i.__v):i)?(i.__=n,i.__b=n.__b+1,f=I(i,u,r=t+a,s),i.__i=f,o=null,-1!==f&&(s--,(o=u[f])&&(o.__u|=131072)),null==o||null===o.__v?(-1==f&&a--,\"function\"!=typeof i.type&&(i.__u|=65536)):f!==r&&(f===r+1?a++:f>r?s>e-r?a+=f-r:a--:a=f<r&&f==r-1?f-r:0,f!==t+a&&(i.__u|=65536))):(o=u[t])&&null==o.key&&o.__e&&(o.__e==n.__d&&(n.__d=m(o)),O(o,o,!1),u[t]=null,s--);if(s)for(t=0;t<c;t++)null!=(o=u[t])&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=m(o)),O(o,o))}function $(n,l,u){var t,i;if(\"function\"==typeof n.type){for(t=n.__k,i=0;t&&i<t.length;i++)t[i]&&(t[i].__=n,l=$(t[i],l,u));return l}n.__e!=l&&(u.insertBefore(n.__e,l||null),l=n.__e);do{l=l&&l.nextSibling}while(null!=l&&8===l.nodeType);return l}function H(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(h(n)?n.some(function(n){H(n,l)}):l.push(n)),l}function I(n,l,u,t){var i=n.key,o=n.type,r=u-1,f=u+1,e=l[u];if(null===e||e&&i==e.key&&o===e.type)return u;if(t>(null!=e&&0==(131072&e.__u)?1:0))for(;r>=0||f<l.length;){if(r>=0){if((e=l[r])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return r;r--}if(f<l.length){if((e=l[f])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return f;f++}}return-1}function T(n,l,u){\"-\"===l[0]?n.setProperty(l,null==u?\"\":u):n[l]=null==u?\"\":\"number\"!=typeof u||a.test(l)?u:u+\"px\"}function A(n,l,u,t,i){var o;n:if(\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof t&&(n.style.cssText=t=\"\"),t)for(l in t)u&&l in u||T(n.style,l,\"\");if(u)for(l in u)t&&u[l]===t[l]||T(n.style,l,u[l])}else if(\"o\"===l[0]&&\"n\"===l[1])o=l!==(l=l.replace(/(PointerCapture)$|Capture$/i,\"$1\")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?t?u.u=t.u:(u.u=Date.now(),n.addEventListener(l,o?L:D,o)):n.removeEventListener(l,o?L:D,o);else{if(i)l=l.replace(/xlink(H|:h)/,\"h\").replace(/sName$/,\"s\");else if(\"width\"!==l&&\"height\"!==l&&\"href\"!==l&&\"list\"!==l&&\"form\"!==l&&\"tabIndex\"!==l&&\"download\"!==l&&\"rowSpan\"!==l&&\"colSpan\"!==l&&\"role\"!==l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null==u||!1===u&&\"-\"!==l[4]?n.removeAttribute(l):n.setAttribute(l,u))}}function D(n){if(this.l){var u=this.l[n.type+!1];if(n.t){if(n.t<=u.u)return}else n.t=Date.now();return u(l.event?l.event(n):n)}}function L(n){if(this.l)return this.l[n.type+!0](l.event?l.event(n):n)}function M(n,u,t,i,o,r,f,e,c,s){var a,p,y,d,_,m,w,k,x,C,S,$,H,I,T,A=u.type;if(void 0!==u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),r=[e=u.__e=t.__e]),(a=l.__b)&&a(u);n:if(\"function\"==typeof A)try{if(k=u.props,x=(a=A.contextType)&&i[a.__c],C=a?x?x.props.value:a.__:i,t.__c?w=(p=u.__c=t.__c).__=p.__E:(\"prototype\"in A&&A.prototype.render?u.__c=p=new A(k,C):(u.__c=p=new b(k,C),p.constructor=A,p.render=q),x&&x.sub(p),p.props=k,p.state||(p.state={}),p.context=C,p.__n=i,y=p.__d=!0,p.__h=[],p._sb=[]),null==p.__s&&(p.__s=p.state),null!=A.getDerivedStateFromProps&&(p.__s==p.state&&(p.__s=v({},p.__s)),v(p.__s,A.getDerivedStateFromProps(k,p.__s))),d=p.props,_=p.state,p.__v=u,y)null==A.getDerivedStateFromProps&&null!=p.componentWillMount&&p.componentWillMount(),null!=p.componentDidMount&&p.__h.push(p.componentDidMount);else{if(null==A.getDerivedStateFromProps&&k!==d&&null!=p.componentWillReceiveProps&&p.componentWillReceiveProps(k,C),!p.__e&&(null!=p.shouldComponentUpdate&&!1===p.shouldComponentUpdate(k,p.__s,C)||u.__v===t.__v)){for(u.__v!==t.__v&&(p.props=k,p.state=p.__s,p.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.forEach(function(n){n&&(n.__=u)}),S=0;S<p._sb.length;S++)p.__h.push(p._sb[S]);p._sb=[],p.__h.length&&f.push(p);break n}null!=p.componentWillUpdate&&p.componentWillUpdate(k,p.__s,C),null!=p.componentDidUpdate&&p.__h.push(function(){p.componentDidUpdate(d,_,m)})}if(p.context=C,p.props=k,p.__P=n,p.__e=!1,$=l.__r,H=0,\"prototype\"in A&&A.prototype.render){for(p.state=p.__s,p.__d=!1,$&&$(u),a=p.render(p.props,p.state,p.context),I=0;I<p._sb.length;I++)p.__h.push(p._sb[I]);p._sb=[]}else do{p.__d=!1,$&&$(u),a=p.render(p.props,p.state,p.context),p.state=p.__s}while(p.__d&&++H<25);p.state=p.__s,null!=p.getChildContext&&(i=v(v({},i),p.getChildContext())),y||null==p.getSnapshotBeforeUpdate||(m=p.getSnapshotBeforeUpdate(d,_)),P(n,h(T=null!=a&&a.type===g&&null==a.key?a.props.children:a)?T:[T],u,t,i,o,r,f,e,c,s),p.base=u.__e,u.__u&=-161,p.__h.length&&f.push(p),w&&(p.__E=p.__=null)}catch(n){u.__v=null,c||null!=r?(u.__e=e,u.__u|=c?160:32,r[r.indexOf(e)]=null):(u.__e=t.__e,u.__k=t.__k),l.__e(n,u,t)}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=z(t.__e,u,t,i,o,r,f,c,s);(a=l.diffed)&&a(u)}function j(n,u,t){for(var i=0;i<t.length;i++)N(t[i],t[++i],t[++i]);l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function z(l,u,t,i,o,r,f,e,s){var a,v,y,d,_,g,b,w=t.props,k=u.props,x=u.type;if(\"svg\"===x&&(o=!0),null!=r)for(a=0;a<r.length;a++)if((_=r[a])&&\"setAttribute\"in _==!!x&&(x?_.localName===x:3===_.nodeType)){l=_,r[a]=null;break}if(null==l){if(null===x)return document.createTextNode(k);l=o?document.createElementNS(\"http://www.w3.org/2000/svg\",x):document.createElement(x,k.is&&k),r=null,e=!1}if(null===x)w===k||e&&l.data===k||(l.data=k);else{if(r=r&&n.call(l.childNodes),w=t.props||c,!e&&null!=r)for(w={},a=0;a<l.attributes.length;a++)w[(_=l.attributes[a]).name]=_.value;for(a in w)_=w[a],\"children\"==a||(\"dangerouslySetInnerHTML\"==a?y=_:\"key\"===a||a in k||A(l,a,null,_,o));for(a in k)_=k[a],\"children\"==a?d=_:\"dangerouslySetInnerHTML\"==a?v=_:\"value\"==a?g=_:\"checked\"==a?b=_:\"key\"===a||e&&\"function\"!=typeof _||w[a]===_||A(l,a,_,w[a],o);if(v)e||y&&(v.__html===y.__html||v.__html===l.innerHTML)||(l.innerHTML=v.__html),u.__k=[];else if(y&&(l.innerHTML=\"\"),P(l,h(d)?d:[d],u,t,i,o&&\"foreignObject\"!==x,r,f,r?r[0]:t.__k&&m(t,0),e,s),null!=r)for(a=r.length;a--;)null!=r[a]&&p(r[a]);e||(a=\"value\",void 0!==g&&(g!==l[a]||\"progress\"===x&&!g||\"option\"===x&&g!==w[a])&&A(l,a,g,w[a],!1),a=\"checked\",void 0!==b&&b!==l[a]&&A(l,a,b,w[a],!1))}return l}function N(n,u,t){try{\"function\"==typeof n?n(u):n.current=u}catch(n){l.__e(n,t)}}function O(n,u,t){var i,o;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!==n.__e||N(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(n){l.__e(n,u)}i.base=i.__P=null,n.__c=void 0}if(i=n.__k)for(o=0;o<i.length;o++)i[o]&&O(i[o],u,t||\"function\"!=typeof n.type);t||null==n.__e||p(n.__e),n.__=n.__e=n.__d=void 0}function q(n,l,u){return this.constructor(n,u)}function B(u,t,i){var o,r,f,e;l.__&&l.__(u,t),r=(o=\"function\"==typeof i)?null:i&&i.__k||t.__k,f=[],e=[],M(t,u=(!o&&i||t).__k=y(g,null,[u]),r||c,c,void 0!==t.ownerSVGElement,!o&&i?[i]:r?null:t.firstChild?n.call(t.childNodes):null,f,!o&&i?i:r?r.__e:t.firstChild,o,e),u.__d=void 0,j(f,u,e)}function E(n,l){B(n,l,E)}function F(l,u,t){var i,o,r,f,e=v({},l.props);for(r in l.type&&l.type.defaultProps&&(f=l.type.defaultProps),u)\"key\"==r?i=u[r]:\"ref\"==r?o=u[r]:e[r]=void 0===u[r]&&void 0!==f?f[r]:u[r];return arguments.length>2&&(e.children=arguments.length>3?n.call(arguments,2):t),d(l.type,e,i||l.key,o||l.ref,null)}function G(n,l){var u={__c:l=\"__cC\"+e++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,t;return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(function(n){n.__e=!0,x(n)})},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=s.slice,l={__e:function(n,l,u,t){for(var i,o,r;l=l.__;)if((i=l.__c)&&!i.__)try{if((o=i.constructor)&&null!=o.getDerivedStateFromError&&(i.setState(o.getDerivedStateFromError(n)),r=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),r=i.__d),r)return i.__E=i}catch(l){n=l}throw n}},u=0,t=function(n){return null!=n&&null==n.constructor},b.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=v({},this.state),\"function\"==typeof n&&(n=n(v({},u),this.props)),n&&v(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),x(this))},b.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),x(this))},b.prototype.render=g,i=[],r=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,f=function(n,l){return n.__v.__b-l.__v.__b},C.__r=0,e=0;export{b as Component,g as Fragment,F as cloneElement,G as createContext,y as createElement,_ as createRef,y as h,E as hydrate,t as isValidElement,l as options,B as render,H as toChildArray};\n//# sourceMappingURL=preact.module.js.map\n","import{options as n}from\"preact\";var t,r,u,i,o=0,f=[],c=[],e=n,a=e.__b,v=e.__r,l=e.diffed,m=e.__c,s=e.unmount,d=e.__;function h(n,t){e.__h&&e.__h(r,n,o||t),o=0;var u=r.__H||(r.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({__V:c}),u.__[n]}function p(n){return o=1,y(D,n)}function y(n,u,i){var o=h(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.u)){var f=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return!!n.__c});if(u.every(function(n){return!n.__N}))return!c||c.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),!(!i&&o.__c.props===n)&&(!c||c.call(this,n,t,r))};r.u=!0;var c=r.shouldComponentUpdate,e=r.componentWillUpdate;r.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u}e&&e.call(this,n,t,r)},r.shouldComponentUpdate=f}return o.__N||o.__}function _(n,u){var i=h(t++,3);!e.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__H.__h.push(i))}function A(n,u){var i=h(t++,4);!e.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__h.push(i))}function F(n){return o=5,q(function(){return{current:n}},[])}function T(n,t,r){o=6,A(function(){return\"function\"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==r?r:r.concat(n))}function q(n,r){var u=h(t++,7);return C(u.__H,r)?(u.__V=n(),u.i=r,u.__h=n,u.__V):u.__}function x(n,t){return o=8,q(function(){return n},t)}function P(n){var u=r.context[n.__c],i=h(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function V(n,t){e.useDebugValue&&e.useDebugValue(t?t(n):n)}function b(n){var u=h(t++,10),i=p();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function g(){var n=h(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__=\"P\"+i[0]+\"-\"+i[1]++}return n.__}function j(){for(var n;n=f.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z),n.__H.__h.forEach(B),n.__H.__h=[]}catch(t){n.__H.__h=[],e.__e(t,n.__v)}}e.__b=function(n){r=null,a&&a(n)},e.__=function(n,t){t.__k&&t.__k.__m&&(n.__m=t.__k.__m),d&&d(n,t)},e.__r=function(n){v&&v(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.__V=c,n.__N=n.i=void 0})):(i.__h.forEach(z),i.__h.forEach(B),i.__h=[],t=0)),u=r},e.diffed=function(n){l&&l(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f.push(t)&&i===e.requestAnimationFrame||((i=e.requestAnimationFrame)||w)(j)),t.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.__V!==c&&(n.__=n.__V),n.i=void 0,n.__V=c})),u=r=null},e.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z),n.__h=n.__h.filter(function(n){return!n.__||B(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],e.__e(r,n.__v)}}),m&&m(n,t)},e.unmount=function(n){s&&s(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z(n)}catch(n){t=n}}),r.__H=void 0,t&&e.__e(t,r.__v))};var k=\"function\"==typeof requestAnimationFrame;function w(n){var t,r=function(){clearTimeout(u),k&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);k&&(t=requestAnimationFrame(r))}function z(n){var t=r,u=n.__c;\"function\"==typeof u&&(n.__c=void 0,u()),r=t}function B(n){var t=r;n.__c=n.__(),r=t}function C(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D(n,t){return\"function\"==typeof t?t(n):t}export{x as useCallback,P as useContext,V as useDebugValue,_ as useEffect,b as useErrorBoundary,g as useId,T as useImperativeHandle,A as useLayoutEffect,q as useMemo,y as useReducer,F as useRef,p as useState};\n//# sourceMappingURL=hooks.module.js.map\n","import { DOCUMENT } from '../../constants';\nimport { setAttributesNS } from '../../util/setAttributesNS';\n\nconst XMLNS = 'http://www.w3.org/2000/svg';\n\n/**\n * Sentry Logo\n */\nexport function SentryLogo(): SVGElement {\n  const createElementNS = <K extends keyof SVGElementTagNameMap>(tagName: K): SVGElementTagNameMap[K] =>\n    DOCUMENT.createElementNS(XMLNS, tagName);\n  const svg = setAttributesNS(createElementNS('svg'), {\n    width: '32',\n    height: '30',\n    viewBox: '0 0 72 66',\n    fill: 'inherit',\n  });\n\n  const path = setAttributesNS(createElementNS('path'), {\n    transform: 'translate(11, 11)',\n    d: 'M29,2.26a4.67,4.67,0,0,0-8,0L14.42,13.53A32.21,32.21,0,0,1,32.17,40.19H27.55A27.68,27.68,0,0,0,12.09,17.47L6,28a15.92,15.92,0,0,1,9.23,12.17H4.62A.76.76,0,0,1,4,39.06l2.94-5a10.74,10.74,0,0,0-3.36-1.9l-2.91,5a4.54,4.54,0,0,0,1.69,6.24A4.66,4.66,0,0,0,4.62,44H19.15a19.4,19.4,0,0,0-8-17.31l2.31-4A23.87,23.87,0,0,1,23.76,44H36.07a35.88,35.88,0,0,0-16.41-31.8l4.67-8a.77.77,0,0,1,1.05-.27c.53.29,20.29,34.77,20.66,35.17a.76.76,0,0,1-.68,1.13H40.6q.09,1.91,0,3.81h4.78A4.59,4.59,0,0,0,50,39.43a4.49,4.49,0,0,0-.62-2.28Z',\n  });\n  svg.appendChild(path);\n\n  return svg;\n}\n","import type { FeedbackInternalOptions } from '@sentry/core';\nimport type { VNode } from 'preact';\nimport { h } from 'preact'; // eslint-disable-line @typescript-eslint/no-unused-vars\nimport { useMemo } from 'preact/hooks';\nimport { SentryLogo } from './SentryLogo';\n\nexport interface Props {\n  options: FeedbackInternalOptions;\n}\n\nexport function DialogHeader({ options }: Props): VNode {\n  const logoHtml = useMemo(() => ({ __html: SentryLogo().outerHTML }), []);\n\n  return (\n    <h2 class=\"dialog__header\">\n      <span class=\"dialog__title\">{options.formTitle}</span>\n      {options.showBranding ? (\n        <a\n          class=\"brand-link\"\n          target=\"_blank\"\n          href=\"https://sentry.io/welcome/\"\n          title=\"Powered by Sentry\"\n          rel=\"noopener noreferrer\"\n          dangerouslySetInnerHTML={logoHtml}\n        />\n      ) : null}\n    </h2>\n  );\n}\n","import type { FeedbackFormData, FeedbackInternalOptions } from '@sentry/core';\n\nexport type Props = Pick<\n  FeedbackInternalOptions,\n  'emailLabel' | 'isEmailRequired' | 'isNameRequired' | 'messageLabel' | 'nameLabel'\n>;\n\n/**\n * Validate that a given feedback submission has the required fields\n */\nexport function getMissingFields(feedback: FeedbackFormData, props: Props): string[] {\n  const emptyFields = [];\n  if (props.isNameRequired && !feedback.name) {\n    emptyFields.push(props.nameLabel);\n  }\n  if (props.isEmailRequired && !feedback.email) {\n    emptyFields.push(props.emailLabel);\n  }\n  if (!feedback.message) {\n    emptyFields.push(props.messageLabel);\n  }\n\n  return emptyFields;\n}\n","import type {\n  FeedbackFormData,\n  FeedbackInternalOptions,\n  FeedbackScreenshotIntegration,\n  SendFeedback,\n} from '@sentry/core';\nimport { logger } from '@sentry/core';\nimport type { JSX, VNode } from 'preact';\nimport { h } from 'preact'; // eslint-disable-line @typescript-eslint/no-unused-vars\nimport { useCallback, useState } from 'preact/hooks';\nimport { FEEDBACK_WIDGET_SOURCE } from '../../constants';\nimport { DEBUG_BUILD } from '../../util/debug-build';\nimport { getMissingFields } from '../../util/validate';\n\nexport interface Props extends Pick<FeedbackInternalOptions, 'showEmail' | 'showName'> {\n  options: FeedbackInternalOptions;\n  defaultEmail: string;\n  defaultName: string;\n  onFormClose: () => void;\n  onSubmit: SendFeedback;\n  onSubmitSuccess: (data: FeedbackFormData, eventId: string) => void;\n  onSubmitError: (error: Error) => void;\n  screenshotInput: ReturnType<FeedbackScreenshotIntegration['createInput']> | undefined;\n}\n\nfunction retrieveStringValue(formData: FormData, key: string): string {\n  const value = formData.get(key);\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n  return '';\n}\n\nexport function Form({\n  options,\n  defaultEmail,\n  defaultName,\n\n  onFormClose,\n  onSubmit,\n  onSubmitSuccess,\n  onSubmitError,\n  showEmail,\n  showName,\n  screenshotInput,\n}: Props): VNode {\n  const {\n    tags,\n    addScreenshotButtonLabel,\n    removeScreenshotButtonLabel,\n    cancelButtonLabel,\n    emailLabel,\n    emailPlaceholder,\n    isEmailRequired,\n    isNameRequired,\n    messageLabel,\n    messagePlaceholder,\n    nameLabel,\n    namePlaceholder,\n    submitButtonLabel,\n    isRequiredLabel,\n  } = options;\n  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);\n  // TODO: set a ref on the form, and whenever an input changes call processForm() and setError()\n  const [error, setError] = useState<null | string>(null);\n\n  const [showScreenshotInput, setShowScreenshotInput] = useState(false);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const ScreenshotInputComponent: any = screenshotInput?.input;\n\n  const [screenshotError, setScreenshotError] = useState<null | Error>(null);\n  const onScreenshotError = useCallback((error: Error) => {\n    setScreenshotError(error);\n    setShowScreenshotInput(false);\n  }, []);\n\n  const hasAllRequiredFields = useCallback(\n    (data: FeedbackFormData) => {\n      const missingFields = getMissingFields(data, {\n        emailLabel,\n        isEmailRequired,\n        isNameRequired,\n        messageLabel,\n        nameLabel,\n      });\n\n      if (missingFields.length > 0) {\n        setError(`Please enter in the following required fields: ${missingFields.join(', ')}`);\n      } else {\n        setError(null);\n      }\n\n      return missingFields.length === 0;\n    },\n    [emailLabel, isEmailRequired, isNameRequired, messageLabel, nameLabel],\n  );\n\n  const handleSubmit = useCallback(\n    async (e: JSX.TargetedSubmitEvent<HTMLFormElement>) => {\n      setIsSubmitting(true);\n      try {\n        e.preventDefault();\n        if (!(e.target instanceof HTMLFormElement)) {\n          return;\n        }\n        const formData = new FormData(e.target);\n        const attachment = await (screenshotInput && showScreenshotInput ? screenshotInput.value() : undefined);\n\n        const data: FeedbackFormData = {\n          name: retrieveStringValue(formData, 'name'),\n          email: retrieveStringValue(formData, 'email'),\n          message: retrieveStringValue(formData, 'message'),\n          attachments: attachment ? [attachment] : undefined,\n        };\n\n        if (!hasAllRequiredFields(data)) {\n          return;\n        }\n\n        try {\n          const eventId = await onSubmit(\n            {\n              name: data.name,\n              email: data.email,\n              message: data.message,\n              source: FEEDBACK_WIDGET_SOURCE,\n              tags,\n            },\n            { attachments: data.attachments },\n          );\n          onSubmitSuccess(data, eventId);\n        } catch (error) {\n          DEBUG_BUILD && logger.error(error);\n          setError(error as string);\n          onSubmitError(error as Error);\n        }\n      } finally {\n        setIsSubmitting(false);\n      }\n    },\n    [screenshotInput && showScreenshotInput, onSubmitSuccess, onSubmitError],\n  );\n\n  return (\n    <form class=\"form\" onSubmit={handleSubmit}>\n      {ScreenshotInputComponent && showScreenshotInput ? (\n        <ScreenshotInputComponent onError={onScreenshotError} />\n      ) : null}\n\n      <fieldset class=\"form__right\" data-sentry-feedback={true} disabled={isSubmitting}>\n        <div class=\"form__top\">\n          {error ? <div class=\"form__error-container\">{error}</div> : null}\n\n          {showName ? (\n            <label for=\"name\" class=\"form__label\">\n              <LabelText label={nameLabel} isRequiredLabel={isRequiredLabel} isRequired={isNameRequired} />\n              <input\n                class=\"form__input\"\n                defaultValue={defaultName}\n                id=\"name\"\n                name=\"name\"\n                placeholder={namePlaceholder}\n                required={isNameRequired}\n                type=\"text\"\n              />\n            </label>\n          ) : (\n            <input aria-hidden value={defaultName} name=\"name\" type=\"hidden\" />\n          )}\n\n          {showEmail ? (\n            <label for=\"email\" class=\"form__label\">\n              <LabelText label={emailLabel} isRequiredLabel={isRequiredLabel} isRequired={isEmailRequired} />\n              <input\n                class=\"form__input\"\n                defaultValue={defaultEmail}\n                id=\"email\"\n                name=\"email\"\n                placeholder={emailPlaceholder}\n                required={isEmailRequired}\n                type=\"email\"\n              ></input>\n            </label>\n          ) : (\n            <input aria-hidden value={defaultEmail} name=\"email\" type=\"hidden\" />\n          )}\n\n          <label for=\"message\" class=\"form__label\">\n            <LabelText label={messageLabel} isRequiredLabel={isRequiredLabel} isRequired />\n            <textarea\n              autoFocus\n              class=\"form__input form__input--textarea\"\n              id=\"message\"\n              name=\"message\"\n              placeholder={messagePlaceholder}\n              required={true}\n              rows={5}\n            />\n          </label>\n\n          {ScreenshotInputComponent ? (\n            <label for=\"screenshot\" class=\"form__label\">\n              <button\n                class=\"btn btn--default\"\n                disabled={isSubmitting}\n                type=\"button\"\n                onClick={() => {\n                  setScreenshotError(null);\n                  setShowScreenshotInput(prev => !prev);\n                }}\n              >\n                {showScreenshotInput ? removeScreenshotButtonLabel : addScreenshotButtonLabel}\n              </button>\n              {screenshotError ? <div class=\"form__error-container\">{screenshotError.message}</div> : null}\n            </label>\n          ) : null}\n        </div>\n        <div class=\"btn-group\">\n          <button class=\"btn btn--primary\" disabled={isSubmitting} type=\"submit\">\n            {submitButtonLabel}\n          </button>\n          <button class=\"btn btn--default\" disabled={isSubmitting} type=\"button\" onClick={onFormClose}>\n            {cancelButtonLabel}\n          </button>\n        </div>\n      </fieldset>\n    </form>\n  );\n}\n\nfunction LabelText({\n  label,\n  isRequired,\n  isRequiredLabel,\n}: {\n  label: string;\n  isRequired: boolean;\n  isRequiredLabel: string;\n}): VNode {\n  return (\n    <span class=\"form__label__text\">\n      {label}\n      {isRequired && <span class=\"form__label__text--required\">{isRequiredLabel}</span>}\n    </span>\n  );\n}\n","import { WINDOW } from '../../constants';\nimport { setAttributesNS } from '../../util/setAttributesNS';\n\nconst WIDTH = 16;\nconst HEIGHT = 17;\nconst XMLNS = 'http://www.w3.org/2000/svg';\n\n/**\n * Success Icon (checkmark)\n */\nexport function SuccessIcon(): SVGElement {\n  const createElementNS = <K extends keyof SVGElementTagNameMap>(tagName: K): SVGElementTagNameMap[K] =>\n    WINDOW.document.createElementNS(XMLNS, tagName);\n  const svg = setAttributesNS(createElementNS('svg'), {\n    width: `${WIDTH}`,\n    height: `${HEIGHT}`,\n    viewBox: `0 0 ${WIDTH} ${HEIGHT}`,\n    fill: 'inherit',\n  });\n\n  const g = setAttributesNS(createElementNS('g'), {\n    clipPath: 'url(#clip0_57_156)',\n  });\n\n  const path2 = setAttributesNS(createElementNS('path'), {\n    ['fill-rule']: 'evenodd',\n    ['clip-rule']: 'evenodd',\n    d: 'M3.55544 15.1518C4.87103 16.0308 6.41775 16.5 8 16.5C10.1217 16.5 12.1566 15.6571 13.6569 14.1569C15.1571 12.6566 16 10.6217 16 8.5C16 6.91775 15.5308 5.37103 14.6518 4.05544C13.7727 2.73985 12.5233 1.71447 11.0615 1.10897C9.59966 0.503466 7.99113 0.34504 6.43928 0.653721C4.88743 0.962403 3.46197 1.72433 2.34315 2.84315C1.22433 3.96197 0.462403 5.38743 0.153721 6.93928C-0.15496 8.49113 0.00346625 10.0997 0.608967 11.5615C1.21447 13.0233 2.23985 14.2727 3.55544 15.1518ZM4.40546 3.1204C5.46945 2.40946 6.72036 2.03 8 2.03C9.71595 2.03 11.3616 2.71166 12.575 3.92502C13.7883 5.13838 14.47 6.78405 14.47 8.5C14.47 9.77965 14.0905 11.0306 13.3796 12.0945C12.6687 13.1585 11.6582 13.9878 10.476 14.4775C9.29373 14.9672 7.99283 15.0953 6.73777 14.8457C5.48271 14.596 4.32987 13.9798 3.42502 13.075C2.52018 12.1701 1.90397 11.0173 1.65432 9.76224C1.40468 8.50718 1.5328 7.20628 2.0225 6.02404C2.5122 4.8418 3.34148 3.83133 4.40546 3.1204Z',\n  });\n  const path = setAttributesNS(createElementNS('path'), {\n    d: 'M6.68775 12.4297C6.78586 12.4745 6.89218 12.4984 7 12.5C7.11275 12.4955 7.22315 12.4664 7.32337 12.4145C7.4236 12.3627 7.51121 12.2894 7.58 12.2L12 5.63999C12.0848 5.47724 12.1071 5.28902 12.0625 5.11098C12.0178 4.93294 11.9095 4.77744 11.7579 4.67392C11.6064 4.57041 11.4221 4.52608 11.24 4.54931C11.0579 4.57254 10.8907 4.66173 10.77 4.79999L6.88 10.57L5.13 8.56999C5.06508 8.49566 4.98613 8.43488 4.89768 8.39111C4.80922 8.34735 4.713 8.32148 4.61453 8.31498C4.51605 8.30847 4.41727 8.32147 4.32382 8.35322C4.23038 8.38497 4.14413 8.43484 4.07 8.49999C3.92511 8.63217 3.83692 8.81523 3.82387 9.01092C3.81083 9.2066 3.87393 9.39976 4 9.54999L6.43 12.24C6.50187 12.3204 6.58964 12.385 6.68775 12.4297Z',\n  });\n\n  svg.appendChild(g).append(path, path2);\n\n  const speakerDefs = createElementNS('defs');\n  const speakerClipPathDef = setAttributesNS(createElementNS('clipPath'), {\n    id: 'clip0_57_156',\n  });\n\n  const speakerRect = setAttributesNS(createElementNS('rect'), {\n    width: `${WIDTH}`,\n    height: `${WIDTH}`,\n    fill: 'white',\n    transform: 'translate(0 0.5)',\n  });\n\n  speakerClipPathDef.appendChild(speakerRect);\n  speakerDefs.appendChild(speakerClipPathDef);\n\n  svg.appendChild(speakerDefs).appendChild(speakerClipPathDef).appendChild(speakerRect);\n\n  return svg;\n}\n","import type { FeedbackFormData, FeedbackInternalOptions } from '@sentry/core';\nimport type { VNode } from 'preact';\nimport { Fragment, h } from 'preact'; // eslint-disable-line @typescript-eslint/no-unused-vars\nimport { useCallback, useMemo, useState } from 'preact/hooks';\nimport { SUCCESS_MESSAGE_TIMEOUT } from '../../constants';\nimport type { Props as HeaderProps } from './DialogHeader';\nimport { DialogHeader } from './DialogHeader';\nimport type { Props as FormProps } from './Form';\nimport { Form } from './Form';\nimport { SuccessIcon } from './SuccessIcon';\n\ninterface Props extends HeaderProps, FormProps {\n  onFormSubmitted: () => void;\n  open: boolean;\n  options: FeedbackInternalOptions;\n}\n\nexport function Dialog({ open, onFormSubmitted, ...props }: Props): VNode {\n  const options = props.options;\n  const successIconHtml = useMemo(() => ({ __html: SuccessIcon().outerHTML }), []);\n\n  const [timeoutId, setTimeoutId] = useState<NodeJS.Timeout | null>(null);\n\n  const handleOnSuccessClick = useCallback(() => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      setTimeoutId(null);\n    }\n    onFormSubmitted();\n  }, [timeoutId]);\n\n  const onSubmitSuccess = useCallback(\n    (data: FeedbackFormData, eventId: string) => {\n      props.onSubmitSuccess(data, eventId);\n      setTimeoutId(\n        setTimeout(() => {\n          onFormSubmitted();\n          setTimeoutId(null);\n        }, SUCCESS_MESSAGE_TIMEOUT),\n      );\n    },\n    [onFormSubmitted],\n  );\n\n  return (\n    <Fragment>\n      {timeoutId ? (\n        <div class=\"success__position\" onClick={handleOnSuccessClick}>\n          <div class=\"success__content\">\n            {options.successMessageText}\n            <span class=\"success__icon\" dangerouslySetInnerHTML={successIconHtml} />\n          </div>\n        </div>\n      ) : (\n        <dialog class=\"dialog\" onClick={options.onFormClose} open={open}>\n          <div class=\"dialog__position\">\n            <div\n              class=\"dialog__content\"\n              onClick={e => {\n                // Stop event propagation so clicks on content modal do not propagate to dialog (which will close dialog)\n                e.stopPropagation();\n              }}\n            >\n              <DialogHeader options={options} />\n              <Form {...props} onSubmitSuccess={onSubmitSuccess} />\n            </div>\n          </div>\n        </dialog>\n      )}\n    </Fragment>\n  );\n}\n","import { DOCUMENT } from '../../constants';\n\nconst DIALOG = `\n.dialog {\n  position: fixed;\n  z-index: var(--z-index);\n  margin: 0;\n  inset: 0;\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0;\n  height: 100vh;\n  width: 100vw;\n\n  color: var(--dialog-color, var(--foreground));\n  fill: var(--dialog-color, var(--foreground));\n  line-height: 1.75em;\n\n  background-color: rgba(0, 0, 0, 0.05);\n  border: none;\n  inset: 0;\n  opacity: 1;\n  transition: opacity 0.2s ease-in-out;\n}\n\n.dialog__position {\n  position: fixed;\n  z-index: var(--z-index);\n  inset: var(--dialog-inset);\n  padding: var(--page-margin);\n  display: flex;\n  max-height: calc(100vh - (2 * var(--page-margin)));\n}\n@media (max-width: 600px) {\n  .dialog__position {\n    inset: var(--page-margin);\n    padding: 0;\n  }\n}\n\n.dialog__position:has(.editor) {\n  inset: var(--page-margin);\n  padding: 0;\n}\n\n.dialog:not([open]) {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n}\n.dialog:not([open]) .dialog__content {\n  transform: translate(0, -16px) scale(0.98);\n}\n\n.dialog__content {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  padding: var(--dialog-padding, 24px);\n  max-width: 100%;\n  width: 100%;\n  max-height: 100%;\n  overflow: auto;\n\n  background: var(--dialog-background, var(--background));\n  border-radius: var(--dialog-border-radius, 20px);\n  border: var(--dialog-border, var(--border));\n  box-shadow: var(--dialog-box-shadow, var(--box-shadow));\n  transform: translate(0, 0) scale(1);\n  transition: transform 0.2s ease-in-out;\n}\n\n`;\n\nconst DIALOG_HEADER = `\n.dialog__header {\n  display: flex;\n  gap: 4px;\n  justify-content: space-between;\n  font-weight: var(--dialog-header-weight, 600);\n  margin: 0;\n}\n.dialog__title {\n  align-self: center;\n  width: var(--form-width, 272px);\n}\n\n@media (max-width: 600px) {\n  .dialog__title {\n    width: auto;\n  }\n}\n\n.dialog__position:has(.editor) .dialog__title {\n  width: auto;\n}\n\n\n.brand-link {\n  display: inline-flex;\n}\n.brand-link:focus-visible {\n  outline: var(--outline);\n}\n`;\n\nconst FORM = `\n.form {\n  display: flex;\n  overflow: auto;\n  flex-direction: row;\n  gap: 16px;\n  flex: 1 0;\n}\n\n.form fieldset {\n  border: none;\n  margin: 0;\n  padding: 0;\n}\n\n.form__right {\n  flex: 0 0 auto;\n  display: flex;\n  overflow: auto;\n  flex-direction: column;\n  justify-content: space-between;\n  gap: 20px;\n  width: var(--form-width, 100%);\n}\n\n.dialog__position:has(.editor) .form__right {\n  width: var(--form-width, 272px);\n}\n\n.form__top {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.form__error-container {\n  color: var(--error-color);\n  fill: var(--error-color);\n}\n\n.form__label {\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n  margin: 0px;\n}\n\n.form__label__text {\n  display: flex;\n  gap: 4px;\n  align-items: center;\n}\n\n.form__label__text--required {\n  font-size: 0.85em;\n}\n\n.form__input {\n  font-family: inherit;\n  line-height: inherit;\n  background: transparent;\n  box-sizing: border-box;\n  border: var(--input-border, var(--border));\n  border-radius: var(--input-border-radius, 6px);\n  color: var(--input-color, inherit);\n  fill: var(--input-color, inherit);\n  font-size: var(--input-font-size, inherit);\n  font-weight: var(--input-font-weight, 500);\n  padding: 6px 12px;\n}\n\n.form__input::placeholder {\n  opacity: 0.65;\n  color: var(--input-placeholder-color, inherit);\n  filter: var(--interactive-filter);\n}\n\n.form__input:focus-visible {\n  outline: var(--input-focus-outline, var(--outline));\n}\n\n.form__input--textarea {\n  font-family: inherit;\n  resize: vertical;\n}\n\n.error {\n  color: var(--error-color);\n  fill: var(--error-color);\n}\n`;\n\nconst BUTTON = `\n.btn-group {\n  display: grid;\n  gap: 8px;\n}\n\n.btn {\n  line-height: inherit;\n  border: var(--button-border, var(--border));\n  border-radius: var(--button-border-radius, 6px);\n  cursor: pointer;\n  font-family: inherit;\n  font-size: var(--button-font-size, inherit);\n  font-weight: var(--button-font-weight, 600);\n  padding: var(--button-padding, 6px 16px);\n}\n.btn[disabled] {\n  opacity: 0.6;\n  pointer-events: none;\n}\n\n.btn--primary {\n  color: var(--button-primary-color, var(--accent-foreground));\n  fill: var(--button-primary-color, var(--accent-foreground));\n  background: var(--button-primary-background, var(--accent-background));\n  border: var(--button-primary-border, var(--border));\n  border-radius: var(--button-primary-border-radius, 6px);\n  font-weight: var(--button-primary-font-weight, 500);\n}\n.btn--primary:hover {\n  color: var(--button-primary-hover-color, var(--accent-foreground));\n  fill: var(--button-primary-hover-color, var(--accent-foreground));\n  background: var(--button-primary-hover-background, var(--accent-background));\n  filter: var(--interactive-filter);\n}\n.btn--primary:focus-visible {\n  background: var(--button-primary-hover-background, var(--accent-background));\n  filter: var(--interactive-filter);\n  outline: var(--button-primary-focus-outline, var(--outline));\n}\n\n.btn--default {\n  color: var(--button-color, var(--foreground));\n  fill: var(--button-color, var(--foreground));\n  background: var(--button-background, var(--background));\n  border: var(--button-border, var(--border));\n  border-radius: var(--button-border-radius, 6px);\n  font-weight: var(--button-font-weight, 500);\n}\n.btn--default:hover {\n  color: var(--button-color, var(--foreground));\n  fill: var(--button-color, var(--foreground));\n  background: var(--button-hover-background, var(--background));\n  filter: var(--interactive-filter);\n}\n.btn--default:focus-visible {\n  background: var(--button-hover-background, var(--background));\n  filter: var(--interactive-filter);\n  outline: var(--button-focus-outline, var(--outline));\n}\n`;\n\nconst SUCCESS = `\n.success__position {\n  position: fixed;\n  inset: var(--dialog-inset);\n  padding: var(--page-margin);\n  z-index: var(--z-index);\n}\n.success__content {\n  background: var(--success-background, var(--background));\n  border: var(--success-border, var(--border));\n  border-radius: var(--success-border-radius, 1.7em/50%);\n  box-shadow: var(--success-box-shadow, var(--box-shadow));\n  font-weight: var(--success-font-weight, 600);\n  color: var(--success-color);\n  fill: var(--success-color);\n  padding: 12px 24px;\n  line-height: 1.75em;\n\n  display: grid;\n  align-items: center;\n  grid-auto-flow: column;\n  gap: 6px;\n  cursor: default;\n}\n\n.success__icon {\n  display: flex;\n}\n`;\n\n/**\n * Creates <style> element for widget dialog\n */\nexport function createDialogStyles(styleNonce?: string): HTMLStyleElement {\n  const style = DOCUMENT.createElement('style');\n\n  style.textContent = `\n:host {\n  --dialog-inset: var(--inset);\n}\n\n${DIALOG}\n${DIALOG_HEADER}\n${FORM}\n${BUTTON}\n${SUCCESS}\n`;\n\n  if (styleNonce) {\n    style.setAttribute('nonce', styleNonce);\n  }\n\n  return style;\n}\n","import type { FeedbackFormData, FeedbackModalIntegration, IntegrationFn, User } from '@sentry/core';\nimport { getClient, getCurrentScope, getGlobalScope, getIsolationScope } from '@sentry/core';\nimport { h, render } from 'preact';\nimport * as hooks from 'preact/hooks';\nimport { DOCUMENT } from '../constants';\nimport { Dialog } from './components/Dialog';\nimport { createDialogStyles } from './components/Dialog.css';\n\nfunction getUser(): User | undefined {\n  const currentUser = getCurrentScope().getUser();\n  const isolationUser = getIsolationScope().getUser();\n  const globalUser = getGlobalScope().getUser();\n  if (currentUser && Object.keys(currentUser).length) {\n    return currentUser;\n  }\n  if (isolationUser && Object.keys(isolationUser).length) {\n    return isolationUser;\n  }\n  return globalUser;\n}\n\nexport const feedbackModalIntegration = ((): FeedbackModalIntegration => {\n  return {\n    name: 'FeedbackModal',\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    setupOnce() {},\n    createDialog: ({ options, screenshotIntegration, sendFeedback, shadow }) => {\n      const shadowRoot = shadow as unknown as ShadowRoot;\n      const userKey = options.useSentryUser;\n      const user = getUser();\n\n      const el = DOCUMENT.createElement('div');\n      const style = createDialogStyles(options.styleNonce);\n\n      let originalOverflow = '';\n      const dialog: ReturnType<FeedbackModalIntegration['createDialog']> = {\n        get el() {\n          return el;\n        },\n        appendToDom(): void {\n          if (!shadowRoot.contains(style) && !shadowRoot.contains(el)) {\n            shadowRoot.appendChild(style);\n            shadowRoot.appendChild(el);\n          }\n        },\n        removeFromDom(): void {\n          el.remove();\n          style.remove();\n          DOCUMENT.body.style.overflow = originalOverflow;\n        },\n        open() {\n          renderContent(true);\n          options.onFormOpen?.();\n          getClient()?.emit('openFeedbackWidget');\n          originalOverflow = DOCUMENT.body.style.overflow;\n          DOCUMENT.body.style.overflow = 'hidden';\n        },\n        close() {\n          renderContent(false);\n          DOCUMENT.body.style.overflow = originalOverflow;\n        },\n      };\n\n      const screenshotInput = screenshotIntegration?.createInput({ h, hooks, dialog, options });\n\n      const renderContent = (open: boolean): void => {\n        render(\n          <Dialog\n            options={options}\n            screenshotInput={screenshotInput}\n            showName={options.showName || options.isNameRequired}\n            showEmail={options.showEmail || options.isEmailRequired}\n            defaultName={(userKey && user && user[userKey.name]) || ''}\n            defaultEmail={(userKey && user && user[userKey.email]) || ''}\n            onFormClose={() => {\n              renderContent(false);\n              options.onFormClose?.();\n            }}\n            onSubmit={sendFeedback}\n            onSubmitSuccess={(data: FeedbackFormData, eventId: string) => {\n              renderContent(false);\n              options.onSubmitSuccess?.(data, eventId);\n            }}\n            onSubmitError={(error: Error) => {\n              options.onSubmitError?.(error);\n            }}\n            onFormSubmitted={() => {\n              options.onFormSubmitted?.();\n            }}\n            open={open}\n          />,\n          el,\n        );\n      };\n\n      return dialog;\n    },\n  };\n}) satisfies IntegrationFn;\n","import type { h as hType, VNode } from 'preact';\n\ninterface FactoryParams {\n  h: typeof hType;\n}\n\nexport default function IconCloseFactory({\n  h, // eslint-disable-line @typescript-eslint/no-unused-vars\n}: FactoryParams) {\n  return function IconClose(): VNode {\n    return (\n      <svg data-test-id=\"icon-close\" viewBox=\"0 0 16 16\" fill=\"#2B2233\" height=\"25px\" width=\"25px\">\n        <circle r=\"7\" cx=\"8\" cy=\"8\" fill=\"white\" />\n        <path\n          strokeWidth=\"1.5\"\n          d=\"M8,16a8,8,0,1,1,8-8A8,8,0,0,1,8,16ZM8,1.53A6.47,6.47,0,1,0,14.47,8,6.47,6.47,0,0,0,8,1.53Z\"\n        ></path>\n        <path\n          strokeWidth=\"1.5\"\n          d=\"M5.34,11.41a.71.71,0,0,1-.53-.22.74.74,0,0,1,0-1.06l5.32-5.32a.75.75,0,0,1,1.06,1.06L5.87,11.19A.74.74,0,0,1,5.34,11.41Z\"\n        ></path>\n        <path\n          strokeWidth=\"1.5\"\n          d=\"M10.66,11.41a.74.74,0,0,1-.53-.22L4.81,5.87A.75.75,0,0,1,5.87,4.81l5.32,5.32a.74.74,0,0,1,0,1.06A.71.71,0,0,1,10.66,11.41Z\"\n        ></path>\n      </svg>\n    );\n  };\n}\n","import { DOCUMENT } from '../../constants';\n\n/**\n * Creates <style> element for widget dialog\n */\nexport function createScreenshotInputStyles(styleNonce?: string): HTMLStyleElement {\n  const style = DOCUMENT.createElement('style');\n\n  const surface200 = '#1A141F';\n  const gray100 = '#302735';\n\n  style.textContent = `\n.editor {\n  display: flex;\n  flex-grow: 1;\n  flex-direction: column;\n}\n\n.editor__image-container {\n  justify-items: center;\n  padding: 15px;\n  position: relative;\n  height: 100%;\n  border-radius: var(--menu-border-radius, 6px);\n\n  background-color: ${surface200};\n  background-image: repeating-linear-gradient(\n      -145deg,\n      transparent,\n      transparent 8px,\n      ${surface200} 8px,\n      ${surface200} 11px\n    ),\n    repeating-linear-gradient(\n      -45deg,\n      transparent,\n      transparent 15px,\n      ${gray100} 15px,\n      ${gray100} 16px\n    );\n}\n\n.editor__canvas-container {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.editor__canvas-container > * {\n  object-fit: contain;\n  position: absolute;\n}\n\n.editor__tool-container {\n  padding-top: 8px;\n  display: flex;\n  justify-content: center;\n}\n\n.editor__tool-bar {\n  display: flex;\n  gap: 8px;\n}\n\n.editor__tool {\n  display: flex;\n  padding: 8px 12px;\n  justify-content: center;\n  align-items: center;\n  border: var(--button-border, var(--border));\n  border-radius: var(--button-border-radius, 6px);\n  background: var(--button-background, var(--background));\n  color: var(--button-color, var(--foreground));\n}\n\n.editor__tool--active {\n  background: var(--button-primary-background, var(--accent-background));\n  color: var(--button-primary-color, var(--accent-foreground));\n}\n\n.editor__rect {\n  position: absolute;\n  z-index: 2;\n}\n\n.editor__rect button {\n  opacity: 0;\n  position: absolute;\n  top: -12px;\n  right: -12px;\n  cursor: pointer;\n  padding: 0;\n  z-index: 3;\n  border: none;\n  background: none;\n}\n\n.editor__rect:hover button {\n  opacity: 1;\n}\n`;\n\n  if (styleNonce) {\n    style.setAttribute('nonce', styleNonce);\n  }\n\n  return style;\n}\n","import type { h as hType, VNode } from 'preact';\nimport type * as Hooks from 'preact/hooks';\n\ninterface FactoryParams {\n  h: typeof hType;\n}\n\nexport default function ToolbarFactory({\n  h, // eslint-disable-line @typescript-eslint/no-unused-vars\n}: FactoryParams) {\n  return function Toolbar({\n    action,\n    setAction,\n  }: {\n    action: 'highlight' | 'hide' | '';\n    setAction: Hooks.StateUpdater<'highlight' | 'hide' | ''>;\n  }): VNode {\n    return (\n      <div class=\"editor__tool-container\">\n        <div class=\"editor__tool-bar\">\n          <button\n            type=\"button\"\n            class={`editor__tool ${action === 'highlight' ? 'editor__tool--active' : ''}`}\n            onClick={() => {\n              setAction(action === 'highlight' ? '' : 'highlight');\n            }}\n          >\n            Highlight\n          </button>\n          <button\n            type=\"button\"\n            class={`editor__tool ${action === 'hide' ? 'editor__tool--active' : ''}`}\n            onClick={() => {\n              setAction(action === 'hide' ? '' : 'hide');\n            }}\n          >\n            Hide\n          </button>\n        </div>\n      </div>\n    );\n  };\n}\n","import type * as Hooks from 'preact/hooks';\nimport { DOCUMENT, NAVIGATOR, WINDOW } from '../../constants';\n\ninterface FactoryParams {\n  hooks: typeof Hooks;\n}\n\ninterface Props {\n  onBeforeScreenshot: () => void;\n  onScreenshot: (imageSource: HTMLVideoElement, dpi: number) => void;\n  onAfterScreenshot: () => void;\n  onError: (error: Error) => void;\n}\n\ntype UseTakeScreenshot = ({ onBeforeScreenshot, onScreenshot, onAfterScreenshot, onError }: Props) => void;\n\nexport function useTakeScreenshotFactory({ hooks }: FactoryParams): UseTakeScreenshot {\n  function useDpi(): number {\n    const [dpi, setDpi] = hooks.useState<number>(WINDOW.devicePixelRatio ?? 1);\n    hooks.useEffect(() => {\n      const onChange = (): void => {\n        setDpi(WINDOW.devicePixelRatio);\n      };\n      const media = matchMedia(`(resolution: ${WINDOW.devicePixelRatio}dppx)`);\n      media.addEventListener('change', onChange);\n      return () => {\n        media.removeEventListener('change', onChange);\n      };\n    }, []);\n\n    return dpi;\n  }\n\n  return function useTakeScreenshot({ onBeforeScreenshot, onScreenshot, onAfterScreenshot, onError }: Props) {\n    const dpi = useDpi();\n\n    hooks.useEffect(() => {\n      const takeScreenshot = async (): Promise<void> => {\n        onBeforeScreenshot();\n\n        // Chrome will animate a top-bar which can shrink the window height by a\n        // few pixels. The exact amount depends on how fast it takes to exec\n        // the onloadedmetadata callback.\n        // https://stackoverflow.com/q/75833049\n        const stream = await NAVIGATOR.mediaDevices.getDisplayMedia({\n          video: {\n            width: WINDOW.innerWidth * dpi,\n            height: WINDOW.innerHeight * dpi,\n          },\n          audio: false,\n          // @ts-expect-error experimental flags: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia#prefercurrenttab\n          monitorTypeSurfaces: 'exclude',\n          preferCurrentTab: true,\n          selfBrowserSurface: 'include',\n          surfaceSwitching: 'exclude',\n        });\n\n        const video = DOCUMENT.createElement('video');\n        await new Promise<void>((resolve, reject) => {\n          video.srcObject = stream;\n          video.onloadedmetadata = () => {\n            onScreenshot(video, dpi);\n            stream.getTracks().forEach(track => track.stop());\n            resolve();\n          };\n          video.play().catch(reject);\n        });\n        onAfterScreenshot();\n      };\n\n      takeScreenshot().catch(onError);\n    }, []);\n  };\n}\n","import type { FeedbackInternalOptions, FeedbackModalIntegration } from '@sentry/core';\nimport type { ComponentType, h as hType, VNode } from 'preact';\nimport { h } from 'preact'; // eslint-disable-line @typescript-eslint/no-unused-vars\nimport type * as Hooks from 'preact/hooks';\nimport { DOCUMENT, WINDOW } from '../../constants';\nimport IconCloseFactory from './IconClose';\nimport { createScreenshotInputStyles } from './ScreenshotInput.css';\nimport ToolbarFactory from './Toolbar';\nimport { useTakeScreenshotFactory } from './useTakeScreenshot';\n\ninterface FactoryParams {\n  h: typeof hType;\n  hooks: typeof Hooks;\n\n  /**\n   * A ref to a Canvas Element that serves as our \"value\" or image output.\n   */\n  outputBuffer: HTMLCanvasElement;\n\n  /**\n   * A reference to the whole dialog (the parent of this component) so that we\n   * can show/hide it and take a clean screenshot of the webpage.\n   */\n  dialog: ReturnType<FeedbackModalIntegration['createDialog']>;\n\n  /**\n   * The whole options object.\n   *\n   * Needed to set nonce and id values for editor specific styles\n   */\n  options: FeedbackInternalOptions;\n}\n\ninterface Props {\n  onError: (error: Error) => void;\n}\n\ntype MaybeCanvas = HTMLCanvasElement | null;\ntype Screenshot = { canvas: HTMLCanvasElement; dpi: number };\n\ntype DrawType = 'highlight' | 'hide' | '';\ninterface DrawCommand {\n  type: DrawType;\n  x: number;\n  y: number;\n  h: number;\n  w: number;\n}\n\nfunction drawRect(command: DrawCommand, ctx: CanvasRenderingContext2D, color: string): void {\n  switch (command.type) {\n    case 'highlight': {\n      // creates a shadow around\n      ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';\n      ctx.shadowBlur = 50;\n\n      // draws a rectangle first with a shadow\n      ctx.fillStyle = color;\n      ctx.fillRect(command.x - 1, command.y - 1, command.w + 2, command.h + 2);\n\n      // cut out the inside of the rectangle\n      ctx.clearRect(command.x, command.y, command.w, command.h);\n\n      break;\n    }\n    case 'hide':\n      ctx.fillStyle = 'rgb(0, 0, 0)';\n      ctx.fillRect(command.x, command.y, command.w, command.h);\n\n      break;\n    default:\n      break;\n  }\n}\n\nfunction with2dContext(\n  canvas: MaybeCanvas,\n  options: CanvasRenderingContext2DSettings,\n  callback: (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => void,\n): void {\n  if (!canvas) {\n    return;\n  }\n  const ctx = canvas.getContext('2d', options);\n  if (!ctx) {\n    return;\n  }\n  callback(canvas, ctx);\n}\n\nfunction paintImage(maybeDest: MaybeCanvas, source: HTMLCanvasElement): void {\n  with2dContext(maybeDest, { alpha: true }, (destCanvas, destCtx) => {\n    destCtx.drawImage(source, 0, 0, source.width, source.height, 0, 0, destCanvas.width, destCanvas.height);\n  });\n}\n\n// Paint the array of drawCommands into a canvas.\n// Assuming this is the canvas foreground, and the background is cleaned.\nfunction paintForeground(maybeCanvas: MaybeCanvas, strokeColor: string, drawCommands: DrawCommand[]): void {\n  with2dContext(maybeCanvas, { alpha: true }, (canvas, ctx) => {\n    // If there's anything to draw, then we'll first clear the canvas with\n    // a transparent grey background\n    if (drawCommands.length) {\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    drawCommands.forEach(command => {\n      drawRect(command, ctx, strokeColor);\n    });\n  });\n}\n\nexport function ScreenshotEditorFactory({\n  h,\n  hooks,\n  outputBuffer,\n  dialog,\n  options,\n}: FactoryParams): ComponentType<Props> {\n  const useTakeScreenshot = useTakeScreenshotFactory({ hooks });\n  const Toolbar = ToolbarFactory({ h });\n  const IconClose = IconCloseFactory({ h });\n  const editorStyleInnerText = { __html: createScreenshotInputStyles(options.styleNonce).innerText };\n\n  const dialogStyle = (dialog.el as HTMLElement).style;\n\n  const ScreenshotEditor = ({ screenshot }: { screenshot: Screenshot }): VNode => {\n    // Data for rendering:\n    const [action, setAction] = hooks.useState<DrawType>('highlight');\n    const [drawCommands, setDrawCommands] = hooks.useState<DrawCommand[]>([]);\n\n    // Refs to our html components:\n    const measurementRef = hooks.useRef<HTMLDivElement | null>(null);\n    const backgroundRef = hooks.useRef<MaybeCanvas>(null);\n    const foregroundRef = hooks.useRef<MaybeCanvas>(null);\n    const mouseRef = hooks.useRef<HTMLDivElement | null>(null);\n\n    // The size of our window, relative to the imageSource\n    const [scaleFactor, setScaleFactor] = hooks.useState<number>(1);\n\n    const strokeColor = hooks.useMemo((): string => {\n      const sentryFeedback = DOCUMENT.getElementById(options.id);\n      if (!sentryFeedback) {\n        return 'white';\n      }\n      const computedStyle = getComputedStyle(sentryFeedback);\n      return (\n        computedStyle.getPropertyValue('--button-primary-background') ||\n        computedStyle.getPropertyValue('--accent-background')\n      );\n    }, [options.id]);\n\n    // The initial resize, to measure the area and set the children to the correct size\n    hooks.useLayoutEffect(() => {\n      const handleResize = (): void => {\n        const measurementDiv = measurementRef.current;\n        if (!measurementDiv) {\n          return;\n        }\n\n        with2dContext(screenshot.canvas, { alpha: false }, canvas => {\n          const scale = Math.min(\n            measurementDiv.clientWidth / canvas.width,\n            measurementDiv.clientHeight / canvas.height,\n          );\n          setScaleFactor(scale);\n        });\n\n        // For Firefox, the canvas is not yet measured, so we need to wait for it to get the correct size\n        if (measurementDiv.clientHeight === 0 || measurementDiv.clientWidth === 0) {\n          setTimeout(handleResize, 0);\n        }\n      };\n\n      handleResize();\n      WINDOW.addEventListener('resize', handleResize);\n      return () => {\n        WINDOW.removeEventListener('resize', handleResize);\n      };\n    }, [screenshot]);\n\n    // Set the size of the canvas element to match our screenshot\n    const setCanvasSize = hooks.useCallback(\n      (maybeCanvas: MaybeCanvas, scale: number): void => {\n        with2dContext(maybeCanvas, { alpha: true }, (canvas, ctx) => {\n          // Must call `scale()` before setting `width` & `height`\n          ctx.scale(scale, scale);\n          canvas.width = screenshot.canvas.width;\n          canvas.height = screenshot.canvas.height;\n        });\n      },\n      [screenshot],\n    );\n\n    // Draw the screenshot into the background\n    hooks.useEffect(() => {\n      setCanvasSize(backgroundRef.current, screenshot.dpi);\n      paintImage(backgroundRef.current, screenshot.canvas);\n    }, [screenshot]);\n\n    // Draw the commands into the foreground\n    hooks.useEffect(() => {\n      setCanvasSize(foregroundRef.current, screenshot.dpi);\n      with2dContext(foregroundRef.current, { alpha: true }, (canvas, ctx) => {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n      });\n      paintForeground(foregroundRef.current, strokeColor, drawCommands);\n    }, [drawCommands, strokeColor]);\n\n    // Draw into the output outputBuffer\n    hooks.useEffect(() => {\n      setCanvasSize(outputBuffer, screenshot.dpi);\n      paintImage(outputBuffer, screenshot.canvas);\n      with2dContext(DOCUMENT.createElement('canvas'), { alpha: true }, (foreground, ctx) => {\n        ctx.scale(screenshot.dpi, screenshot.dpi); // The scale needs to be set before we set the width/height and paint\n        foreground.width = screenshot.canvas.width;\n        foreground.height = screenshot.canvas.height;\n        paintForeground(foreground, strokeColor, drawCommands);\n        paintImage(outputBuffer, foreground);\n      });\n    }, [drawCommands, screenshot, strokeColor]);\n\n    const handleMouseDown = (e: MouseEvent): void => {\n      if (!action || !mouseRef.current) {\n        return;\n      }\n\n      const boundingRect = mouseRef.current.getBoundingClientRect();\n      const startingPoint: DrawCommand = {\n        type: action,\n        x: e.offsetX / scaleFactor,\n        y: e.offsetY / scaleFactor,\n        w: 0,\n        h: 0,\n      };\n\n      const getDrawCommand = (startingPoint: DrawCommand, e: MouseEvent): DrawCommand => {\n        const x = (e.clientX - boundingRect.x) / scaleFactor;\n        const y = (e.clientY - boundingRect.y) / scaleFactor;\n        return {\n          type: startingPoint.type,\n          x: Math.min(startingPoint.x, x),\n          y: Math.min(startingPoint.y, y),\n          w: Math.abs(x - startingPoint.x),\n          h: Math.abs(y - startingPoint.y),\n        } as DrawCommand;\n      };\n\n      const handleMouseMove = (e: MouseEvent): void => {\n        with2dContext(foregroundRef.current, { alpha: true }, (canvas, ctx) => {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n        });\n        paintForeground(foregroundRef.current, strokeColor, [...drawCommands, getDrawCommand(startingPoint, e)]);\n      };\n\n      const handleMouseUp = (e: MouseEvent): void => {\n        const drawCommand = getDrawCommand(startingPoint, e);\n\n        // Prevent just clicking onto the canvas, mouse has to move at least 1 pixel\n        if (drawCommand.w * scaleFactor >= 1 && drawCommand.h * scaleFactor >= 1) {\n          setDrawCommands(prev => [...prev, drawCommand]);\n        }\n        DOCUMENT.removeEventListener('mousemove', handleMouseMove);\n        DOCUMENT.removeEventListener('mouseup', handleMouseUp);\n      };\n\n      DOCUMENT.addEventListener('mousemove', handleMouseMove);\n      DOCUMENT.addEventListener('mouseup', handleMouseUp);\n    };\n\n    const deleteRect = hooks.useCallback((index: number): hType.JSX.MouseEventHandler<HTMLButtonElement> => {\n      return (e: MouseEvent): void => {\n        e.preventDefault();\n        e.stopPropagation();\n        setDrawCommands(prev => {\n          const updatedRects = [...prev];\n          updatedRects.splice(index, 1);\n          return updatedRects;\n        });\n      };\n    }, []);\n\n    const dimensions = {\n      width: `${screenshot.canvas.width * scaleFactor}px`,\n      height: `${screenshot.canvas.height * scaleFactor}px`,\n    };\n\n    const handleStopPropagation = (e: MouseEvent): void => {\n      e.stopPropagation();\n    };\n\n    return (\n      <div class=\"editor\">\n        <style nonce={options.styleNonce} dangerouslySetInnerHTML={editorStyleInnerText} />\n        <div class=\"editor__image-container\">\n          <div class=\"editor__canvas-container\" ref={measurementRef}>\n            <canvas ref={backgroundRef} id=\"background\" style={dimensions} />\n            <canvas ref={foregroundRef} id=\"foreground\" style={dimensions} />\n            <div ref={mouseRef} onMouseDown={handleMouseDown} style={dimensions}>\n              {drawCommands.map((rect, index) => (\n                <div\n                  key={index}\n                  class=\"editor__rect\"\n                  style={{\n                    top: `${rect.y * scaleFactor}px`,\n                    left: `${rect.x * scaleFactor}px`,\n                    width: `${rect.w * scaleFactor}px`,\n                    height: `${rect.h * scaleFactor}px`,\n                  }}\n                >\n                  <button\n                    aria-label=\"Remove\"\n                    onClick={deleteRect(index)}\n                    onMouseDown={handleStopPropagation}\n                    onMouseUp={handleStopPropagation}\n                    type=\"button\"\n                  >\n                    <IconClose />\n                  </button>\n                </div>\n              ))}\n            </div>\n          </div>\n        </div>\n        <Toolbar action={action} setAction={setAction} />\n      </div>\n    );\n  };\n\n  return function Wrapper({ onError }: Props): VNode {\n    const [screenshot, setScreenshot] = hooks.useState<undefined | Screenshot>();\n\n    useTakeScreenshot({\n      onBeforeScreenshot: hooks.useCallback(() => {\n        dialogStyle.display = 'none';\n      }, []),\n      onScreenshot: hooks.useCallback((screenshotVideo: HTMLVideoElement, dpi: number) => {\n        // Stash the original screenshot image so we can (re)draw it multiple times\n        with2dContext(DOCUMENT.createElement('canvas'), { alpha: false }, (canvas, ctx) => {\n          ctx.scale(dpi, dpi); // The scale needs to be set before we set the width/height and paint\n          canvas.width = screenshotVideo.videoWidth;\n          canvas.height = screenshotVideo.videoHeight;\n          ctx.drawImage(screenshotVideo, 0, 0, canvas.width, canvas.height);\n\n          setScreenshot({ canvas, dpi });\n        });\n\n        // The output buffer, we only need to set the width/height on this once, it stays the same forever\n        outputBuffer.width = screenshotVideo.videoWidth;\n        outputBuffer.height = screenshotVideo.videoHeight;\n      }, []),\n      onAfterScreenshot: hooks.useCallback(() => {\n        dialogStyle.display = 'block';\n      }, []),\n      onError: hooks.useCallback(error => {\n        dialogStyle.display = 'block';\n        onError(error);\n      }, []),\n    });\n\n    if (screenshot) {\n      return <ScreenshotEditor screenshot={screenshot} />;\n    }\n\n    return <div />;\n  };\n}\n","import type { Attachment, FeedbackScreenshotIntegration, IntegrationFn } from '@sentry/core';\nimport type { h as hType } from 'preact';\nimport type * as Hooks from 'preact/hooks';\nimport { DOCUMENT } from '../constants';\nimport { ScreenshotEditorFactory } from './components/ScreenshotEditor';\n\nexport const feedbackScreenshotIntegration = ((): FeedbackScreenshotIntegration => {\n  return {\n    name: 'FeedbackScreenshot',\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    setupOnce() {},\n    createInput: ({ h, hooks, dialog, options }) => {\n      const outputBuffer = DOCUMENT.createElement('canvas');\n\n      return {\n        input: ScreenshotEditorFactory({\n          h: h as typeof hType,\n          hooks: hooks as typeof Hooks,\n          outputBuffer,\n          dialog,\n          options,\n        }) as any, // eslint-disable-line @typescript-eslint/no-explicit-any\n\n        value: async () => {\n          const blob = await new Promise<Parameters<BlobCallback>[0]>(resolve => {\n            outputBuffer.toBlob(resolve, 'image/png');\n          });\n          if (blob) {\n            const data = new Uint8Array(await blob.arrayBuffer());\n            const attachment: Attachment = {\n              data,\n              filename: 'screenshot.png',\n              contentType: 'application/png',\n              // attachmentType?: string;\n            };\n            return attachment;\n          }\n          return undefined;\n        },\n      };\n    },\n  };\n}) satisfies IntegrationFn;\n"],"names":["XMLNS","l","u","i","o","r","f","c","s","a","h","v","p","y","d","g","b","m","w","k","x","C","j","P","T","A","D","q","z","B","n","useMemo","useState","useCallback","Fragment","render"],"mappings":"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"}},
    {"offset": {"line": 3374, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3379, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@sentry-internal+replay-canvas@9.37.0/node_modules/node_modules/@sentry-internal/rrweb/dist/rrweb.js","/turbopack/[project]/node_modules/.pnpm/@sentry-internal+replay-canvas@9.37.0/node_modules/@sentry-internal/replay-canvas/src/canvas.ts"],"sourcesContent":["var __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar NodeType$2 = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType$2 || {});\nfunction isElement(n2) {\n  return n2.nodeType === n2.ELEMENT_NODE;\n}\nfunction isShadowRoot(n2) {\n  const host = n2?.host;\n  return Boolean(host?.shadowRoot === n2);\n}\nfunction isNativeShadowDom(shadowRoot) {\n  return Object.prototype.toString.call(shadowRoot) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n  if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n    cssText = cssText.replace(\n      /\\sbackground-clip:\\s*text;/g,\n      \" -webkit-background-clip: text; background-clip: text;\"\n    );\n  }\n  return cssText;\n}\nfunction escapeImportStatement(rule) {\n  const { cssText } = rule;\n  if (cssText.split('\"').length < 3) return cssText;\n  const statement = [\"@import\", `url(${JSON.stringify(rule.href)})`];\n  if (rule.layerName === \"\") {\n    statement.push(`layer`);\n  } else if (rule.layerName) {\n    statement.push(`layer(${rule.layerName})`);\n  }\n  if (rule.supportsText) {\n    statement.push(`supports(${rule.supportsText})`);\n  }\n  if (rule.media.length) {\n    statement.push(rule.media.mediaText);\n  }\n  return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s2) {\n  try {\n    const rules2 = s2.rules || s2.cssRules;\n    return rules2 ? fixBrowserCompatibilityIssuesInCSS(\n      Array.from(rules2, stringifyRule).join(\"\")\n    ) : null;\n  } catch (error) {\n    return null;\n  }\n}\nfunction fixAllCssProperty(rule) {\n  let styles = \"\";\n  for (let i2 = 0; i2 < rule.style.length; i2++) {\n    const styleDeclaration = rule.style;\n    const attribute = styleDeclaration[i2];\n    const isImportant = styleDeclaration.getPropertyPriority(attribute);\n    styles += `${attribute}:${styleDeclaration.getPropertyValue(attribute)}${isImportant ? ` !important` : \"\"};`;\n  }\n  return `${rule.selectorText} { ${styles} }`;\n}\nfunction stringifyRule(rule) {\n  let importStringified;\n  if (isCSSImportRule(rule)) {\n    try {\n      importStringified = // for same-origin stylesheets,\n      // we can access the imported stylesheet rules directly\n      stringifyStylesheet(rule.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement\n      escapeImportStatement(rule);\n    } catch (error) {\n    }\n  } else if (isCSSStyleRule(rule)) {\n    let cssText = rule.cssText;\n    const needsSafariColonFix = rule.selectorText.includes(\":\");\n    const needsAllFix = typeof rule.style[\"all\"] === \"string\" && rule.style[\"all\"];\n    if (needsAllFix) {\n      cssText = fixAllCssProperty(rule);\n    }\n    if (needsSafariColonFix) {\n      cssText = fixSafariColons(cssText);\n    }\n    if (needsSafariColonFix || needsAllFix) {\n      return cssText;\n    }\n  }\n  return importStringified || rule.cssText;\n}\nfunction fixSafariColons(cssStringified) {\n  const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n  return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule) {\n  return \"styleSheet\" in rule;\n}\nfunction isCSSStyleRule(rule) {\n  return \"selectorText\" in rule;\n}\nclass Mirror {\n  constructor() {\n    __publicField$1(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField$1(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach(\n        (childNode) => this.removeNodeFromMap(childNode)\n      );\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n}\nfunction createMirror$2() {\n  return new Mirror();\n}\nfunction shouldMaskInput({\n  maskInputOptions,\n  tagName,\n  type\n}) {\n  if (tagName === \"OPTION\") {\n    tagName = \"SELECT\";\n  }\n  return Boolean(\n    maskInputOptions[tagName.toLowerCase()] || type && maskInputOptions[type] || type === \"password\" || // Default to \"text\" option for inputs without a \"type\" attribute defined\n    tagName === \"INPUT\" && !type && maskInputOptions[\"text\"]\n  );\n}\nfunction maskInputValue({\n  isMasked,\n  element,\n  value,\n  maskInputFn\n}) {\n  let text = value || \"\";\n  if (!isMasked) {\n    return text;\n  }\n  if (maskInputFn) {\n    text = maskInputFn(text, element);\n  }\n  return \"*\".repeat(text.length);\n}\nfunction toLowerCase(str) {\n  return str.toLowerCase();\n}\nfunction toUpperCase(str) {\n  return str.toUpperCase();\n}\nconst ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return true;\n  const chunkSize = 50;\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData;\n      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n      const pixelBuffer = new Uint32Array(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y)\n        ).data.buffer\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\nfunction isNodeMetaEqual(a2, b) {\n  if (!a2 || !b || a2.type !== b.type) return false;\n  if (a2.type === NodeType$2.Document)\n    return a2.compatMode === b.compatMode;\n  else if (a2.type === NodeType$2.DocumentType)\n    return a2.name === b.name && a2.publicId === b.publicId && a2.systemId === b.systemId;\n  else if (a2.type === NodeType$2.Comment || a2.type === NodeType$2.Text || a2.type === NodeType$2.CDATA)\n    return a2.textContent === b.textContent;\n  else if (a2.type === NodeType$2.Element)\n    return a2.tagName === b.tagName && JSON.stringify(a2.attributes) === JSON.stringify(b.attributes) && a2.isSVG === b.isSVG && a2.needBlock === b.needBlock;\n  return false;\n}\nfunction getInputType(element) {\n  const type = element.type;\n  return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    toLowerCase(type)\n  ) : null;\n}\nfunction getInputValue(el, tagName, type) {\n  if (tagName === \"INPUT\" && (type === \"radio\" || type === \"checkbox\")) {\n    return el.getAttribute(\"value\") || \"\";\n  }\n  return el.value;\n}\nfunction extractFileExtension(path, baseURL) {\n  let url;\n  try {\n    url = new URL(path, baseURL ?? window.location.href);\n  } catch (err) {\n    return null;\n  }\n  const regex = /\\.([0-9a-z]+)(?:$)/i;\n  const match = url.pathname.match(regex);\n  return match?.[1] ?? null;\n}\nconst cachedImplementations$1 = {};\nfunction getImplementation$1(name) {\n  const cached = cachedImplementations$1[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations$1[name] = impl.bind(\n    window\n  );\n}\nfunction setTimeout$2(...rest) {\n  return getImplementation$1(\"setTimeout\")(...rest);\n}\nfunction clearTimeout$1(...rest) {\n  return getImplementation$1(\"clearTimeout\")(...rest);\n}\nfunction getIframeContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nlet _id = 1;\nconst tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nconst IGNORED_NODE = -2;\nfunction genId() {\n  return _id++;\n}\nfunction getValidTagName$1(element) {\n  if (element instanceof HTMLFormElement) {\n    return \"form\";\n  }\n  const processedTagName = toLowerCase(element.tagName);\n  if (tagNameRegex.test(processedTagName)) {\n    return \"div\";\n  }\n  return processedTagName;\n}\nfunction extractOrigin(url) {\n  let origin = \"\";\n  if (url.indexOf(\"//\") > -1) {\n    origin = url.split(\"/\").slice(0, 3).join(\"/\");\n  } else {\n    origin = url.split(\"/\")[0];\n  }\n  origin = origin.split(\"?\")[0];\n  return origin;\n}\nlet canvasService;\nlet canvasCtx;\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n  return (cssText || \"\").replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || \"\";\n      if (!filePath) {\n        return origin;\n      }\n      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === \"/\") {\n        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\n      }\n      const stack = href.split(\"/\");\n      const parts = filePath.split(\"/\");\n      stack.pop();\n      for (const part of parts) {\n        if (part === \".\") {\n          continue;\n        } else if (part === \"..\") {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join(\"/\")}${maybeQuote})`;\n    }\n  );\n}\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n  if (attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  let pos = 0;\n  function collectCharacters(regEx) {\n    let chars2;\n    const match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars2 = match[0];\n      pos += chars2.length;\n      return chars2;\n    }\n    return \"\";\n  }\n  const output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === \",\") {\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      output.push(url);\n    } else {\n      let descriptorsStr = \"\";\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        const c2 = attributeValue.charAt(pos);\n        if (c2 === \"\") {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c2 === \",\") {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break;\n          } else if (c2 === \"(\") {\n            inParens = true;\n          }\n        } else {\n          if (c2 === \")\") {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c2;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(\", \");\n}\nconst cachedDocument = /* @__PURE__ */ new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n  if (!attributeValue || attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n  return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n  let a2 = cachedDocument.get(doc);\n  if (!a2) {\n    a2 = doc.createElement(\"a\");\n    cachedDocument.set(doc, a2);\n  }\n  if (!customHref) {\n    customHref = \"\";\n  } else if (customHref.startsWith(\"blob:\") || customHref.startsWith(\"data:\")) {\n    return customHref;\n  }\n  a2.setAttribute(\"href\", customHref);\n  return a2.href;\n}\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn) {\n  if (!value) {\n    return value;\n  }\n  if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"srcset\") {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === \"style\") {\n    return absoluteToStylesheet(value, getHref(doc));\n  } else if (tagName === \"object\" && name === \"data\") {\n    return absoluteToDoc(doc, value);\n  }\n  if (typeof maskAttributeFn === \"function\") {\n    return maskAttributeFn(name, value, element);\n  }\n  return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n  return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\n  try {\n    if (unblockSelector && element.matches(unblockSelector)) {\n      return false;\n    }\n    if (typeof blockClass === \"string\") {\n      if (element.classList.contains(blockClass)) {\n        return true;\n      }\n    } else {\n      for (let eIndex = element.classList.length; eIndex--; ) {\n        const className = element.classList[eIndex];\n        if (blockClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (blockSelector) {\n      return element.matches(blockSelector);\n    }\n  } catch (e2) {\n  }\n  return false;\n}\nfunction elementClassMatchesRegex(el, regex) {\n  for (let eIndex = el.classList.length; eIndex--; ) {\n    const className = el.classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n  if (!node) return -1;\n  if (node.nodeType !== node.ELEMENT_NODE) return -1;\n  if (distance > limit) return -1;\n  if (matchPredicate(node)) return distance;\n  return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n}\nfunction createMatchPredicate(className, selector) {\n  return (node) => {\n    const el = node;\n    if (el === null) return false;\n    try {\n      if (className) {\n        if (typeof className === \"string\") {\n          if (el.matches(`.${className}`)) return true;\n        } else if (elementClassMatchesRegex(el, className)) {\n          return true;\n        }\n      }\n      if (selector && el.matches(selector)) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  };\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    if (el === null) return false;\n    if (el.tagName === \"INPUT\") {\n      const autocomplete = el.getAttribute(\"autocomplete\");\n      const disallowedAutocompleteValues = [\n        \"current-password\",\n        \"new-password\",\n        \"cc-number\",\n        \"cc-exp\",\n        \"cc-exp-month\",\n        \"cc-exp-year\",\n        \"cc-csc\"\n      ];\n      if (disallowedAutocompleteValues.includes(autocomplete)) {\n        return true;\n      }\n    }\n    let maskDistance = -1;\n    let unmaskDistance = -1;\n    if (maskAllText) {\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector)\n      );\n      if (unmaskDistance < 0) {\n        return true;\n      }\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector),\n        unmaskDistance >= 0 ? unmaskDistance : Infinity\n      );\n    } else {\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector)\n      );\n      if (maskDistance < 0) {\n        return false;\n      }\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector),\n        maskDistance >= 0 ? maskDistance : Infinity\n      );\n    }\n    return maskDistance >= 0 ? unmaskDistance >= 0 ? maskDistance <= unmaskDistance : true : unmaskDistance >= 0 ? false : !!maskAllText;\n  } catch (e2) {\n  }\n  return !!maskAllText;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  let fired = false;\n  let readyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== \"complete\") {\n    const timer = setTimeout$2(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener(\"load\", () => {\n      clearTimeout$1(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  const blankUrl = \"about:blank\";\n  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n    setTimeout$2(listener, 0);\n    return iframeEl.addEventListener(\"load\", listener);\n  }\n  iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n  let fired = false;\n  let styleSheetLoaded;\n  try {\n    styleSheetLoaded = link.sheet;\n  } catch (error) {\n    return;\n  }\n  if (styleSheetLoaded) return;\n  const timer = setTimeout$2(() => {\n    if (!fired) {\n      listener();\n      fired = true;\n    }\n  }, styleSheetLoadTimeout);\n  link.addEventListener(\"load\", () => {\n    clearTimeout$1(timer);\n    fired = true;\n    listener();\n  });\n}\nfunction serializeNode(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskAttributeFn,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false\n  } = options;\n  const rootId = getRootId(doc, mirror2);\n  switch (n2.nodeType) {\n    case n2.DOCUMENT_NODE:\n      if (n2.compatMode !== \"CSS1Compat\") {\n        return {\n          type: NodeType$2.Document,\n          childNodes: [],\n          compatMode: n2.compatMode\n          // probably \"BackCompat\"\n        };\n      } else {\n        return {\n          type: NodeType$2.Document,\n          childNodes: []\n        };\n      }\n    case n2.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType$2.DocumentType,\n        name: n2.name,\n        publicId: n2.publicId,\n        systemId: n2.systemId,\n        rootId\n      };\n    case n2.ELEMENT_NODE:\n      return serializeElementNode(n2, {\n        doc,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        inlineStylesheet,\n        maskAttributeFn,\n        maskInputOptions,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement,\n        rootId,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector\n      });\n    case n2.TEXT_NODE:\n      return serializeTextNode(n2, {\n        doc,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        maskTextFn,\n        maskInputOptions,\n        maskInputFn,\n        rootId\n      });\n    case n2.CDATA_SECTION_NODE:\n      return {\n        type: NodeType$2.CDATA,\n        textContent: \"\",\n        rootId\n      };\n    case n2.COMMENT_NODE:\n      return {\n        type: NodeType$2.Comment,\n        textContent: n2.textContent || \"\",\n        rootId\n      };\n    default:\n      return false;\n  }\n}\nfunction getRootId(doc, mirror2) {\n  if (!mirror2.hasNode(doc)) return void 0;\n  const docId = mirror2.getId(doc);\n  return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n2, options) {\n  const {\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    maskTextFn,\n    maskInputOptions,\n    maskInputFn,\n    rootId\n  } = options;\n  const parentTagName = n2.parentNode && n2.parentNode.tagName;\n  let textContent = n2.textContent;\n  const isStyle = parentTagName === \"STYLE\" ? true : void 0;\n  const isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n  const isTextarea = parentTagName === \"TEXTAREA\" ? true : void 0;\n  if (isStyle && textContent) {\n    try {\n      if (n2.nextSibling || n2.previousSibling) {\n      } else if (n2.parentNode.sheet?.cssRules) {\n        textContent = stringifyStylesheet(\n          n2.parentNode.sheet\n        );\n      }\n    } catch (err) {\n      console.warn(\n        `Cannot get CSS styles from text's parentNode. Error: ${err}`,\n        n2\n      );\n    }\n    textContent = absoluteToStylesheet(textContent, getHref(options.doc));\n  }\n  if (isScript) {\n    textContent = \"SCRIPT_PLACEHOLDER\";\n  }\n  const forceMask = needMaskingText(\n    n2,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextClass,\n    unmaskTextSelector,\n    maskAllText\n  );\n  if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\n    textContent = maskTextFn ? maskTextFn(textContent, n2.parentElement) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\n    textContent = maskInputFn ? maskInputFn(textContent, n2.parentNode) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (parentTagName === \"OPTION\" && textContent) {\n    const isInputMasked = shouldMaskInput({\n      type: null,\n      tagName: parentTagName,\n      maskInputOptions\n    });\n    textContent = maskInputValue({\n      isMasked: needMaskingText(\n        n2,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        isInputMasked\n      ),\n      element: n2,\n      value: textContent,\n      maskInputFn\n    });\n  }\n  return {\n    type: NodeType$2.Text,\n    textContent: textContent || \"\",\n    isStyle,\n    rootId\n  };\n}\nfunction serializeElementNode(n2, options) {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    rootId,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector\n  } = options;\n  const needBlock = _isBlockedElement(\n    n2,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  );\n  const tagName = getValidTagName$1(n2);\n  let attributes2 = {};\n  const len = n2.attributes.length;\n  for (let i2 = 0; i2 < len; i2++) {\n    const attr = n2.attributes[i2];\n    if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\n      attributes2[attr.name] = transformAttribute(\n        doc,\n        tagName,\n        toLowerCase(attr.name),\n        attr.value,\n        n2,\n        maskAttributeFn\n      );\n    }\n  }\n  if (tagName === \"link\" && inlineStylesheet) {\n    const stylesheet = Array.from(doc.styleSheets).find((s2) => {\n      return s2.href === n2.href;\n    });\n    let cssText = null;\n    if (stylesheet) {\n      cssText = stringifyStylesheet(stylesheet);\n    }\n    if (cssText) {\n      attributes2.rel = null;\n      attributes2.href = null;\n      attributes2.crossorigin = null;\n      attributes2._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n    }\n  }\n  if (tagName === \"style\" && n2.sheet && // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n  !(n2.innerText || n2.textContent || \"\").trim().length) {\n    const cssText = stringifyStylesheet(\n      n2.sheet\n    );\n    if (cssText) {\n      attributes2._cssText = absoluteToStylesheet(cssText, getHref(doc));\n    }\n  }\n  if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\" || tagName === \"option\") {\n    const el = n2;\n    const type = getInputType(el);\n    const value = getInputValue(el, toUpperCase(tagName), type);\n    const checked = el.checked;\n    if (type !== \"submit\" && type !== \"button\" && value) {\n      const forceMask = needMaskingText(\n        el,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        shouldMaskInput({\n          type,\n          tagName: toUpperCase(tagName),\n          maskInputOptions\n        })\n      );\n      attributes2.value = maskInputValue({\n        isMasked: forceMask,\n        element: el,\n        value,\n        maskInputFn\n      });\n    }\n    if (checked) {\n      attributes2.checked = checked;\n    }\n  }\n  if (tagName === \"option\") {\n    if (n2.selected && !maskInputOptions[\"select\"]) {\n      attributes2.selected = true;\n    } else {\n      delete attributes2.selected;\n    }\n  }\n  if (tagName === \"canvas\" && recordCanvas) {\n    if (n2.__context === \"2d\") {\n      if (!is2DCanvasBlank(n2)) {\n        attributes2.rr_dataURL = n2.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      }\n    } else if (!(\"__context\" in n2)) {\n      const canvasDataURL = n2.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      const blankCanvas = doc.createElement(\"canvas\");\n      blankCanvas.width = n2.width;\n      blankCanvas.height = n2.height;\n      const blankCanvasDataURL = blankCanvas.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      if (canvasDataURL !== blankCanvasDataURL) {\n        attributes2.rr_dataURL = canvasDataURL;\n      }\n    }\n  }\n  if (tagName === \"img\" && inlineImages) {\n    if (!canvasService) {\n      canvasService = doc.createElement(\"canvas\");\n      canvasCtx = canvasService.getContext(\"2d\");\n    }\n    const image = n2;\n    const imageSrc = image.currentSrc || image.getAttribute(\"src\") || \"<unknown-src>\";\n    const priorCrossOrigin = image.crossOrigin;\n    const recordInlineImage = () => {\n      image.removeEventListener(\"load\", recordInlineImage);\n      try {\n        canvasService.width = image.naturalWidth;\n        canvasService.height = image.naturalHeight;\n        canvasCtx.drawImage(image, 0, 0);\n        attributes2.rr_dataURL = canvasService.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      } catch (err) {\n        if (image.crossOrigin !== \"anonymous\") {\n          image.crossOrigin = \"anonymous\";\n          if (image.complete && image.naturalWidth !== 0)\n            recordInlineImage();\n          else image.addEventListener(\"load\", recordInlineImage);\n          return;\n        } else {\n          console.warn(\n            `Cannot inline img src=${imageSrc}! Error: ${err}`\n          );\n        }\n      }\n      if (image.crossOrigin === \"anonymous\") {\n        priorCrossOrigin ? attributes2.crossOrigin = priorCrossOrigin : image.removeAttribute(\"crossorigin\");\n      }\n    };\n    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n    else image.addEventListener(\"load\", recordInlineImage);\n  }\n  if (tagName === \"audio\" || tagName === \"video\") {\n    attributes2.rr_mediaState = n2.paused ? \"paused\" : \"played\";\n    attributes2.rr_mediaCurrentTime = n2.currentTime;\n  }\n  if (!newlyAddedElement) {\n    if (n2.scrollLeft) {\n      attributes2.rr_scrollLeft = n2.scrollLeft;\n    }\n    if (n2.scrollTop) {\n      attributes2.rr_scrollTop = n2.scrollTop;\n    }\n  }\n  if (needBlock) {\n    const { width, height } = n2.getBoundingClientRect();\n    attributes2 = {\n      class: attributes2.class,\n      rr_width: `${width}px`,\n      rr_height: `${height}px`\n    };\n  }\n  if (tagName === \"iframe\" && !keepIframeSrcFn(attributes2.src)) {\n    if (!needBlock && !getIframeContentDocument(n2)) {\n      attributes2.rr_src = attributes2.src;\n    }\n    delete attributes2.src;\n  }\n  let isCustomElement;\n  try {\n    if (customElements.get(tagName)) isCustomElement = true;\n  } catch (e2) {\n  }\n  return {\n    type: NodeType$2.Element,\n    tagName,\n    attributes: attributes2,\n    childNodes: [],\n    isSVG: isSVGElement(n2) || void 0,\n    needBlock,\n    rootId,\n    isCustom: isCustomElement\n  };\n}\nfunction lowerIfExists(maybeAttr) {\n  if (maybeAttr === void 0 || maybeAttr === null) {\n    return \"\";\n  } else {\n    return maybeAttr.toLowerCase();\n  }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n  if (slimDOMOptions.comment && sn.type === NodeType$2.Comment) {\n    return true;\n  } else if (sn.type === NodeType$2.Element) {\n    if (slimDOMOptions.script && // script tag\n    (sn.tagName === \"script\" || // (module)preload link\n    sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") || // prefetch link\n    sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n      return true;\n    } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(\n      /^msapplication-tile(image|color)$/\n    ) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n      return true;\n    } else if (sn.tagName === \"meta\") {\n      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n        return true;\n      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n        return true;\n      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n        return true;\n      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction serializeNodeWithId(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5e3,\n    onStylesheetLoad,\n    stylesheetLoadTimeout = 5e3,\n    keepIframeSrcFn = () => false,\n    newlyAddedElement = false\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n2, {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    maskAllText,\n    unblockSelector,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement\n  });\n  if (!_serializedNode) {\n    console.warn(n2, \"not serialized\");\n    return null;\n  }\n  let id;\n  if (mirror2.hasNode(n2)) {\n    id = mirror2.getId(n2);\n  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$2.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode2 = Object.assign(_serializedNode, { id });\n  mirror2.add(n2, serializedNode2);\n  if (id === IGNORED_NODE) {\n    return null;\n  }\n  if (onSerialize) {\n    onSerialize(n2);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode2.type === NodeType$2.Element) {\n    recordChild = recordChild && !serializedNode2.needBlock;\n    delete serializedNode2.needBlock;\n    const shadowRoot = n2.shadowRoot;\n    if (shadowRoot && isNativeShadowDom(shadowRoot))\n      serializedNode2.isShadowHost = true;\n  }\n  if ((serializedNode2.type === NodeType$2.Document || serializedNode2.type === NodeType$2.Element) && recordChild) {\n    if (slimDOMOptions.headWhitespace && serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"head\") {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      mirror: mirror2,\n      blockClass,\n      blockSelector,\n      maskAllText,\n      unblockSelector,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn\n    };\n    for (const childN of Array.from(n2.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode2.childNodes.push(serializedChildNode);\n      }\n    }\n    if (isElement(n2) && n2.shadowRoot) {\n      for (const childN of Array.from(n2.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          isNativeShadowDom(n2.shadowRoot) && (serializedChildNode.isShadow = true);\n          serializedNode2.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n  if (n2.parentNode && isShadowRoot(n2.parentNode) && isNativeShadowDom(n2.parentNode)) {\n    serializedNode2.isShadow = true;\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"iframe\" && !_isBlockedElement(\n    n2,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  )) {\n    onceIframeLoaded(\n      n2,\n      () => {\n        const iframeDoc = getIframeContentDocument(n2);\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedIframeNode) {\n            onIframeLoad(\n              n2,\n              serializedIframeNode\n            );\n          }\n        }\n      },\n      iframeLoadTimeout\n    );\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"link\" && typeof serializedNode2.attributes.rel === \"string\" && (serializedNode2.attributes.rel === \"stylesheet\" || serializedNode2.attributes.rel === \"preload\" && typeof serializedNode2.attributes.href === \"string\" && extractFileExtension(serializedNode2.attributes.href) === \"css\")) {\n    onceStylesheetLoaded(\n      n2,\n      () => {\n        if (onStylesheetLoad) {\n          const serializedLinkNode = serializeNodeWithId(n2, {\n            doc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedLinkNode) {\n            onStylesheetLoad(\n              n2,\n              serializedLinkNode\n            );\n          }\n        }\n      },\n      stylesheetLoadTimeout\n    );\n  }\n  return serializedNode2;\n}\nfunction snapshot(n2, options) {\n  const {\n    mirror: mirror2 = new Mirror(),\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn = () => false\n  } = options || {};\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true\n  } : maskAllInputs === false ? {} : maskAllInputs;\n  const slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? (\n    // if true: set of sensible options that should not throw away any information\n    {\n      script: true,\n      comment: true,\n      headFavicon: true,\n      headWhitespace: true,\n      headMetaDescKeywords: slimDOM === \"all\",\n      // destructive\n      headMetaSocial: true,\n      headMetaRobots: true,\n      headMetaHttpEquiv: true,\n      headMetaAuthorship: true,\n      headMetaVerification: true\n    }\n  ) : slimDOM === false ? {} : slimDOM;\n  return serializeNodeWithId(n2, {\n    doc: n2,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild: false,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn,\n    newlyAddedElement: false\n  });\n}\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\nfunction parse(css, options = {}) {\n  let lineno = 1;\n  let column = 1;\n  function updatePosition(str) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    const i2 = str.lastIndexOf(\"\\n\");\n    column = i2 === -1 ? column + str.length : str.length - i2;\n  }\n  function position() {\n    const start = { line: lineno, column };\n    return (node) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n  const _Position = class _Position2 {\n    constructor(start) {\n      __publicField$1(this, \"content\");\n      __publicField$1(this, \"start\");\n      __publicField$1(this, \"end\");\n      __publicField$1(this, \"source\");\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n      this.content = _Position2.content;\n    }\n  };\n  __publicField$1(_Position, \"content\");\n  let Position = _Position;\n  Position.content = css;\n  const errorsList = [];\n  function error(msg) {\n    const err = new Error(\n      `${options.source || \"\"}:${lineno}:${column}: ${msg}`\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n  function stylesheet() {\n    const rulesList = rules2();\n    return {\n      type: \"stylesheet\",\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList\n      }\n    };\n  }\n  function open() {\n    return match(/^{\\s*/);\n  }\n  function close() {\n    return match(/^}/);\n  }\n  function rules2() {\n    let node;\n    const rules22 = [];\n    whitespace();\n    comments(rules22);\n    while (css.length && css.charAt(0) !== \"}\" && (node = atrule() || rule())) {\n      if (node) {\n        rules22.push(node);\n        comments(rules22);\n      }\n    }\n    return rules22;\n  }\n  function match(re) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n  function whitespace() {\n    match(/^\\s*/);\n  }\n  function comments(rules22 = []) {\n    let c2;\n    while (c2 = comment()) {\n      if (c2) {\n        rules22.push(c2);\n      }\n      c2 = comment();\n    }\n    return rules22;\n  }\n  function comment() {\n    const pos = position();\n    if (\"/\" !== css.charAt(0) || \"*\" !== css.charAt(1)) {\n      return;\n    }\n    let i2 = 2;\n    while (\"\" !== css.charAt(i2) && (\"*\" !== css.charAt(i2) || \"/\" !== css.charAt(i2 + 1))) {\n      ++i2;\n    }\n    i2 += 2;\n    if (\"\" === css.charAt(i2 - 1)) {\n      return error(\"End of comment missing\");\n    }\n    const str = css.slice(2, i2 - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i2);\n    column += 2;\n    return pos({\n      type: \"comment\",\n      comment: str\n    });\n  }\n  function selector() {\n    const m = match(/^([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const splitSelectors = trim(m[0]).replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, \"\").replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m2) => {\n      return m2.replace(/,/g, \"\");\n    }).split(/\\s*(?![^(]*\\)),\\s*/);\n    if (splitSelectors.length <= 1) {\n      return splitSelectors.map((s2) => {\n        return s2.replace(/\\u200C/g, \",\");\n      });\n    }\n    let i2 = 0;\n    let j = 0;\n    const len = splitSelectors.length;\n    const finalSelectors = [];\n    while (i2 < len) {\n      const openingParensCount = (splitSelectors[i2].match(/\\(/g) || []).length;\n      const closingParensCount = (splitSelectors[i2].match(/\\)/g) || []).length;\n      let unbalancedParens = openingParensCount - closingParensCount;\n      if (unbalancedParens >= 1) {\n        let foundClosingSelector = false;\n        j = i2 + 1;\n        while (j < len) {\n          const nextOpeningParensCount = (splitSelectors[j].match(/\\(/g) || []).length;\n          const nextClosingParensCount = (splitSelectors[j].match(/\\)/g) || []).length;\n          const nextUnbalancedParens = nextClosingParensCount - nextOpeningParensCount;\n          if (nextUnbalancedParens === unbalancedParens) {\n            finalSelectors.push(splitSelectors.slice(i2, j + 1).join(\",\"));\n            i2 = j + 1;\n            foundClosingSelector = true;\n            break;\n          }\n          j++;\n          unbalancedParens -= nextUnbalancedParens;\n        }\n        if (foundClosingSelector) {\n          continue;\n        }\n        splitSelectors.slice(i2, len).forEach((selector2) => selector2 && finalSelectors.push(selector2));\n        break;\n      }\n      splitSelectors[i2] && finalSelectors.push(splitSelectors[i2]);\n      i2++;\n    }\n    return finalSelectors.map((s2) => {\n      return s2.replace(/\\u200C/g, \",\");\n    });\n  }\n  function declaration() {\n    const pos = position();\n    const propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n    const ret = pos({\n      type: \"declaration\",\n      property: prop.replace(commentre, \"\"),\n      value: val ? trim(val[0]).replace(commentre, \"\") : \"\"\n    });\n    match(/^[;\\s]*/);\n    return ret;\n  }\n  function declarations() {\n    const decls = [];\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n    let decl;\n    while (decl = declaration()) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n    while (m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/)) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n    if (!vals.length) {\n      return;\n    }\n    return pos({\n      type: \"keyframe\",\n      values: vals,\n      declarations: declarations()\n    });\n  }\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error(\"@keyframes missing name\");\n    }\n    const name = m[1];\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n    let frame;\n    let frames = comments();\n    while (frame = keyframe()) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n    return pos({\n      type: \"keyframes\",\n      name,\n      vendor,\n      keyframes: frames\n    });\n  }\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n    return pos({\n      type: \"supports\",\n      supports,\n      rules: style\n    });\n  }\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n    if (!m) {\n      return;\n    }\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n    return pos({\n      type: \"host\",\n      rules: style\n    });\n  }\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n    return pos({\n      type: \"media\",\n      media,\n      rules: style\n    });\n  }\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n    return pos({\n      type: \"custom-media\",\n      name: trim(m[1]),\n      media: trim(m[2])\n    });\n  }\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n    const sel = selector() || [];\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n    let decl;\n    while (decl = declaration()) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n    return pos({\n      type: \"page\",\n      selectors: sel,\n      declarations: decls\n    });\n  }\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n    return pos({\n      type: \"document\",\n      document: doc,\n      vendor,\n      rules: style\n    });\n  }\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n    let decl;\n    while (decl = declaration()) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n    return pos({\n      type: \"font-face\",\n      declarations: decls\n    });\n  }\n  const atimport = _compileAtrule(\"import\");\n  const atcharset = _compileAtrule(\"charset\");\n  const atnamespace = _compileAtrule(\"namespace\");\n  function _compileAtrule(name) {\n    const re = new RegExp(\n      \"^@\" + name + \"\\\\s*((?:\" + [\n        /[^\\\\]\"(?:\\\\\"|[^\"])*\"/.source,\n        // consume any quoted parts (checking that the double quote isn't itself escaped)\n        /[^\\\\]'(?:\\\\'|[^'])*'/.source,\n        // same but for single quotes\n        \"[^;]\"\n      ].join(\"|\") + \")+);\"\n    );\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n  function atrule() {\n    if (css[0] !== \"@\") {\n      return;\n    }\n    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();\n  }\n  function rule() {\n    const pos = position();\n    const sel = selector();\n    if (!sel) {\n      return error(\"selector missing\");\n    }\n    comments();\n    return pos({\n      type: \"rule\",\n      selectors: sel,\n      declarations: declarations()\n    });\n  }\n  return addParent(stylesheet());\n}\nfunction trim(str) {\n  return str ? str.replace(/^\\s+|\\s+$/g, \"\") : \"\";\n}\nfunction addParent(obj, parent) {\n  const isNode = obj && typeof obj.type === \"string\";\n  const childParent = isNode ? obj : parent;\n  for (const k of Object.keys(obj)) {\n    const value = obj[k];\n    if (Array.isArray(value)) {\n      value.forEach((v2) => {\n        addParent(v2, childParent);\n      });\n    } else if (value && typeof value === \"object\") {\n      addParent(value, childParent);\n    }\n  }\n  if (isNode) {\n    Object.defineProperty(obj, \"parent\", {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null\n    });\n  }\n  return obj;\n}\nconst tagMap = {\n  script: \"noscript\",\n  // camel case svg element tag names\n  altglyph: \"altGlyph\",\n  altglyphdef: \"altGlyphDef\",\n  altglyphitem: \"altGlyphItem\",\n  animatecolor: \"animateColor\",\n  animatemotion: \"animateMotion\",\n  animatetransform: \"animateTransform\",\n  clippath: \"clipPath\",\n  feblend: \"feBlend\",\n  fecolormatrix: \"feColorMatrix\",\n  fecomponenttransfer: \"feComponentTransfer\",\n  fecomposite: \"feComposite\",\n  feconvolvematrix: \"feConvolveMatrix\",\n  fediffuselighting: \"feDiffuseLighting\",\n  fedisplacementmap: \"feDisplacementMap\",\n  fedistantlight: \"feDistantLight\",\n  fedropshadow: \"feDropShadow\",\n  feflood: \"feFlood\",\n  fefunca: \"feFuncA\",\n  fefuncb: \"feFuncB\",\n  fefuncg: \"feFuncG\",\n  fefuncr: \"feFuncR\",\n  fegaussianblur: \"feGaussianBlur\",\n  feimage: \"feImage\",\n  femerge: \"feMerge\",\n  femergenode: \"feMergeNode\",\n  femorphology: \"feMorphology\",\n  feoffset: \"feOffset\",\n  fepointlight: \"fePointLight\",\n  fespecularlighting: \"feSpecularLighting\",\n  fespotlight: \"feSpotLight\",\n  fetile: \"feTile\",\n  feturbulence: \"feTurbulence\",\n  foreignobject: \"foreignObject\",\n  glyphref: \"glyphRef\",\n  lineargradient: \"linearGradient\",\n  radialgradient: \"radialGradient\"\n};\nfunction getTagName(n2) {\n  let tagName = tagMap[n2.tagName] ? tagMap[n2.tagName] : n2.tagName;\n  if (tagName === \"link\" && n2.attributes._cssText) {\n    tagName = \"style\";\n  }\n  return tagName;\n}\nfunction escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, \"g\");\nfunction addHoverClass(cssText, cache) {\n  const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n  if (cssText.length >= 1e6) {\n    return cssText;\n  }\n  const ast = parse(cssText, {\n    silent: true\n  });\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n  const selectors = [];\n  ast.stylesheet.rules.forEach((rule) => {\n    if (\"selectors\" in rule) {\n      (rule.selectors || []).forEach((selector) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n  });\n  if (selectors.length === 0) {\n    return cssText;\n  }\n  const selectorMatcher = new RegExp(\n    selectors.filter((selector, index) => selectors.indexOf(selector) === index).sort((a2, b) => b.length - a2.length).map((selector) => {\n      return escapeRegExp(selector);\n    }).join(\"|\"),\n    \"g\"\n  );\n  const result = cssText.replace(selectorMatcher, (selector) => {\n    const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, \"$1.\\\\:hover\");\n    return `${selector}, ${newSelector}`;\n  });\n  cache?.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\nfunction createCache() {\n  const stylesWithHoverClass = /* @__PURE__ */ new Map();\n  return {\n    stylesWithHoverClass\n  };\n}\nfunction buildNode(n2, options) {\n  const { doc, hackCss, cache } = options;\n  switch (n2.type) {\n    case NodeType$2.Document:\n      return doc.implementation.createDocument(null, \"\", null);\n    case NodeType$2.DocumentType:\n      return doc.implementation.createDocumentType(\n        n2.name || \"html\",\n        n2.publicId,\n        n2.systemId\n      );\n    case NodeType$2.Element: {\n      const tagName = getTagName(n2);\n      let node;\n      if (n2.isSVG) {\n        node = doc.createElementNS(\"http://www.w3.org/2000/svg\", tagName);\n      } else {\n        if (\n          // If the tag name is a custom element name\n          n2.isCustom && // If the browser supports custom elements\n          doc.defaultView?.customElements && // If the custom element hasn't been defined yet\n          !doc.defaultView.customElements.get(n2.tagName)\n        )\n          doc.defaultView.customElements.define(\n            n2.tagName,\n            class extends doc.defaultView.HTMLElement {\n            }\n          );\n        node = doc.createElement(tagName);\n      }\n      const specialAttributes = {};\n      for (const name in n2.attributes) {\n        if (!Object.prototype.hasOwnProperty.call(n2.attributes, name)) {\n          continue;\n        }\n        let value = n2.attributes[name];\n        if (tagName === \"option\" && name === \"selected\" && value === false) {\n          continue;\n        }\n        if (value === null) {\n          continue;\n        }\n        if (value === true) value = \"\";\n        if (name.startsWith(\"rr_\")) {\n          specialAttributes[name] = value;\n          continue;\n        }\n        const isTextarea = tagName === \"textarea\" && name === \"value\";\n        const isRemoteOrDynamicCss = tagName === \"style\" && name === \"_cssText\";\n        if (isRemoteOrDynamicCss && hackCss && typeof value === \"string\") {\n          value = addHoverClass(value, cache);\n        }\n        if ((isTextarea || isRemoteOrDynamicCss) && typeof value === \"string\") {\n          const child = doc.createTextNode(value);\n          for (const c2 of Array.from(node.childNodes)) {\n            if (c2.nodeType === node.TEXT_NODE) {\n              node.removeChild(c2);\n            }\n          }\n          node.appendChild(child);\n          continue;\n        }\n        try {\n          if (n2.isSVG && name === \"xlink:href\") {\n            node.setAttributeNS(\n              \"http://www.w3.org/1999/xlink\",\n              name,\n              value.toString()\n            );\n          } else if (name === \"onload\" || name === \"onclick\" || name.substring(0, 7) === \"onmouse\") {\n            node.setAttribute(\"_\" + name, value.toString());\n          } else if (tagName === \"meta\" && n2.attributes[\"http-equiv\"] === \"Content-Security-Policy\" && name === \"content\") {\n            node.setAttribute(\"csp-content\", value.toString());\n            continue;\n          } else if (tagName === \"link\" && (n2.attributes.rel === \"preload\" || n2.attributes.rel === \"modulepreload\")) {\n          } else if (tagName === \"link\" && n2.attributes.rel === \"prefetch\" && typeof n2.attributes.href === \"string\" && extractFileExtension(n2.attributes.href) === \"js\") {\n          } else if (tagName === \"img\" && n2.attributes.srcset && n2.attributes.rr_dataURL) {\n            node.setAttribute(\n              \"rrweb-original-srcset\",\n              n2.attributes.srcset\n            );\n          } else {\n            node.setAttribute(name, value.toString());\n          }\n        } catch (error) {\n        }\n      }\n      for (const name in specialAttributes) {\n        const value = specialAttributes[name];\n        if (tagName === \"canvas\" && name === \"rr_dataURL\") {\n          const image = doc.createElement(\"img\");\n          image.onload = () => {\n            const ctx = node.getContext(\"2d\");\n            if (ctx) {\n              ctx.drawImage(image, 0, 0, image.width, image.height);\n            }\n          };\n          image.src = value.toString();\n          if (node.RRNodeType)\n            node.rr_dataURL = value.toString();\n        } else if (tagName === \"img\" && name === \"rr_dataURL\") {\n          const image = node;\n          if (!image.currentSrc.startsWith(\"data:\")) {\n            image.setAttribute(\n              \"rrweb-original-src\",\n              n2.attributes.src\n            );\n            image.src = value.toString();\n          }\n        }\n        if (name === \"rr_width\") {\n          node.style.setProperty(\"width\", value.toString());\n        } else if (name === \"rr_height\") {\n          node.style.setProperty(\"height\", value.toString());\n        } else if (name === \"rr_mediaCurrentTime\" && typeof value === \"number\") {\n          node.currentTime = value;\n        } else if (name === \"rr_mediaState\") {\n          switch (value) {\n            case \"played\":\n              node.play().catch((e2) => console.warn(\"media playback error\", e2));\n              break;\n            case \"paused\":\n              node.pause();\n              break;\n          }\n        }\n      }\n      if (n2.isShadowHost) {\n        if (!node.shadowRoot) {\n          node.attachShadow({ mode: \"open\" });\n        } else {\n          while (node.shadowRoot.firstChild) {\n            node.shadowRoot.removeChild(node.shadowRoot.firstChild);\n          }\n        }\n      }\n      return node;\n    }\n    case NodeType$2.Text:\n      return doc.createTextNode(\n        n2.isStyle && hackCss ? addHoverClass(n2.textContent, cache) : n2.textContent\n      );\n    case NodeType$2.CDATA:\n      if (!(doc instanceof XMLDocument)) {\n        return null;\n      }\n      return doc.createCDATASection(n2.textContent);\n    case NodeType$2.Comment:\n      return doc.createComment(n2.textContent);\n    default:\n      return null;\n  }\n}\nfunction buildNodeWithSN(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    skipChild = false,\n    hackCss = true,\n    afterAppend,\n    cache\n  } = options;\n  if (mirror2.has(n2.id)) {\n    const nodeInMirror = mirror2.getNode(n2.id);\n    const meta = mirror2.getMeta(nodeInMirror);\n    if (isNodeMetaEqual(meta, n2)) return mirror2.getNode(n2.id);\n  }\n  let node = buildNode(n2, { doc, hackCss, cache });\n  if (!node) {\n    return null;\n  }\n  if (n2.rootId && mirror2.getNode(n2.rootId) !== doc) {\n    mirror2.replace(n2.rootId, doc);\n  }\n  if (n2.type === NodeType$2.Document) {\n    doc.close();\n    doc.open();\n    if (n2.compatMode === \"BackCompat\" && n2.childNodes && n2.childNodes[0].type !== NodeType$2.DocumentType) {\n      if (n2.childNodes[0].type === NodeType$2.Element && \"xmlns\" in n2.childNodes[0].attributes && n2.childNodes[0].attributes.xmlns === \"http://www.w3.org/1999/xhtml\") {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">'\n        );\n      } else {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">'\n        );\n      }\n    }\n    node = doc;\n  }\n  mirror2.add(node, n2);\n  if ((n2.type === NodeType$2.Document || n2.type === NodeType$2.Element) && !skipChild) {\n    for (const childN of n2.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        mirror: mirror2,\n        skipChild: false,\n        hackCss,\n        afterAppend,\n        cache\n      });\n      if (!childNode) {\n        console.warn(\"Failed to rebuild\", childN);\n        continue;\n      }\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else if (n2.type === NodeType$2.Document && childN.type == NodeType$2.Element) {\n        const htmlElement = childNode;\n        let body = null;\n        htmlElement.childNodes.forEach((child) => {\n          if (child.nodeName === \"BODY\") body = child;\n        });\n        if (body) {\n          htmlElement.removeChild(body);\n          node.appendChild(childNode);\n          htmlElement.appendChild(body);\n        } else {\n          node.appendChild(childNode);\n        }\n      } else {\n        node.appendChild(childNode);\n      }\n      if (afterAppend) {\n        afterAppend(childNode, childN.id);\n      }\n    }\n  }\n  return node;\n}\nfunction visit(mirror2, onVisit) {\n  function walk(node) {\n    onVisit(node);\n  }\n  for (const id of mirror2.getIds()) {\n    if (mirror2.has(id)) {\n      walk(mirror2.getNode(id));\n    }\n  }\n}\nfunction handleScroll(node, mirror2) {\n  const n2 = mirror2.getMeta(node);\n  if (n2?.type !== NodeType$2.Element) {\n    return;\n  }\n  const el = node;\n  for (const name in n2.attributes) {\n    if (!(Object.prototype.hasOwnProperty.call(n2.attributes, name) && name.startsWith(\"rr_\"))) {\n      continue;\n    }\n    const value = n2.attributes[name];\n    if (name === \"rr_scrollLeft\") {\n      el.scrollLeft = value;\n    }\n    if (name === \"rr_scrollTop\") {\n      el.scrollTop = value;\n    }\n  }\n}\nfunction rebuild(n2, options) {\n  const {\n    doc,\n    onVisit,\n    hackCss = true,\n    afterAppend,\n    cache,\n    mirror: mirror2 = new Mirror()\n  } = options;\n  const node = buildNodeWithSN(n2, {\n    doc,\n    mirror: mirror2,\n    skipChild: false,\n    hackCss,\n    afterAppend,\n    cache\n  });\n  visit(mirror2, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode, mirror2);\n  });\n  return node;\n}\nfunction on(type, fn, target = document) {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\nlet _mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\nif (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === \"map\") {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction throttle(func, wait, options = {}) {\n  let timeout = null;\n  let previous = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    const context = this;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout$1(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\nfunction hookSetter(target, key, d, isRevoked, win = window) {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked ? d : {\n      set(value) {\n        setTimeout$1(() => {\n          d.set.call(this, value);\n        }, 0);\n        if (original && original.set) {\n          original.set.call(this, value);\n        }\n      }\n    }\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {\n      };\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === \"function\") {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {\n    };\n  }\n}\nlet nowTimestamp = Date.now;\nif (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {\n  nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();\n}\nfunction getWindowScroll(win) {\n  const doc = win.document;\n  return {\n    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc?.documentElement.scrollLeft || doc?.body?.parentElement?.scrollLeft || doc?.body?.scrollLeft || 0,\n    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : doc?.documentElement.scrollTop || doc?.body?.parentElement?.scrollTop || doc?.body?.scrollTop || 0\n  };\n}\nfunction getWindowHeight() {\n  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node) {\n  if (!node) {\n    return null;\n  }\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    return el;\n  } catch (error) {\n    return null;\n  }\n}\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\n  if (!node) {\n    return false;\n  }\n  const el = closestElementOfNode(node);\n  if (!el) {\n    return false;\n  }\n  const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\n  if (!checkAncestors) {\n    const isUnblocked = unblockSelector && el.matches(unblockSelector);\n    return blockedPredicate(el) && !isUnblocked;\n  }\n  const blockDistance = distanceToMatch(el, blockedPredicate);\n  let unblockDistance = -1;\n  if (blockDistance < 0) {\n    return false;\n  }\n  if (unblockSelector) {\n    unblockDistance = distanceToMatch(\n      el,\n      createMatchPredicate(null, unblockSelector)\n    );\n  }\n  if (blockDistance > -1 && unblockDistance < 0) {\n    return true;\n  }\n  return blockDistance < unblockDistance;\n}\nfunction isSerialized(n2, mirror2) {\n  return mirror2.getId(n2) !== -1;\n}\nfunction isIgnored(n2, mirror2) {\n  return mirror2.getId(n2) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror2) {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror2.getId(target);\n  if (!mirror2.has(id)) {\n    return true;\n  }\n  if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n    return false;\n  }\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved(target.parentNode, mirror2);\n}\nfunction legacy_isTouchEvent(event) {\n  return Boolean(event.changedTouches);\n}\nfunction polyfill$1(win = window) {\n  if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = (...args) => {\n      let node = args[0];\n      if (!(0 in args)) {\n        throw new TypeError(\"1 argument is required\");\n      }\n      do {\n        if (this === node) {\n          return true;\n        }\n      } while (node = node && node.parentNode);\n      return false;\n    };\n  }\n}\nfunction queueToResolveTrees(queue) {\n  const queueNodeMap = {};\n  const putIntoMap = (m, parent) => {\n    const nodeInTree = {\n      value: m,\n      parent,\n      children: []\n    };\n    queueNodeMap[m.node.id] = nodeInTree;\n    return nodeInTree;\n  };\n  const queueNodeTrees = [];\n  for (const mutation of queue) {\n    const { nextId, parentId } = mutation;\n    if (nextId && nextId in queueNodeMap) {\n      const nextInTree = queueNodeMap[nextId];\n      if (nextInTree.parent) {\n        const idx = nextInTree.parent.children.indexOf(nextInTree);\n        nextInTree.parent.children.splice(\n          idx,\n          0,\n          putIntoMap(mutation, nextInTree.parent)\n        );\n      } else {\n        const idx = queueNodeTrees.indexOf(nextInTree);\n        queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\n      }\n      continue;\n    }\n    if (parentId in queueNodeMap) {\n      const parentInTree = queueNodeMap[parentId];\n      parentInTree.children.push(putIntoMap(mutation, parentInTree));\n      continue;\n    }\n    queueNodeTrees.push(putIntoMap(mutation, null));\n  }\n  return queueNodeTrees;\n}\nfunction iterateResolveTree(tree, cb) {\n  cb(tree.value);\n  for (let i2 = tree.children.length - 1; i2 >= 0; i2--) {\n    iterateResolveTree(tree.children[i2], cb);\n  }\n}\nfunction isSerializedIframe(n2, mirror2) {\n  return Boolean(n2.nodeName === \"IFRAME\" && mirror2.getMeta(n2));\n}\nfunction isSerializedStylesheet(n2, mirror2) {\n  return Boolean(\n    n2.nodeName === \"LINK\" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute(\"rel\") === \"stylesheet\" && mirror2.getMeta(n2)\n  );\n}\nfunction getBaseDimension(node, rootIframe) {\n  const frameElement = node.ownerDocument?.defaultView?.frameElement;\n  if (!frameElement || frameElement === rootIframe) {\n    return {\n      x: 0,\n      y: 0,\n      relativeScale: 1,\n      absoluteScale: 1\n    };\n  }\n  const frameDimension = frameElement.getBoundingClientRect();\n  const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\n  const relativeScale = frameDimension.height / frameElement.clientHeight;\n  return {\n    x: frameDimension.x * frameBaseDimension.relativeScale + frameBaseDimension.x,\n    y: frameDimension.y * frameBaseDimension.relativeScale + frameBaseDimension.y,\n    relativeScale,\n    absoluteScale: frameBaseDimension.absoluteScale * relativeScale\n  };\n}\nfunction hasShadowRoot(n2) {\n  return Boolean(n2?.shadowRoot);\n}\nfunction getNestedRule(rules2, position) {\n  const rule = rules2[position[0]];\n  if (position.length === 1) {\n    return rule;\n  } else {\n    return getNestedRule(\n      rule.cssRules[position[1]].cssRules,\n      position.slice(2)\n    );\n  }\n}\nfunction getPositionsAndIndex(nestedIndex) {\n  const positions = [...nestedIndex];\n  const index = positions.pop();\n  return { positions, index };\n}\nfunction uniqueTextMutations(mutations) {\n  const idSet = /* @__PURE__ */ new Set();\n  const uniqueMutations = [];\n  for (let i2 = mutations.length; i2--; ) {\n    const mutation = mutations[i2];\n    if (!idSet.has(mutation.id)) {\n      uniqueMutations.push(mutation);\n      idSet.add(mutation.id);\n    }\n  }\n  return uniqueMutations;\n}\nclass StyleSheetMirror {\n  constructor() {\n    this.id = 1;\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n  }\n  getId(stylesheet) {\n    return this.styleIDMap.get(stylesheet) ?? -1;\n  }\n  has(stylesheet) {\n    return this.styleIDMap.has(stylesheet);\n  }\n  /**\n   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.\n   */\n  add(stylesheet, id) {\n    if (this.has(stylesheet)) return this.getId(stylesheet);\n    let newId;\n    if (id === void 0) {\n      newId = this.id++;\n    } else newId = id;\n    this.styleIDMap.set(stylesheet, newId);\n    this.idStyleMap.set(newId, stylesheet);\n    return newId;\n  }\n  getStyle(id) {\n    return this.idStyleMap.get(id) || null;\n  }\n  reset() {\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n    this.id = 1;\n  }\n  generateId() {\n    return this.id++;\n  }\n}\nfunction getShadowHost(n2) {\n  let shadowHost = null;\n  if (n2.getRootNode?.()?.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n2.getRootNode().host)\n    shadowHost = n2.getRootNode().host;\n  return shadowHost;\n}\nfunction getRootShadowHost(n2) {\n  let rootShadowHost = n2;\n  let shadowHost;\n  while (shadowHost = getShadowHost(rootShadowHost))\n    rootShadowHost = shadowHost;\n  return rootShadowHost;\n}\nfunction shadowHostInDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  const shadowHost = getRootShadowHost(n2);\n  return doc.contains(shadowHost);\n}\nfunction inDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  return doc.contains(n2) || shadowHostInDom(n2);\n}\nconst cachedImplementations = {};\nfunction getImplementation(name) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations[name] = impl.bind(\n    window\n  );\n}\nfunction onRequestAnimationFrame(...rest) {\n  return getImplementation(\"requestAnimationFrame\")(...rest);\n}\nfunction setTimeout$1(...rest) {\n  return getImplementation(\"setTimeout\")(...rest);\n}\nfunction clearTimeout(...rest) {\n  return getImplementation(\"clearTimeout\")(...rest);\n}\nconst utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  StyleSheetMirror,\n  get _mirror() {\n    return _mirror;\n  },\n  clearTimeout,\n  closestElementOfNode,\n  getBaseDimension,\n  getNestedRule,\n  getPositionsAndIndex,\n  getRootShadowHost,\n  getShadowHost,\n  getWindowHeight,\n  getWindowScroll,\n  getWindowWidth,\n  hasShadowRoot,\n  hookSetter,\n  inDom,\n  isAncestorRemoved,\n  isBlocked,\n  isIgnored,\n  isSerialized,\n  isSerializedIframe,\n  isSerializedStylesheet,\n  iterateResolveTree,\n  legacy_isTouchEvent,\n  get nowTimestamp() {\n    return nowTimestamp;\n  },\n  on,\n  onRequestAnimationFrame,\n  patch,\n  polyfill: polyfill$1,\n  queueToResolveTrees,\n  setTimeout: setTimeout$1,\n  shadowHostInDom,\n  throttle,\n  uniqueTextMutations\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {\n  CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n  CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n  return CanvasContext2;\n})(CanvasContext || {});\nvar MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {\n  MediaInteractions2[MediaInteractions2[\"Play\"] = 0] = \"Play\";\n  MediaInteractions2[MediaInteractions2[\"Pause\"] = 1] = \"Pause\";\n  MediaInteractions2[MediaInteractions2[\"Seeked\"] = 2] = \"Seeked\";\n  MediaInteractions2[MediaInteractions2[\"VolumeChange\"] = 3] = \"VolumeChange\";\n  MediaInteractions2[MediaInteractions2[\"RateChange\"] = 4] = \"RateChange\";\n  return MediaInteractions2;\n})(MediaInteractions || {});\nvar ReplayerEvents = /* @__PURE__ */ ((ReplayerEvents2) => {\n  ReplayerEvents2[\"Start\"] = \"start\";\n  ReplayerEvents2[\"Pause\"] = \"pause\";\n  ReplayerEvents2[\"Resume\"] = \"resume\";\n  ReplayerEvents2[\"Resize\"] = \"resize\";\n  ReplayerEvents2[\"Finish\"] = \"finish\";\n  ReplayerEvents2[\"FullsnapshotRebuilded\"] = \"fullsnapshot-rebuilded\";\n  ReplayerEvents2[\"LoadStylesheetStart\"] = \"load-stylesheet-start\";\n  ReplayerEvents2[\"LoadStylesheetEnd\"] = \"load-stylesheet-end\";\n  ReplayerEvents2[\"SkipStart\"] = \"skip-start\";\n  ReplayerEvents2[\"SkipEnd\"] = \"skip-end\";\n  ReplayerEvents2[\"MouseInteraction\"] = \"mouse-interaction\";\n  ReplayerEvents2[\"EventCast\"] = \"event-cast\";\n  ReplayerEvents2[\"CustomEvent\"] = \"custom-event\";\n  ReplayerEvents2[\"Flush\"] = \"flush\";\n  ReplayerEvents2[\"StateChange\"] = \"state-change\";\n  ReplayerEvents2[\"PlayBack\"] = \"play-back\";\n  ReplayerEvents2[\"Destroy\"] = \"destroy\";\n  return ReplayerEvents2;\n})(ReplayerEvents || {});\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar __defProp2 = Object.defineProperty;\nvar __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar NodeType$1 = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType$1 || {});\nlet Mirror$1 = class Mirror2 {\n  constructor() {\n    __publicField2(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField2(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach(\n        (childNode) => this.removeNodeFromMap(childNode)\n      );\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n};\nfunction createMirror$1() {\n  return new Mirror$1();\n}\nfunction parseCSSText(cssText) {\n  const res = {};\n  const listDelimiter = /;(?![^(]*\\))/g;\n  const propertyDelimiter = /:(.+)/;\n  const comment = /\\/\\*.*?\\*\\//g;\n  cssText.replace(comment, \"\").split(listDelimiter).forEach(function(item) {\n    if (item) {\n      const tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[camelize(tmp[0].trim())] = tmp[1].trim());\n    }\n  });\n  return res;\n}\nfunction toCSSText(style) {\n  const properties = [];\n  for (const name in style) {\n    const value = style[name];\n    if (typeof value !== \"string\") continue;\n    const normalizedName = hyphenate(name);\n    properties.push(`${normalizedName}: ${value};`);\n  }\n  return properties.join(\" \");\n}\nconst camelizeRE = /-([a-z])/g;\nconst CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9-]+$/;\nconst camelize = (str) => {\n  if (CUSTOM_PROPERTY_REGEX.test(str)) return str;\n  return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : \"\");\n};\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = (str) => {\n  return str.replace(hyphenateRE, \"-$1\").toLowerCase();\n};\nclass BaseRRNode {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any\n  constructor(..._args) {\n    __publicField(this, \"parentElement\", null);\n    __publicField(this, \"parentNode\", null);\n    __publicField(this, \"ownerDocument\");\n    __publicField(this, \"firstChild\", null);\n    __publicField(this, \"lastChild\", null);\n    __publicField(this, \"previousSibling\", null);\n    __publicField(this, \"nextSibling\", null);\n    __publicField(this, \"ELEMENT_NODE\", 1);\n    __publicField(this, \"TEXT_NODE\", 3);\n    __publicField(this, \"nodeType\");\n    __publicField(this, \"nodeName\");\n    __publicField(this, \"RRNodeType\");\n  }\n  get childNodes() {\n    const childNodes = [];\n    let childIterator = this.firstChild;\n    while (childIterator) {\n      childNodes.push(childIterator);\n      childIterator = childIterator.nextSibling;\n    }\n    return childNodes;\n  }\n  contains(node) {\n    if (!(node instanceof BaseRRNode)) return false;\n    else if (node.ownerDocument !== this.ownerDocument) return false;\n    else if (node === this) return true;\n    while (node.parentNode) {\n      if (node.parentNode === this) return true;\n      node = node.parentNode;\n    }\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  appendChild(_newChild) {\n    throw new Error(\n      `RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.`\n    );\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  insertBefore(_newChild, _refChild) {\n    throw new Error(\n      `RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.`\n    );\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  removeChild(_node) {\n    throw new Error(\n      `RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.`\n    );\n  }\n  toString() {\n    return \"RRNode\";\n  }\n}\nclass BaseRRDocument extends BaseRRNode {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(...args) {\n    super(args);\n    __publicField(this, \"nodeType\", 9);\n    __publicField(this, \"nodeName\", \"#document\");\n    __publicField(this, \"compatMode\", \"CSS1Compat\");\n    __publicField(this, \"RRNodeType\", NodeType$1.Document);\n    __publicField(this, \"textContent\", null);\n    this.ownerDocument = this;\n  }\n  get documentElement() {\n    return this.childNodes.find(\n      (node) => node.RRNodeType === NodeType$1.Element && node.tagName === \"HTML\"\n    ) || null;\n  }\n  get body() {\n    return this.documentElement?.childNodes.find(\n      (node) => node.RRNodeType === NodeType$1.Element && node.tagName === \"BODY\"\n    ) || null;\n  }\n  get head() {\n    return this.documentElement?.childNodes.find(\n      (node) => node.RRNodeType === NodeType$1.Element && node.tagName === \"HEAD\"\n    ) || null;\n  }\n  get implementation() {\n    return this;\n  }\n  get firstElementChild() {\n    return this.documentElement;\n  }\n  appendChild(newChild) {\n    const nodeType = newChild.RRNodeType;\n    if (nodeType === NodeType$1.Element || nodeType === NodeType$1.DocumentType) {\n      if (this.childNodes.some((s2) => s2.RRNodeType === nodeType)) {\n        throw new Error(\n          `RRDomException: Failed to execute 'appendChild' on 'RRNode': Only one ${nodeType === NodeType$1.Element ? \"RRElement\" : \"RRDoctype\"} on RRDocument allowed.`\n        );\n      }\n    }\n    const child = appendChild(this, newChild);\n    child.parentElement = null;\n    return child;\n  }\n  insertBefore(newChild, refChild) {\n    const nodeType = newChild.RRNodeType;\n    if (nodeType === NodeType$1.Element || nodeType === NodeType$1.DocumentType) {\n      if (this.childNodes.some((s2) => s2.RRNodeType === nodeType)) {\n        throw new Error(\n          `RRDomException: Failed to execute 'insertBefore' on 'RRNode': Only one ${nodeType === NodeType$1.Element ? \"RRElement\" : \"RRDoctype\"} on RRDocument allowed.`\n        );\n      }\n    }\n    const child = insertBefore(this, newChild, refChild);\n    child.parentElement = null;\n    return child;\n  }\n  removeChild(node) {\n    return removeChild(this, node);\n  }\n  open() {\n    this.firstChild = null;\n    this.lastChild = null;\n  }\n  close() {\n  }\n  /**\n   * Adhoc implementation for setting xhtml namespace in rebuilt.ts (rrweb-snapshot).\n   * There are two lines used this function:\n   * 1. doc.write('\\<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\"\\>')\n   * 2. doc.write('\\<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\"\\>')\n   */\n  write(content) {\n    let publicId;\n    if (content === '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">')\n      publicId = \"-//W3C//DTD XHTML 1.0 Transitional//EN\";\n    else if (content === '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">')\n      publicId = \"-//W3C//DTD HTML 4.0 Transitional//EN\";\n    if (publicId) {\n      const doctype = this.createDocumentType(\"html\", publicId, \"\");\n      this.open();\n      this.appendChild(doctype);\n    }\n  }\n  createDocument(_namespace, _qualifiedName, _doctype) {\n    return new BaseRRDocument();\n  }\n  createDocumentType(qualifiedName, publicId, systemId) {\n    const doctype = new BaseRRDocumentType(qualifiedName, publicId, systemId);\n    doctype.ownerDocument = this;\n    return doctype;\n  }\n  createElement(tagName) {\n    const element = new BaseRRElement(tagName);\n    element.ownerDocument = this;\n    return element;\n  }\n  createElementNS(_namespaceURI, qualifiedName) {\n    return this.createElement(qualifiedName);\n  }\n  createTextNode(data) {\n    const text = new BaseRRText(data);\n    text.ownerDocument = this;\n    return text;\n  }\n  createComment(data) {\n    const comment = new BaseRRComment(data);\n    comment.ownerDocument = this;\n    return comment;\n  }\n  createCDATASection(data) {\n    const CDATASection = new BaseRRCDATASection(data);\n    CDATASection.ownerDocument = this;\n    return CDATASection;\n  }\n  toString() {\n    return \"RRDocument\";\n  }\n}\nclass BaseRRDocumentType extends BaseRRNode {\n  constructor(qualifiedName, publicId, systemId) {\n    super();\n    __publicField(this, \"nodeType\", 10);\n    __publicField(this, \"RRNodeType\", NodeType$1.DocumentType);\n    __publicField(this, \"name\");\n    __publicField(this, \"publicId\");\n    __publicField(this, \"systemId\");\n    __publicField(this, \"textContent\", null);\n    this.name = qualifiedName;\n    this.publicId = publicId;\n    this.systemId = systemId;\n    this.nodeName = qualifiedName;\n  }\n  toString() {\n    return \"RRDocumentType\";\n  }\n}\nclass BaseRRElement extends BaseRRNode {\n  constructor(tagName) {\n    super();\n    __publicField(this, \"nodeType\", 1);\n    __publicField(this, \"RRNodeType\", NodeType$1.Element);\n    __publicField(this, \"tagName\");\n    __publicField(this, \"attributes\", {});\n    __publicField(this, \"shadowRoot\", null);\n    __publicField(this, \"scrollLeft\");\n    __publicField(this, \"scrollTop\");\n    this.tagName = tagName.toUpperCase();\n    this.nodeName = tagName.toUpperCase();\n  }\n  get textContent() {\n    let result = \"\";\n    this.childNodes.forEach((node) => result += node.textContent);\n    return result;\n  }\n  set textContent(textContent) {\n    this.firstChild = null;\n    this.lastChild = null;\n    this.appendChild(this.ownerDocument.createTextNode(textContent));\n  }\n  get classList() {\n    return new ClassList(\n      this.attributes.class,\n      (newClassName) => {\n        this.attributes.class = newClassName;\n      }\n    );\n  }\n  get id() {\n    return this.attributes.id || \"\";\n  }\n  get className() {\n    return this.attributes.class || \"\";\n  }\n  get style() {\n    const style = this.attributes.style ? parseCSSText(this.attributes.style) : {};\n    const hyphenateRE2 = /\\B([A-Z])/g;\n    style.setProperty = (name, value, priority) => {\n      if (hyphenateRE2.test(name)) return;\n      const normalizedName = camelize(name);\n      if (!value) delete style[normalizedName];\n      else style[normalizedName] = value;\n      if (priority === \"important\") style[normalizedName] += \" !important\";\n      this.attributes.style = toCSSText(style);\n    };\n    style.removeProperty = (name) => {\n      if (hyphenateRE2.test(name)) return \"\";\n      const normalizedName = camelize(name);\n      const value = style[normalizedName] || \"\";\n      delete style[normalizedName];\n      this.attributes.style = toCSSText(style);\n      return value;\n    };\n    return style;\n  }\n  getAttribute(name) {\n    return this.attributes[name] || null;\n  }\n  setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n  }\n  setAttributeNS(_namespace, qualifiedName, value) {\n    this.setAttribute(qualifiedName, value);\n  }\n  removeAttribute(name) {\n    delete this.attributes[name];\n  }\n  appendChild(newChild) {\n    return appendChild(this, newChild);\n  }\n  insertBefore(newChild, refChild) {\n    return insertBefore(this, newChild, refChild);\n  }\n  removeChild(node) {\n    return removeChild(this, node);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attachShadow(_init) {\n    const shadowRoot = this.ownerDocument.createElement(\"SHADOWROOT\");\n    this.shadowRoot = shadowRoot;\n    return shadowRoot;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  dispatchEvent(_event) {\n    return true;\n  }\n  toString() {\n    let attributeString = \"\";\n    for (const attribute in this.attributes) {\n      attributeString += `${attribute}=\"${this.attributes[attribute]}\" `;\n    }\n    return `${this.tagName} ${attributeString}`;\n  }\n}\nclass BaseRRMediaElement extends BaseRRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"currentTime\");\n    __publicField(this, \"volume\");\n    __publicField(this, \"paused\");\n    __publicField(this, \"muted\");\n    __publicField(this, \"playbackRate\");\n    __publicField(this, \"loop\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attachShadow(_init) {\n    throw new Error(\n      `RRDomException: Failed to execute 'attachShadow' on 'RRElement': This RRElement does not support attachShadow`\n    );\n  }\n  play() {\n    this.paused = false;\n  }\n  pause() {\n    this.paused = true;\n  }\n}\nclass BaseRRText extends BaseRRNode {\n  constructor(data) {\n    super();\n    __publicField(this, \"nodeType\", 3);\n    __publicField(this, \"nodeName\", \"#text\");\n    __publicField(this, \"RRNodeType\", NodeType$1.Text);\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  get textContent() {\n    return this.data;\n  }\n  set textContent(textContent) {\n    this.data = textContent;\n  }\n  toString() {\n    return `RRText text=${JSON.stringify(this.data)}`;\n  }\n}\nclass BaseRRComment extends BaseRRNode {\n  constructor(data) {\n    super();\n    __publicField(this, \"nodeType\", 8);\n    __publicField(this, \"nodeName\", \"#comment\");\n    __publicField(this, \"RRNodeType\", NodeType$1.Comment);\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  get textContent() {\n    return this.data;\n  }\n  set textContent(textContent) {\n    this.data = textContent;\n  }\n  toString() {\n    return `RRComment text=${JSON.stringify(this.data)}`;\n  }\n}\nclass BaseRRCDATASection extends BaseRRNode {\n  constructor(data) {\n    super();\n    __publicField(this, \"nodeName\", \"#cdata-section\");\n    __publicField(this, \"nodeType\", 4);\n    __publicField(this, \"RRNodeType\", NodeType$1.CDATA);\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  get textContent() {\n    return this.data;\n  }\n  set textContent(textContent) {\n    this.data = textContent;\n  }\n  toString() {\n    return `RRCDATASection data=${JSON.stringify(this.data)}`;\n  }\n}\nclass ClassList {\n  constructor(classText, onChange) {\n    __publicField(this, \"onChange\");\n    __publicField(this, \"classes\", []);\n    __publicField(this, \"add\", (...classNames) => {\n      for (const item of classNames) {\n        const className = String(item);\n        if (this.classes.indexOf(className) >= 0) continue;\n        this.classes.push(className);\n      }\n      this.onChange && this.onChange(this.classes.join(\" \"));\n    });\n    __publicField(this, \"remove\", (...classNames) => {\n      this.classes = this.classes.filter(\n        (item) => classNames.indexOf(item) === -1\n      );\n      this.onChange && this.onChange(this.classes.join(\" \"));\n    });\n    if (classText) {\n      const classes = classText.trim().split(/\\s+/);\n      this.classes.push(...classes);\n    }\n    this.onChange = onChange;\n  }\n}\nfunction appendChild(parent, newChild) {\n  if (newChild.parentNode) newChild.parentNode.removeChild(newChild);\n  if (parent.lastChild) {\n    parent.lastChild.nextSibling = newChild;\n    newChild.previousSibling = parent.lastChild;\n  } else {\n    parent.firstChild = newChild;\n    newChild.previousSibling = null;\n  }\n  parent.lastChild = newChild;\n  newChild.nextSibling = null;\n  newChild.parentNode = parent;\n  newChild.parentElement = parent;\n  newChild.ownerDocument = parent.ownerDocument;\n  return newChild;\n}\nfunction insertBefore(parent, newChild, refChild) {\n  if (!refChild) return appendChild(parent, newChild);\n  if (refChild.parentNode !== parent)\n    throw new Error(\n      \"Failed to execute 'insertBefore' on 'RRNode': The RRNode before which the new node is to be inserted is not a child of this RRNode.\"\n    );\n  if (newChild === refChild) return newChild;\n  if (newChild.parentNode) newChild.parentNode.removeChild(newChild);\n  newChild.previousSibling = refChild.previousSibling;\n  refChild.previousSibling = newChild;\n  newChild.nextSibling = refChild;\n  if (newChild.previousSibling) newChild.previousSibling.nextSibling = newChild;\n  else parent.firstChild = newChild;\n  newChild.parentElement = parent;\n  newChild.parentNode = parent;\n  newChild.ownerDocument = parent.ownerDocument;\n  return newChild;\n}\nfunction removeChild(parent, child) {\n  if (child.parentNode !== parent)\n    throw new Error(\n      \"Failed to execute 'removeChild' on 'RRNode': The RRNode to be removed is not a child of this RRNode.\"\n    );\n  if (child.previousSibling)\n    child.previousSibling.nextSibling = child.nextSibling;\n  else parent.firstChild = child.nextSibling;\n  if (child.nextSibling)\n    child.nextSibling.previousSibling = child.previousSibling;\n  else parent.lastChild = child.previousSibling;\n  child.previousSibling = null;\n  child.nextSibling = null;\n  child.parentElement = null;\n  child.parentNode = null;\n  return child;\n}\nvar NodeType = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"PLACEHOLDER\"] = 0] = \"PLACEHOLDER\";\n  NodeType2[NodeType2[\"ELEMENT_NODE\"] = 1] = \"ELEMENT_NODE\";\n  NodeType2[NodeType2[\"ATTRIBUTE_NODE\"] = 2] = \"ATTRIBUTE_NODE\";\n  NodeType2[NodeType2[\"TEXT_NODE\"] = 3] = \"TEXT_NODE\";\n  NodeType2[NodeType2[\"CDATA_SECTION_NODE\"] = 4] = \"CDATA_SECTION_NODE\";\n  NodeType2[NodeType2[\"ENTITY_REFERENCE_NODE\"] = 5] = \"ENTITY_REFERENCE_NODE\";\n  NodeType2[NodeType2[\"ENTITY_NODE\"] = 6] = \"ENTITY_NODE\";\n  NodeType2[NodeType2[\"PROCESSING_INSTRUCTION_NODE\"] = 7] = \"PROCESSING_INSTRUCTION_NODE\";\n  NodeType2[NodeType2[\"COMMENT_NODE\"] = 8] = \"COMMENT_NODE\";\n  NodeType2[NodeType2[\"DOCUMENT_NODE\"] = 9] = \"DOCUMENT_NODE\";\n  NodeType2[NodeType2[\"DOCUMENT_TYPE_NODE\"] = 10] = \"DOCUMENT_TYPE_NODE\";\n  NodeType2[NodeType2[\"DOCUMENT_FRAGMENT_NODE\"] = 11] = \"DOCUMENT_FRAGMENT_NODE\";\n  return NodeType2;\n})(NodeType || {});\nfunction getIFrameContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nfunction getIFrameContentWindow(iframe) {\n  try {\n    return iframe.contentWindow;\n  } catch (e2) {\n  }\n}\nconst NAMESPACES = {\n  svg: \"http://www.w3.org/2000/svg\",\n  \"xlink:href\": \"http://www.w3.org/1999/xlink\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\nconst SVGTagMap = {\n  altglyph: \"altGlyph\",\n  altglyphdef: \"altGlyphDef\",\n  altglyphitem: \"altGlyphItem\",\n  animatecolor: \"animateColor\",\n  animatemotion: \"animateMotion\",\n  animatetransform: \"animateTransform\",\n  clippath: \"clipPath\",\n  feblend: \"feBlend\",\n  fecolormatrix: \"feColorMatrix\",\n  fecomponenttransfer: \"feComponentTransfer\",\n  fecomposite: \"feComposite\",\n  feconvolvematrix: \"feConvolveMatrix\",\n  fediffuselighting: \"feDiffuseLighting\",\n  fedisplacementmap: \"feDisplacementMap\",\n  fedistantlight: \"feDistantLight\",\n  fedropshadow: \"feDropShadow\",\n  feflood: \"feFlood\",\n  fefunca: \"feFuncA\",\n  fefuncb: \"feFuncB\",\n  fefuncg: \"feFuncG\",\n  fefuncr: \"feFuncR\",\n  fegaussianblur: \"feGaussianBlur\",\n  feimage: \"feImage\",\n  femerge: \"feMerge\",\n  femergenode: \"feMergeNode\",\n  femorphology: \"feMorphology\",\n  feoffset: \"feOffset\",\n  fepointlight: \"fePointLight\",\n  fespecularlighting: \"feSpecularLighting\",\n  fespotlight: \"feSpotLight\",\n  fetile: \"feTile\",\n  feturbulence: \"feTurbulence\",\n  foreignobject: \"foreignObject\",\n  glyphref: \"glyphRef\",\n  lineargradient: \"linearGradient\",\n  radialgradient: \"radialGradient\"\n};\nlet createdNodeSet = null;\nfunction diff(oldTree, newTree, replayer, rrnodeMirror = newTree.mirror || newTree.ownerDocument.mirror) {\n  oldTree = diffBeforeUpdatingChildren(\n    oldTree,\n    newTree,\n    replayer,\n    rrnodeMirror\n  );\n  diffChildren(oldTree, newTree, replayer, rrnodeMirror);\n  diffAfterUpdatingChildren(oldTree, newTree, replayer);\n}\nfunction diffBeforeUpdatingChildren(oldTree, newTree, replayer, rrnodeMirror) {\n  if (replayer.afterAppend && !createdNodeSet) {\n    createdNodeSet = /* @__PURE__ */ new WeakSet();\n    setTimeout(() => {\n      createdNodeSet = null;\n    }, 0);\n  }\n  if (!sameNodeType(oldTree, newTree)) {\n    const calibratedOldTree = createOrGetNode(\n      newTree,\n      replayer.mirror,\n      rrnodeMirror\n    );\n    oldTree.parentNode?.replaceChild(calibratedOldTree, oldTree);\n    oldTree = calibratedOldTree;\n  }\n  switch (newTree.RRNodeType) {\n    case NodeType$1.Document: {\n      if (!nodeMatching(oldTree, newTree, replayer.mirror, rrnodeMirror)) {\n        const newMeta = rrnodeMirror.getMeta(newTree);\n        if (newMeta) {\n          replayer.mirror.removeNodeFromMap(oldTree);\n          oldTree.close();\n          oldTree.open();\n          replayer.mirror.add(oldTree, newMeta);\n          createdNodeSet?.add(oldTree);\n        }\n      }\n      break;\n    }\n    case NodeType$1.Element: {\n      const oldElement = oldTree;\n      const newRRElement = newTree;\n      switch (newRRElement.tagName) {\n        case \"IFRAME\": {\n          const oldContentDocument = getIFrameContentDocument(\n            oldTree\n          );\n          if (!oldContentDocument) break;\n          diff(\n            oldContentDocument,\n            newTree.contentDocument,\n            replayer,\n            rrnodeMirror\n          );\n          break;\n        }\n      }\n      if (newRRElement.shadowRoot) {\n        if (!oldElement.shadowRoot) oldElement.attachShadow({ mode: \"open\" });\n        diffChildren(\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          oldElement.shadowRoot,\n          newRRElement.shadowRoot,\n          replayer,\n          rrnodeMirror\n        );\n      }\n      diffProps(oldElement, newRRElement, rrnodeMirror);\n      break;\n    }\n  }\n  return oldTree;\n}\nfunction diffAfterUpdatingChildren(oldTree, newTree, replayer) {\n  switch (newTree.RRNodeType) {\n    case NodeType$1.Document: {\n      const scrollData = newTree.scrollData;\n      scrollData && replayer.applyScroll(scrollData, true);\n      break;\n    }\n    case NodeType$1.Element: {\n      const oldElement = oldTree;\n      const newRRElement = newTree;\n      newRRElement.scrollData && replayer.applyScroll(newRRElement.scrollData, true);\n      newRRElement.inputData && replayer.applyInput(newRRElement.inputData);\n      switch (newRRElement.tagName) {\n        case \"AUDIO\":\n        case \"VIDEO\": {\n          const oldMediaElement = oldTree;\n          const newMediaRRElement = newRRElement;\n          if (newMediaRRElement.paused !== void 0)\n            newMediaRRElement.paused ? void oldMediaElement.pause() : void oldMediaElement.play();\n          if (newMediaRRElement.muted !== void 0)\n            oldMediaElement.muted = newMediaRRElement.muted;\n          if (newMediaRRElement.volume !== void 0)\n            oldMediaElement.volume = newMediaRRElement.volume;\n          if (newMediaRRElement.currentTime !== void 0)\n            oldMediaElement.currentTime = newMediaRRElement.currentTime;\n          if (newMediaRRElement.playbackRate !== void 0)\n            oldMediaElement.playbackRate = newMediaRRElement.playbackRate;\n          break;\n        }\n        case \"CANVAS\": {\n          const rrCanvasElement = newTree;\n          if (rrCanvasElement.rr_dataURL !== null) {\n            const image = document.createElement(\"img\");\n            image.onload = () => {\n              const ctx = oldElement.getContext(\"2d\");\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height);\n              }\n            };\n            image.src = rrCanvasElement.rr_dataURL;\n          }\n          rrCanvasElement.canvasMutations.forEach(\n            (canvasMutation2) => replayer.applyCanvas(\n              canvasMutation2.event,\n              canvasMutation2.mutation,\n              oldTree\n            )\n          );\n          break;\n        }\n        case \"STYLE\": {\n          const styleSheet = oldElement.sheet;\n          styleSheet && newTree.rules.forEach(\n            (data) => replayer.applyStyleSheetMutation(data, styleSheet)\n          );\n          break;\n        }\n      }\n      break;\n    }\n    case NodeType$1.Text:\n    case NodeType$1.Comment:\n    case NodeType$1.CDATA: {\n      if (oldTree.textContent !== newTree.data)\n        oldTree.textContent = newTree.data;\n      break;\n    }\n  }\n  if (createdNodeSet?.has(oldTree)) {\n    createdNodeSet.delete(oldTree);\n    replayer.afterAppend?.(oldTree, replayer.mirror.getId(oldTree));\n  }\n}\nfunction diffProps(oldTree, newTree, rrnodeMirror) {\n  const oldAttributes = oldTree.attributes;\n  const newAttributes = newTree.attributes;\n  for (const name in newAttributes) {\n    const newValue = newAttributes[name];\n    const sn = rrnodeMirror.getMeta(newTree);\n    if (sn?.isSVG && NAMESPACES[name])\n      oldTree.setAttributeNS(NAMESPACES[name], name, newValue);\n    else if (newTree.tagName === \"CANVAS\" && name === \"rr_dataURL\") {\n      const image = document.createElement(\"img\");\n      image.src = newValue;\n      image.onload = () => {\n        const ctx = oldTree.getContext(\"2d\");\n        if (ctx) {\n          ctx.drawImage(image, 0, 0, image.width, image.height);\n        }\n      };\n    } else if (newTree.tagName === \"IFRAME\" && name === \"srcdoc\") continue;\n    else {\n      try {\n        oldTree.setAttribute(name, newValue);\n      } catch (err) {\n        console.warn(err);\n      }\n    }\n  }\n  for (const { name } of Array.from(oldAttributes))\n    if (!(name in newAttributes)) oldTree.removeAttribute(name);\n  newTree.scrollLeft && (oldTree.scrollLeft = newTree.scrollLeft);\n  newTree.scrollTop && (oldTree.scrollTop = newTree.scrollTop);\n}\nfunction diffChildren(oldTree, newTree, replayer, rrnodeMirror) {\n  const oldChildren = Array.from(oldTree.childNodes);\n  const newChildren = newTree.childNodes;\n  if (oldChildren.length === 0 && newChildren.length === 0) return;\n  let oldStartIndex = 0, oldEndIndex = oldChildren.length - 1, newStartIndex = 0, newEndIndex = newChildren.length - 1;\n  let oldStartNode = oldChildren[oldStartIndex], oldEndNode = oldChildren[oldEndIndex], newStartNode = newChildren[newStartIndex], newEndNode = newChildren[newEndIndex];\n  let oldIdToIndex = void 0, indexInOld = void 0;\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n    if (oldStartNode === void 0) {\n      oldStartNode = oldChildren[++oldStartIndex];\n    } else if (oldEndNode === void 0) {\n      oldEndNode = oldChildren[--oldEndIndex];\n    } else if (\n      // same first node?\n      nodeMatching(oldStartNode, newStartNode, replayer.mirror, rrnodeMirror)\n    ) {\n      oldStartNode = oldChildren[++oldStartIndex];\n      newStartNode = newChildren[++newStartIndex];\n    } else if (\n      // same last node?\n      nodeMatching(oldEndNode, newEndNode, replayer.mirror, rrnodeMirror)\n    ) {\n      oldEndNode = oldChildren[--oldEndIndex];\n      newEndNode = newChildren[--newEndIndex];\n    } else if (\n      // is the first old node the same as the last new node?\n      nodeMatching(oldStartNode, newEndNode, replayer.mirror, rrnodeMirror)\n    ) {\n      try {\n        handleInsertBefore(oldTree, oldStartNode, oldEndNode.nextSibling);\n      } catch (e2) {\n        console.warn(e2);\n      }\n      oldStartNode = oldChildren[++oldStartIndex];\n      newEndNode = newChildren[--newEndIndex];\n    } else if (\n      // is the last old node the same as the first new node?\n      nodeMatching(oldEndNode, newStartNode, replayer.mirror, rrnodeMirror)\n    ) {\n      try {\n        handleInsertBefore(oldTree, oldEndNode, oldStartNode);\n      } catch (e2) {\n        console.warn(e2);\n      }\n      oldEndNode = oldChildren[--oldEndIndex];\n      newStartNode = newChildren[++newStartIndex];\n    } else {\n      if (!oldIdToIndex) {\n        oldIdToIndex = {};\n        for (let i2 = oldStartIndex; i2 <= oldEndIndex; i2++) {\n          const oldChild2 = oldChildren[i2];\n          if (oldChild2 && replayer.mirror.hasNode(oldChild2))\n            oldIdToIndex[replayer.mirror.getId(oldChild2)] = i2;\n        }\n      }\n      indexInOld = oldIdToIndex[rrnodeMirror.getId(newStartNode)];\n      const nodeToMove = oldChildren[indexInOld];\n      if (indexInOld !== void 0 && nodeToMove && nodeMatching(nodeToMove, newStartNode, replayer.mirror, rrnodeMirror)) {\n        try {\n          handleInsertBefore(oldTree, nodeToMove, oldStartNode);\n        } catch (e2) {\n          console.warn(e2);\n        }\n        oldChildren[indexInOld] = void 0;\n      } else {\n        const newNode = createOrGetNode(\n          newStartNode,\n          replayer.mirror,\n          rrnodeMirror\n        );\n        if (oldTree.nodeName === \"#document\" && oldStartNode && /**\n        * Special case 1: one document isn't allowed to have two doctype nodes at the same time, so we need to remove the old one first before inserting the new one.\n        * How this case happens: A parent document in the old tree already has a doctype node with an id e.g. #1. A new full snapshot rebuilds the replayer with a new doctype node with another id #2. According to the algorithm, the new doctype node will be inserted before the old one, which is not allowed by the Document standard.\n        */\n        (newNode.nodeType === newNode.DOCUMENT_TYPE_NODE && oldStartNode.nodeType === oldStartNode.DOCUMENT_TYPE_NODE || /**\n        * Special case 2: one document isn't allowed to have two HTMLElements at the same time, so we need to remove the old one first before inserting the new one.\n        * How this case happens: A mounted iframe element has an automatically created HTML element. We should delete it before inserting a serialized one. Otherwise, an error 'Only one element on document allowed' will be thrown.\n        */\n        newNode.nodeType === newNode.ELEMENT_NODE && oldStartNode.nodeType === oldStartNode.ELEMENT_NODE)) {\n          oldTree.removeChild(oldStartNode);\n          replayer.mirror.removeNodeFromMap(oldStartNode);\n          oldStartNode = oldChildren[++oldStartIndex];\n        }\n        try {\n          handleInsertBefore(oldTree, newNode, oldStartNode || null);\n        } catch (e2) {\n          console.warn(e2);\n        }\n      }\n      newStartNode = newChildren[++newStartIndex];\n    }\n  }\n  if (oldStartIndex > oldEndIndex) {\n    const referenceRRNode = newChildren[newEndIndex + 1];\n    let referenceNode = null;\n    if (referenceRRNode)\n      referenceNode = replayer.mirror.getNode(\n        rrnodeMirror.getId(referenceRRNode)\n      );\n    for (; newStartIndex <= newEndIndex; ++newStartIndex) {\n      const newNode = createOrGetNode(\n        newChildren[newStartIndex],\n        replayer.mirror,\n        rrnodeMirror\n      );\n      try {\n        handleInsertBefore(oldTree, newNode, referenceNode);\n      } catch (e2) {\n        console.warn(e2);\n      }\n    }\n  } else if (newStartIndex > newEndIndex) {\n    for (; oldStartIndex <= oldEndIndex; oldStartIndex++) {\n      const node = oldChildren[oldStartIndex];\n      if (!node || node.parentNode !== oldTree) continue;\n      try {\n        oldTree.removeChild(node);\n        replayer.mirror.removeNodeFromMap(node);\n      } catch (e2) {\n        console.warn(e2);\n      }\n    }\n  }\n  let oldChild = oldTree.firstChild;\n  let newChild = newTree.firstChild;\n  while (oldChild !== null && newChild !== null) {\n    diff(oldChild, newChild, replayer, rrnodeMirror);\n    oldChild = oldChild.nextSibling;\n    newChild = newChild.nextSibling;\n  }\n}\nfunction createOrGetNode(rrNode, domMirror, rrnodeMirror) {\n  const nodeId = rrnodeMirror.getId(rrNode);\n  const sn = rrnodeMirror.getMeta(rrNode);\n  let node = null;\n  if (nodeId > -1) node = domMirror.getNode(nodeId);\n  if (node !== null && sameNodeType(node, rrNode)) return node;\n  switch (rrNode.RRNodeType) {\n    case NodeType$1.Document:\n      node = new Document();\n      break;\n    case NodeType$1.DocumentType:\n      node = document.implementation.createDocumentType(\n        rrNode.name,\n        rrNode.publicId,\n        rrNode.systemId\n      );\n      break;\n    case NodeType$1.Element: {\n      let tagName = rrNode.tagName.toLowerCase();\n      tagName = SVGTagMap[tagName] || tagName;\n      if (sn && \"isSVG\" in sn && sn?.isSVG) {\n        node = document.createElementNS(NAMESPACES[\"svg\"], tagName);\n      } else node = document.createElement(rrNode.tagName);\n      break;\n    }\n    case NodeType$1.Text:\n      node = document.createTextNode(rrNode.data);\n      break;\n    case NodeType$1.Comment:\n      node = document.createComment(rrNode.data);\n      break;\n    case NodeType$1.CDATA:\n      node = document.createCDATASection(rrNode.data);\n      break;\n  }\n  if (sn) domMirror.add(node, { ...sn });\n  try {\n    createdNodeSet?.add(node);\n  } catch (e2) {\n  }\n  return node;\n}\nfunction sameNodeType(node1, node2) {\n  if (node1.nodeType !== node2.nodeType) return false;\n  return node1.nodeType !== node1.ELEMENT_NODE || node1.tagName.toUpperCase() === node2.tagName;\n}\nfunction nodeMatching(node1, node2, domMirror, rrdomMirror) {\n  const node1Id = domMirror.getId(node1);\n  const node2Id = rrdomMirror.getId(node2);\n  if (node1Id === -1 || node1Id !== node2Id) return false;\n  return sameNodeType(node1, node2);\n}\nfunction getInsertedStylesFromElement(styleElement) {\n  const elementCssRules = styleElement.sheet?.cssRules;\n  if (!elementCssRules || !elementCssRules.length) return;\n  const tempStyleSheet = new CSSStyleSheet();\n  tempStyleSheet.replaceSync(styleElement.innerText);\n  const innerTextStylesMap = {};\n  for (let i2 = 0; i2 < tempStyleSheet.cssRules.length; i2++) {\n    innerTextStylesMap[tempStyleSheet.cssRules[i2].cssText] = tempStyleSheet.cssRules[i2];\n  }\n  const insertedStylesStyleSheet = [];\n  for (let i2 = 0; i2 < elementCssRules?.length; i2++) {\n    const cssRuleText = elementCssRules[i2].cssText;\n    if (!innerTextStylesMap[cssRuleText]) {\n      insertedStylesStyleSheet.push({\n        index: i2,\n        cssRuleText\n      });\n    }\n  }\n  return insertedStylesStyleSheet;\n}\nfunction handleInsertBefore(oldTree, nodeToMove, insertBeforeNode) {\n  let insertedStyles;\n  if (nodeToMove.nodeName === \"STYLE\") {\n    insertedStyles = getInsertedStylesFromElement(\n      nodeToMove\n    );\n  }\n  oldTree.insertBefore(nodeToMove, insertBeforeNode);\n  if (insertedStyles && insertedStyles.length) {\n    insertedStyles.forEach(({ cssRuleText, index }) => {\n      nodeToMove.sheet?.insertRule(cssRuleText, index);\n    });\n  }\n}\nclass RRDocument extends BaseRRDocument {\n  constructor(mirror2) {\n    super();\n    __publicField(this, \"UNSERIALIZED_STARTING_ID\", -2);\n    __publicField(this, \"_unserializedId\", this.UNSERIALIZED_STARTING_ID);\n    __publicField(this, \"mirror\", createMirror());\n    __publicField(this, \"scrollData\", null);\n    if (mirror2) {\n      this.mirror = mirror2;\n    }\n  }\n  /**\n   * Every time the id is used, it will minus 1 automatically to avoid collisions.\n   */\n  get unserializedId() {\n    return this._unserializedId--;\n  }\n  createDocument(_namespace, _qualifiedName, _doctype) {\n    return new RRDocument();\n  }\n  createDocumentType(qualifiedName, publicId, systemId) {\n    const documentTypeNode = new RRDocumentType(\n      qualifiedName,\n      publicId,\n      systemId\n    );\n    documentTypeNode.ownerDocument = this;\n    return documentTypeNode;\n  }\n  createElement(tagName) {\n    const upperTagName = tagName.toUpperCase();\n    let element;\n    switch (upperTagName) {\n      case \"AUDIO\":\n      case \"VIDEO\":\n        element = new RRMediaElement(upperTagName);\n        break;\n      case \"IFRAME\":\n        element = new RRIFrameElement(upperTagName, this.mirror);\n        break;\n      case \"CANVAS\":\n        element = new RRCanvasElement(upperTagName);\n        break;\n      case \"STYLE\":\n        element = new RRStyleElement(upperTagName);\n        break;\n      default:\n        element = new RRElement(upperTagName);\n        break;\n    }\n    element.ownerDocument = this;\n    return element;\n  }\n  createComment(data) {\n    const commentNode = new RRComment(data);\n    commentNode.ownerDocument = this;\n    return commentNode;\n  }\n  createCDATASection(data) {\n    const sectionNode = new RRCDATASection(data);\n    sectionNode.ownerDocument = this;\n    return sectionNode;\n  }\n  createTextNode(data) {\n    const textNode = new RRText(data);\n    textNode.ownerDocument = this;\n    return textNode;\n  }\n  destroyTree() {\n    this.firstChild = null;\n    this.lastChild = null;\n    this.mirror.reset();\n  }\n  open() {\n    super.open();\n    this._unserializedId = this.UNSERIALIZED_STARTING_ID;\n  }\n}\nconst RRDocumentType = BaseRRDocumentType;\nclass RRElement extends BaseRRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"inputData\", null);\n    __publicField(this, \"scrollData\", null);\n  }\n}\nclass RRMediaElement extends BaseRRMediaElement {\n}\nclass RRCanvasElement extends RRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"rr_dataURL\", null);\n    __publicField(this, \"canvasMutations\", []);\n  }\n  /**\n   * This is a dummy implementation to distinguish RRCanvasElement from real HTMLCanvasElement.\n   */\n  getContext() {\n    return null;\n  }\n}\nclass RRStyleElement extends RRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"rules\", []);\n  }\n}\nclass RRIFrameElement extends RRElement {\n  constructor(upperTagName, mirror2) {\n    super(upperTagName);\n    __publicField(this, \"contentDocument\", new RRDocument());\n    this.contentDocument.mirror = mirror2;\n  }\n}\nconst RRText = BaseRRText;\nconst RRComment = BaseRRComment;\nconst RRCDATASection = BaseRRCDATASection;\nfunction getValidTagName(element) {\n  if (element instanceof HTMLFormElement) {\n    return \"FORM\";\n  }\n  return element.tagName.toUpperCase();\n}\nfunction buildFromNode(node, rrdom, domMirror, parentRRNode) {\n  let rrNode;\n  switch (node.nodeType) {\n    case NodeType.DOCUMENT_NODE:\n      if (parentRRNode && parentRRNode.nodeName === \"IFRAME\")\n        rrNode = parentRRNode.contentDocument;\n      else {\n        rrNode = rrdom;\n        rrNode.compatMode = node.compatMode;\n      }\n      break;\n    case NodeType.DOCUMENT_TYPE_NODE: {\n      const documentType = node;\n      rrNode = rrdom.createDocumentType(\n        documentType.name,\n        documentType.publicId,\n        documentType.systemId\n      );\n      break;\n    }\n    case NodeType.ELEMENT_NODE: {\n      const elementNode = node;\n      const tagName = getValidTagName(elementNode);\n      rrNode = rrdom.createElement(tagName);\n      const rrElement = rrNode;\n      for (const { name, value } of Array.from(elementNode.attributes)) {\n        rrElement.attributes[name] = value;\n      }\n      elementNode.scrollLeft && (rrElement.scrollLeft = elementNode.scrollLeft);\n      elementNode.scrollTop && (rrElement.scrollTop = elementNode.scrollTop);\n      break;\n    }\n    case NodeType.TEXT_NODE:\n      rrNode = rrdom.createTextNode(node.textContent || \"\");\n      break;\n    case NodeType.CDATA_SECTION_NODE:\n      rrNode = rrdom.createCDATASection(node.data);\n      break;\n    case NodeType.COMMENT_NODE:\n      rrNode = rrdom.createComment(node.textContent || \"\");\n      break;\n    case NodeType.DOCUMENT_FRAGMENT_NODE:\n      rrNode = parentRRNode.attachShadow({ mode: \"open\" });\n      break;\n    default:\n      return null;\n  }\n  let sn = domMirror.getMeta(node);\n  if (rrdom instanceof RRDocument) {\n    if (!sn) {\n      sn = getDefaultSN(rrNode, rrdom.unserializedId);\n      domMirror.add(node, sn);\n    }\n    rrdom.mirror.add(rrNode, { ...sn });\n  }\n  return rrNode;\n}\nfunction buildFromDom(dom, domMirror = createMirror$1(), rrdom = new RRDocument()) {\n  function walk2(node, parentRRNode) {\n    const rrNode = buildFromNode(node, rrdom, domMirror, parentRRNode);\n    if (rrNode === null) return;\n    if (\n      // if the parentRRNode isn't a RRIFrameElement\n      parentRRNode?.nodeName !== \"IFRAME\" && // if node isn't a shadow root\n      node.nodeType !== NodeType.DOCUMENT_FRAGMENT_NODE\n    ) {\n      parentRRNode?.appendChild(rrNode);\n      rrNode.parentNode = parentRRNode;\n      rrNode.parentElement = parentRRNode;\n    }\n    if (node.nodeName === \"IFRAME\") {\n      const iframeDoc = getIFrameContentDocument(node);\n      iframeDoc && walk2(iframeDoc, rrNode);\n    } else if (node.nodeType === NodeType.DOCUMENT_NODE || node.nodeType === NodeType.ELEMENT_NODE || node.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {\n      if (node.nodeType === NodeType.ELEMENT_NODE && node.shadowRoot)\n        walk2(node.shadowRoot, rrNode);\n      node.childNodes.forEach((childNode) => walk2(childNode, rrNode));\n    }\n  }\n  walk2(dom, null);\n  return rrdom;\n}\nfunction createMirror() {\n  return new Mirror22();\n}\nclass Mirror22 {\n  constructor() {\n    __publicField(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n}\nfunction getDefaultSN(node, id) {\n  switch (node.RRNodeType) {\n    case NodeType$1.Document:\n      return {\n        id,\n        type: node.RRNodeType,\n        childNodes: []\n      };\n    case NodeType$1.DocumentType: {\n      const doctype = node;\n      return {\n        id,\n        type: node.RRNodeType,\n        name: doctype.name,\n        publicId: doctype.publicId,\n        systemId: doctype.systemId\n      };\n    }\n    case NodeType$1.Element:\n      return {\n        id,\n        type: node.RRNodeType,\n        tagName: node.tagName.toLowerCase(),\n        // In rrweb data, all tagNames are lowercase.\n        attributes: {},\n        childNodes: []\n      };\n    case NodeType$1.Text:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: node.textContent || \"\"\n      };\n    case NodeType$1.Comment:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: node.textContent || \"\"\n      };\n    case NodeType$1.CDATA:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: \"\"\n      };\n  }\n}\nfunction isNodeInLinkedList(n2) {\n  return \"__ln\" in n2;\n}\nclass DoubleLinkedList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n  }\n  get(position) {\n    if (position >= this.length) {\n      throw new Error(\"Position outside of list range\");\n    }\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n  addNode(n2) {\n    const node = {\n      value: n2,\n      previous: null,\n      next: null\n    };\n    n2.__ln = node;\n    if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {\n      const current = n2.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n2.previousSibling.__ln;\n      n2.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {\n      const current = n2.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n2.nextSibling.__ln;\n      n2.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    if (node.next === null) {\n      this.tail = node;\n    }\n    this.length++;\n  }\n  removeNode(n2) {\n    const current = n2.__ln;\n    if (!this.head) {\n      return;\n    }\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      } else {\n        this.tail = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      } else {\n        this.tail = current.previous;\n      }\n    }\n    if (n2.__ln) {\n      delete n2.__ln;\n    }\n    this.length--;\n  }\n}\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\nclass MutationBuffer {\n  constructor() {\n    this.frozen = false;\n    this.locked = false;\n    this.texts = [];\n    this.attributes = [];\n    this.attributeMap = /* @__PURE__ */ new WeakMap();\n    this.removes = [];\n    this.mapRemoves = [];\n    this.movedMap = {};\n    this.addedSet = /* @__PURE__ */ new Set();\n    this.movedSet = /* @__PURE__ */ new Set();\n    this.droppedSet = /* @__PURE__ */ new Set();\n    this.processMutations = (mutations) => {\n      mutations.forEach(this.processMutation);\n      this.emit();\n    };\n    this.emit = () => {\n      if (this.frozen || this.locked) {\n        return;\n      }\n      const adds = [];\n      const addedIds = /* @__PURE__ */ new Set();\n      const addList = new DoubleLinkedList();\n      const getNextId = (n2) => {\n        let ns = n2;\n        let nextId = IGNORED_NODE;\n        while (nextId === IGNORED_NODE) {\n          ns = ns && ns.nextSibling;\n          nextId = ns && this.mirror.getId(ns);\n        }\n        return nextId;\n      };\n      const pushAdd = (n2) => {\n        if (!n2.parentNode || !inDom(n2)) {\n          return;\n        }\n        const parentId = isShadowRoot(n2.parentNode) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(n2.parentNode);\n        const nextId = getNextId(n2);\n        if (parentId === -1 || nextId === -1) {\n          return addList.addNode(n2);\n        }\n        const sn = serializeNodeWithId(n2, {\n          doc: this.doc,\n          mirror: this.mirror,\n          blockClass: this.blockClass,\n          blockSelector: this.blockSelector,\n          maskAllText: this.maskAllText,\n          unblockSelector: this.unblockSelector,\n          maskTextClass: this.maskTextClass,\n          unmaskTextClass: this.unmaskTextClass,\n          maskTextSelector: this.maskTextSelector,\n          unmaskTextSelector: this.unmaskTextSelector,\n          skipChild: true,\n          newlyAddedElement: true,\n          inlineStylesheet: this.inlineStylesheet,\n          maskInputOptions: this.maskInputOptions,\n          maskAttributeFn: this.maskAttributeFn,\n          maskTextFn: this.maskTextFn,\n          maskInputFn: this.maskInputFn,\n          slimDOMOptions: this.slimDOMOptions,\n          dataURLOptions: this.dataURLOptions,\n          recordCanvas: this.recordCanvas,\n          inlineImages: this.inlineImages,\n          onSerialize: (currentN) => {\n            if (isSerializedIframe(currentN, this.mirror) && !isBlocked(\n              currentN,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              this.iframeManager.addIframe(currentN);\n            }\n            if (isSerializedStylesheet(currentN, this.mirror)) {\n              this.stylesheetManager.trackLinkElement(\n                currentN\n              );\n            }\n            if (hasShadowRoot(n2)) {\n              this.shadowDomManager.addShadowRoot(n2.shadowRoot, this.doc);\n            }\n          },\n          onIframeLoad: (iframe, childSn) => {\n            if (isBlocked(\n              iframe,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              return;\n            }\n            this.iframeManager.attachIframe(iframe, childSn);\n            if (iframe.contentWindow) {\n              this.canvasManager.addWindow(iframe.contentWindow);\n            }\n            this.shadowDomManager.observeAttachShadow(iframe);\n          },\n          onStylesheetLoad: (link, childSn) => {\n            this.stylesheetManager.attachLinkElement(link, childSn);\n          }\n        });\n        if (sn) {\n          adds.push({\n            parentId,\n            nextId,\n            node: sn\n          });\n          addedIds.add(sn.id);\n        }\n      };\n      while (this.mapRemoves.length) {\n        this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n      }\n      for (const n2 of this.movedSet) {\n        if (isParentRemoved(this.removes, n2, this.mirror) && !this.movedSet.has(n2.parentNode)) {\n          continue;\n        }\n        pushAdd(n2);\n      }\n      for (const n2 of this.addedSet) {\n        if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removes, n2, this.mirror)) {\n          pushAdd(n2);\n        } else if (isAncestorInSet(this.movedSet, n2)) {\n          pushAdd(n2);\n        } else {\n          this.droppedSet.add(n2);\n        }\n      }\n      let candidate = null;\n      while (addList.length) {\n        let node = null;\n        if (candidate) {\n          const parentId = this.mirror.getId(candidate.value.parentNode);\n          const nextId = getNextId(candidate.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = candidate;\n          }\n        }\n        if (!node) {\n          let tailNode = addList.tail;\n          while (tailNode) {\n            const _node = tailNode;\n            tailNode = tailNode.previous;\n            if (_node) {\n              const parentId = this.mirror.getId(_node.value.parentNode);\n              const nextId = getNextId(_node.value);\n              if (nextId === -1) continue;\n              else if (parentId !== -1) {\n                node = _node;\n                break;\n              } else {\n                const unhandledNode = _node.value;\n                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                  const shadowHost = unhandledNode.parentNode.host;\n                  const parentId2 = this.mirror.getId(shadowHost);\n                  if (parentId2 !== -1) {\n                    node = _node;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (!node) {\n          while (addList.head) {\n            addList.removeNode(addList.head.value);\n          }\n          break;\n        }\n        candidate = node.previous;\n        addList.removeNode(node.value);\n        pushAdd(node.value);\n      }\n      const payload = {\n        texts: this.texts.map((text) => ({\n          id: this.mirror.getId(text.node),\n          value: text.value\n        })).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),\n        attributes: this.attributes.map((attribute) => {\n          const { attributes } = attribute;\n          if (typeof attributes.style === \"string\") {\n            const diffAsStr = JSON.stringify(attribute.styleDiff);\n            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n            if (diffAsStr.length < attributes.style.length) {\n              if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                attributes.style = attribute.styleDiff;\n              }\n            }\n          }\n          return {\n            id: this.mirror.getId(attribute.node),\n            attributes\n          };\n        }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),\n        removes: this.removes,\n        adds\n      };\n      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n        return;\n      }\n      this.texts = [];\n      this.attributes = [];\n      this.attributeMap = /* @__PURE__ */ new WeakMap();\n      this.removes = [];\n      this.addedSet = /* @__PURE__ */ new Set();\n      this.movedSet = /* @__PURE__ */ new Set();\n      this.droppedSet = /* @__PURE__ */ new Set();\n      this.movedMap = {};\n      this.mutationCb(payload);\n    };\n    this.processMutation = (m) => {\n      if (isIgnored(m.target, this.mirror)) {\n        return;\n      }\n      switch (m.type) {\n        case \"characterData\": {\n          const value = m.target.textContent;\n          if (!isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) && value !== m.oldValue) {\n            this.texts.push({\n              value: needMaskingText(\n                m.target,\n                this.maskTextClass,\n                this.maskTextSelector,\n                this.unmaskTextClass,\n                this.unmaskTextSelector,\n                this.maskAllText\n              ) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n              node: m.target\n            });\n          }\n          break;\n        }\n        case \"attributes\": {\n          const target = m.target;\n          let attributeName = m.attributeName;\n          let value = m.target.getAttribute(attributeName);\n          if (attributeName === \"value\") {\n            const type = getInputType(target);\n            const tagName = target.tagName;\n            value = getInputValue(target, tagName, type);\n            const isInputMasked = shouldMaskInput({\n              maskInputOptions: this.maskInputOptions,\n              tagName,\n              type\n            });\n            const forceMask = needMaskingText(\n              m.target,\n              this.maskTextClass,\n              this.maskTextSelector,\n              this.unmaskTextClass,\n              this.unmaskTextSelector,\n              isInputMasked\n            );\n            value = maskInputValue({\n              isMasked: forceMask,\n              element: target,\n              value,\n              maskInputFn: this.maskInputFn\n            });\n          }\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) || value === m.oldValue) {\n            return;\n          }\n          let item = this.attributeMap.get(m.target);\n          if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !this.keepIframeSrcFn(value)) {\n            const iframeDoc = getIFrameContentDocument(\n              target\n            );\n            if (!iframeDoc) {\n              attributeName = \"rr_src\";\n            } else {\n              return;\n            }\n          }\n          if (!item) {\n            item = {\n              node: m.target,\n              attributes: {},\n              styleDiff: {},\n              _unchangedStyles: {}\n            };\n            this.attributes.push(item);\n            this.attributeMap.set(m.target, item);\n          }\n          if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n            target.setAttribute(\"data-rr-is-password\", \"true\");\n          }\n          if (!ignoreAttribute(target.tagName, attributeName)) {\n            item.attributes[attributeName] = transformAttribute(\n              this.doc,\n              toLowerCase(target.tagName),\n              toLowerCase(attributeName),\n              value,\n              target,\n              this.maskAttributeFn\n            );\n            if (attributeName === \"style\") {\n              if (!this.unattachedDoc) {\n                try {\n                  this.unattachedDoc = document.implementation.createHTMLDocument();\n                } catch (e2) {\n                  this.unattachedDoc = this.doc;\n                }\n              }\n              const old = this.unattachedDoc.createElement(\"span\");\n              if (m.oldValue) {\n                old.setAttribute(\"style\", m.oldValue);\n              }\n              for (const pname of Array.from(target.style)) {\n                const newValue = target.style.getPropertyValue(pname);\n                const newPriority = target.style.getPropertyPriority(pname);\n                if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                  if (newPriority === \"\") {\n                    item.styleDiff[pname] = newValue;\n                  } else {\n                    item.styleDiff[pname] = [newValue, newPriority];\n                  }\n                } else {\n                  item._unchangedStyles[pname] = [newValue, newPriority];\n                }\n              }\n              for (const pname of Array.from(old.style)) {\n                if (target.style.getPropertyValue(pname) === \"\") {\n                  item.styleDiff[pname] = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n        case \"childList\": {\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            true\n          )) {\n            return;\n          }\n          m.addedNodes.forEach((n2) => this.genAdds(n2, m.target));\n          m.removedNodes.forEach((n2) => {\n            const nodeId = this.mirror.getId(n2);\n            const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n            if (isBlocked(\n              m.target,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            ) || isIgnored(n2, this.mirror) || !isSerialized(n2, this.mirror)) {\n              return;\n            }\n            if (this.addedSet.has(n2)) {\n              deepDelete(this.addedSet, n2);\n              this.droppedSet.add(n2);\n            } else if (this.addedSet.has(m.target) && nodeId === -1) ;\n            else if (isAncestorRemoved(m.target, this.mirror)) ;\n            else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {\n              deepDelete(this.movedSet, n2);\n            } else {\n              this.removes.push({\n                parentId,\n                id: nodeId,\n                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0\n              });\n            }\n            this.mapRemoves.push(n2);\n          });\n          break;\n        }\n      }\n    };\n    this.genAdds = (n2, target) => {\n      if (this.processedNodeManager.inOtherBuffer(n2, this)) return;\n      if (this.addedSet.has(n2) || this.movedSet.has(n2)) return;\n      if (this.mirror.hasNode(n2)) {\n        if (isIgnored(n2, this.mirror)) {\n          return;\n        }\n        this.movedSet.add(n2);\n        let targetId = null;\n        if (target && this.mirror.hasNode(target)) {\n          targetId = this.mirror.getId(target);\n        }\n        if (targetId && targetId !== -1) {\n          this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;\n        }\n      } else {\n        this.addedSet.add(n2);\n        this.droppedSet.delete(n2);\n      }\n      if (!isBlocked(\n        n2,\n        this.blockClass,\n        this.blockSelector,\n        this.unblockSelector,\n        false\n      )) {\n        n2.childNodes.forEach((childN) => this.genAdds(childN));\n        if (hasShadowRoot(n2)) {\n          n2.shadowRoot.childNodes.forEach((childN) => {\n            this.processedNodeManager.add(childN, this);\n            this.genAdds(childN, n2);\n          });\n        }\n      }\n    };\n  }\n  init(options) {\n    [\n      \"mutationCb\",\n      \"blockClass\",\n      \"blockSelector\",\n      \"unblockSelector\",\n      \"maskAllText\",\n      \"maskTextClass\",\n      \"unmaskTextClass\",\n      \"maskTextSelector\",\n      \"unmaskTextSelector\",\n      \"inlineStylesheet\",\n      \"maskInputOptions\",\n      \"maskAttributeFn\",\n      \"maskTextFn\",\n      \"maskInputFn\",\n      \"keepIframeSrcFn\",\n      \"recordCanvas\",\n      \"inlineImages\",\n      \"slimDOMOptions\",\n      \"dataURLOptions\",\n      \"doc\",\n      \"mirror\",\n      \"iframeManager\",\n      \"stylesheetManager\",\n      \"shadowDomManager\",\n      \"canvasManager\",\n      \"processedNodeManager\"\n    ].forEach((key) => {\n      this[key] = options[key];\n    });\n  }\n  freeze() {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  }\n  unfreeze() {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  }\n  isFrozen() {\n    return this.frozen;\n  }\n  lock() {\n    this.locked = true;\n    this.canvasManager.lock();\n  }\n  unlock() {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  }\n  reset() {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  }\n}\nfunction deepDelete(addsSet, n2) {\n  addsSet.delete(n2);\n  n2.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n}\nfunction isParentRemoved(removes, n2, mirror2) {\n  if (removes.length === 0) return false;\n  return _isParentRemoved(removes, n2, mirror2);\n}\nfunction _isParentRemoved(removes, n2, mirror2) {\n  let node = n2.parentNode;\n  while (node) {\n    const parentId = mirror2.getId(node);\n    if (removes.some((r2) => r2.id === parentId)) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\nfunction isAncestorInSet(set, n2) {\n  if (set.size === 0) return false;\n  return _isAncestorInSet(set, n2);\n}\nfunction _isAncestorInSet(set, n2) {\n  const { parentNode } = n2;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return _isAncestorInSet(set, parentNode);\n}\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n  errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n  errorHandler = void 0;\n}\nconst callbackWrapper = (cb) => {\n  if (!errorHandler) {\n    return cb;\n  }\n  const rrwebWrapped = (...rest) => {\n    try {\n      return cb(...rest);\n    } catch (error) {\n      if (errorHandler && errorHandler(error) === true) {\n        return () => {\n        };\n      }\n      throw error;\n    }\n  };\n  return rrwebWrapped;\n};\nconst mutationBuffers = [];\nfunction getEventTarget(event) {\n  try {\n    if (\"composedPath\" in event) {\n      const path = event.composedPath();\n      if (path.length) {\n        return path[0];\n      }\n    } else if (\"path\" in event && event.path.length) {\n      return event.path[0];\n    }\n  } catch {\n  }\n  return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  mutationBuffer.init(options);\n  let mutationObserverCtor = window.MutationObserver || /**\n  * Some websites may disable MutationObserver by removing it from the window object.\n  * If someone is using rrweb to build a browser extention or things like it, they\n  * could not change the website's code but can have an opportunity to inject some\n  * code before the website executing its JS logic.\n  * Then they can do this to store the native MutationObserver:\n  * window.__rrMutationObserver = MutationObserver\n  */\n  window.__rrMutationObserver;\n  const angularZoneSymbol = window?.Zone?.__symbol__?.(\"MutationObserver\");\n  if (angularZoneSymbol && window[angularZoneSymbol]) {\n    mutationObserverCtor = window[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(\n    callbackWrapper((mutations) => {\n      if (options.onMutation && options.onMutation(mutations) === false) {\n        return;\n      }\n      mutationBuffer.processMutations.bind(mutationBuffer)(mutations);\n    })\n  );\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nfunction initMoveObserver({\n  mousemoveCb,\n  sampling,\n  doc,\n  mirror: mirror2\n}) {\n  if (sampling.mousemove === false) {\n    return () => {\n    };\n  }\n  const threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n  const callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n  let positions = [];\n  let timeBaseline;\n  const wrappedCb = throttle(\n    callbackWrapper(\n      (source) => {\n        const totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(\n          positions.map((p) => {\n            p.timeOffset -= totalOffset;\n            return p;\n          }),\n          source\n        );\n        positions = [];\n        timeBaseline = null;\n      }\n    ),\n    callbackThreshold\n  );\n  const updatePosition = callbackWrapper(\n    throttle(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;\n        if (!timeBaseline) {\n          timeBaseline = nowTimestamp();\n        }\n        positions.push({\n          x: clientX,\n          y: clientY,\n          id: mirror2.getId(target),\n          timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(\n          typeof DragEvent !== \"undefined\" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove\n        );\n      }),\n      threshold,\n      {\n        trailing: false\n      }\n    )\n  );\n  const handlers = [\n    on(\"mousemove\", updatePosition, doc),\n    on(\"touchmove\", updatePosition, doc),\n    on(\"drag\", updatePosition, doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initMouseInteractionObserver({\n  mouseInteractionCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  if (sampling.mouseInteraction === false) {\n    return () => {\n    };\n  }\n  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n  const handlers = [];\n  let currentPointerType = null;\n  const getHandler = (eventKey) => {\n    return (event) => {\n      const target = getEventTarget(event);\n      if (isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n        return;\n      }\n      let pointerType = null;\n      let thisEventKey = eventKey;\n      if (\"pointerType\" in event) {\n        switch (event.pointerType) {\n          case \"mouse\":\n            pointerType = PointerTypes.Mouse;\n            break;\n          case \"touch\":\n            pointerType = PointerTypes.Touch;\n            break;\n          case \"pen\":\n            pointerType = PointerTypes.Pen;\n            break;\n        }\n        if (pointerType === PointerTypes.Touch) {\n          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n            thisEventKey = \"TouchStart\";\n          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n            thisEventKey = \"TouchEnd\";\n          }\n        } else if (pointerType === PointerTypes.Pen) ;\n      } else if (legacy_isTouchEvent(event)) {\n        pointerType = PointerTypes.Touch;\n      }\n      if (pointerType !== null) {\n        currentPointerType = pointerType;\n        if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n          pointerType = null;\n        }\n      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n        pointerType = currentPointerType;\n        currentPointerType = null;\n      }\n      const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e2) {\n        return;\n      }\n      const id = mirror2.getId(target);\n      const { clientX, clientY } = e2;\n      callbackWrapper(mouseInteractionCb)({\n        type: MouseInteractions[thisEventKey],\n        id,\n        x: clientX,\n        y: clientY,\n        ...pointerType !== null && { pointerType }\n      });\n    };\n  };\n  Object.keys(MouseInteractions).filter(\n    (key) => Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false\n  ).forEach((eventKey) => {\n    let eventName = toLowerCase(eventKey);\n    const handler = getHandler(eventKey);\n    if (window.PointerEvent) {\n      switch (MouseInteractions[eventKey]) {\n        case MouseInteractions.MouseDown:\n        case MouseInteractions.MouseUp:\n          eventName = eventName.replace(\n            \"mouse\",\n            \"pointer\"\n          );\n          break;\n        case MouseInteractions.TouchStart:\n        case MouseInteractions.TouchEnd:\n          return;\n      }\n    }\n    handlers.push(on(eventName, handler, doc));\n  });\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initScrollObserver({\n  scrollCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  const updatePosition = callbackWrapper(\n    throttle(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const id = mirror2.getId(target);\n        if (target === doc && doc.defaultView) {\n          const scrollLeftTop = getWindowScroll(doc.defaultView);\n          scrollCb({\n            id,\n            x: scrollLeftTop.left,\n            y: scrollLeftTop.top\n          });\n        } else {\n          scrollCb({\n            id,\n            x: target.scrollLeft,\n            y: target.scrollTop\n          });\n        }\n      }),\n      sampling.scroll || 100\n    )\n  );\n  return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver({ viewportResizeCb }, { win }) {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = callbackWrapper(\n    throttle(\n      callbackWrapper(() => {\n        const height = getWindowHeight();\n        const width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n          viewportResizeCb({\n            width: Number(width),\n            height: Number(height)\n          });\n          lastH = height;\n          lastW = width;\n        }\n      }),\n      200\n    )\n  );\n  return on(\"resize\", updateDimension, win);\n}\nconst INPUT_TAGS = [\"INPUT\", \"TEXTAREA\", \"SELECT\"];\nconst lastInputValueMap = /* @__PURE__ */ new WeakMap();\nfunction initInputObserver({\n  inputCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  ignoreClass,\n  ignoreSelector,\n  maskInputOptions,\n  maskInputFn,\n  sampling,\n  userTriggeredOnInput,\n  maskTextClass,\n  unmaskTextClass,\n  maskTextSelector,\n  unmaskTextSelector\n}) {\n  function eventHandler(event) {\n    let target = getEventTarget(event);\n    const userTriggered = event.isTrusted;\n    const tagName = target && toUpperCase(target.tagName);\n    if (tagName === \"OPTION\") target = target.parentElement;\n    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(\n      target,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      true\n    )) {\n      return;\n    }\n    const el = target;\n    if (el.classList.contains(ignoreClass) || ignoreSelector && el.matches(ignoreSelector)) {\n      return;\n    }\n    const type = getInputType(target);\n    let text = getInputValue(el, tagName, type);\n    let isChecked = false;\n    const isInputMasked = shouldMaskInput({\n      maskInputOptions,\n      tagName,\n      type\n    });\n    const forceMask = needMaskingText(\n      target,\n      maskTextClass,\n      maskTextSelector,\n      unmaskTextClass,\n      unmaskTextSelector,\n      isInputMasked\n    );\n    if (type === \"radio\" || type === \"checkbox\") {\n      isChecked = target.checked;\n    }\n    text = maskInputValue({\n      isMasked: forceMask,\n      element: target,\n      value: text,\n      maskInputFn\n    });\n    cbWithDedup(\n      target,\n      userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked }\n    );\n    const name = target.name;\n    if (type === \"radio\" && name && isChecked) {\n      doc.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`).forEach((el2) => {\n        if (el2 !== target) {\n          const text2 = maskInputValue({\n            // share mask behavior of `target`\n            isMasked: forceMask,\n            element: el2,\n            value: getInputValue(el2, tagName, type),\n            maskInputFn\n          });\n          cbWithDedup(\n            el2,\n            userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked }\n          );\n        }\n      });\n    }\n  }\n  function cbWithDedup(target, v2) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {\n      lastInputValueMap.set(target, v2);\n      const id = mirror2.getId(target);\n      callbackWrapper(inputCb)({\n        ...v2,\n        id\n      });\n    }\n  }\n  const events = sampling.input === \"last\" ? [\"change\"] : [\"input\", \"change\"];\n  const handlers = events.map(\n    (eventName) => on(eventName, callbackWrapper(eventHandler), doc)\n  );\n  const currentWindow = doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  }\n  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(\n    currentWindow.HTMLInputElement.prototype,\n    \"value\"\n  );\n  const hookProperties = [\n    [currentWindow.HTMLInputElement.prototype, \"value\"],\n    [currentWindow.HTMLInputElement.prototype, \"checked\"],\n    [currentWindow.HTMLSelectElement.prototype, \"value\"],\n    [currentWindow.HTMLTextAreaElement.prototype, \"value\"],\n    // Some UI library use selectedIndex to set select value\n    [currentWindow.HTMLSelectElement.prototype, \"selectedIndex\"],\n    [currentWindow.HTMLOptionElement.prototype, \"selected\"]\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map(\n        (p) => hookSetter(\n          p[0],\n          p[1],\n          {\n            set() {\n              callbackWrapper(eventHandler)({\n                target: this,\n                isTrusted: false\n                // userTriggered to false as this could well be programmatic\n              });\n            }\n          },\n          false,\n          currentWindow\n        )\n      )\n    );\n  }\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction getNestedCSSRulePositions(rule) {\n  const positions = [];\n  function recurse(childRule, pos) {\n    if (hasNestedCSSRule(\"CSSGroupingRule\") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule(\"CSSMediaRule\") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule(\"CSSSupportsRule\") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule(\"CSSConditionRule\") && childRule.parentRule instanceof CSSConditionRule) {\n      const rules2 = Array.from(\n        childRule.parentRule.cssRules\n      );\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    } else if (childRule.parentStyleSheet) {\n      const rules2 = Array.from(childRule.parentStyleSheet.cssRules);\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    }\n    return pos;\n  }\n  return recurse(rule, positions);\n}\nfunction getIdAndStyleId(sheet, mirror2, styleMirror) {\n  let id, styleId;\n  if (!sheet) return {};\n  if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);\n  else styleId = styleMirror.getId(sheet);\n  return {\n    styleId,\n    id\n  };\n}\nfunction initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win }) {\n  if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n    return () => {\n    };\n  }\n  const insertRule = win.CSSStyleSheet.prototype.insertRule;\n  win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [rule, index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            adds: [{ rule, index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n  win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            removes: [{ index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  let replace;\n  if (win.CSSStyleSheet.prototype.replace) {\n    replace = win.CSSStyleSheet.prototype.replace;\n    win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replace: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  let replaceSync;\n  if (win.CSSStyleSheet.prototype.replaceSync) {\n    replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n    win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replaceSync: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  const supportedNestedCSSRuleTypes = {};\n  if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n  } else {\n    if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n    }\n  }\n  const unmodifiedFunctions = {};\n  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n    unmodifiedFunctions[typeKey] = {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      insertRule: type.prototype.insertRule,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      deleteRule: type.prototype.deleteRule\n    };\n    type.prototype.insertRule = new Proxy(\n      unmodifiedFunctions[typeKey].insertRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [rule, index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                adds: [\n                  {\n                    rule,\n                    index: [\n                      ...getNestedCSSRulePositions(thisArg),\n                      index || 0\n                      // defaults to 0\n                    ]\n                  }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n    type.prototype.deleteRule = new Proxy(\n      unmodifiedFunctions[typeKey].deleteRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                removes: [\n                  { index: [...getNestedCSSRulePositions(thisArg), index] }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleSheet.prototype.insertRule = insertRule;\n    win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n    replace && (win.CSSStyleSheet.prototype.replace = replace);\n    replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n    });\n  });\n}\nfunction initAdoptedStyleSheetObserver({\n  mirror: mirror2,\n  stylesheetManager\n}, host) {\n  let hostId = null;\n  if (host.nodeName === \"#document\") hostId = mirror2.getId(host);\n  else hostId = mirror2.getId(host.host);\n  const patchTarget = host.nodeName === \"#document\" ? host.defaultView?.Document : host.ownerDocument?.defaultView?.ShadowRoot;\n  const originalPropertyDescriptor = patchTarget?.prototype ? Object.getOwnPropertyDescriptor(\n    patchTarget?.prototype,\n    \"adoptedStyleSheets\"\n  ) : void 0;\n  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)\n    return () => {\n    };\n  Object.defineProperty(host, \"adoptedStyleSheets\", {\n    configurable: originalPropertyDescriptor.configurable,\n    enumerable: originalPropertyDescriptor.enumerable,\n    get() {\n      return originalPropertyDescriptor.get?.call(this);\n    },\n    set(sheets) {\n      const result = originalPropertyDescriptor.set?.call(this, sheets);\n      if (hostId !== null && hostId !== -1) {\n        try {\n          stylesheetManager.adoptStyleSheets(sheets, hostId);\n        } catch (e2) {\n        }\n      }\n      return result;\n    }\n  });\n  return callbackWrapper(() => {\n    Object.defineProperty(host, \"adoptedStyleSheets\", {\n      configurable: originalPropertyDescriptor.configurable,\n      enumerable: originalPropertyDescriptor.enumerable,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      get: originalPropertyDescriptor.get,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      set: originalPropertyDescriptor.set\n    });\n  });\n}\nfunction initStyleDeclarationObserver({\n  styleDeclarationCb,\n  mirror: mirror2,\n  ignoreCSSAttributes,\n  stylesheetManager\n}, { win }) {\n  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n  win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property, value, priority] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return setProperty.apply(thisArg, [property, value, priority]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            set: {\n              property,\n              value,\n              priority\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n  win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return removeProperty.apply(thisArg, [property]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            remove: {\n              property\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n  });\n}\nfunction initMediaInteractionObserver({\n  mediaInteractionCb,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  mirror: mirror2,\n  sampling,\n  doc\n}) {\n  const handler = callbackWrapper(\n    (type) => throttle(\n      callbackWrapper((event) => {\n        const target = getEventTarget(event);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const { currentTime, volume, muted, playbackRate } = target;\n        mediaInteractionCb({\n          type,\n          id: mirror2.getId(target),\n          currentTime,\n          volume,\n          muted,\n          playbackRate\n        });\n      }),\n      sampling.media || 500\n    )\n  );\n  const handlers = [\n    on(\"play\", handler(MediaInteractions.Play), doc),\n    on(\"pause\", handler(MediaInteractions.Pause), doc),\n    on(\"seeked\", handler(MediaInteractions.Seeked), doc),\n    on(\"volumechange\", handler(MediaInteractions.VolumeChange), doc),\n    on(\"ratechange\", handler(MediaInteractions.RateChange), doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initFontObserver({ fontCb, doc }) {\n  const win = doc.defaultView;\n  if (!win) {\n    return () => {\n    };\n  }\n  const handlers = [];\n  const fontMap = /* @__PURE__ */ new WeakMap();\n  const originalFontFace = win.FontFace;\n  win.FontFace = function FontFace2(family, source, descriptors) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== \"string\",\n      descriptors,\n      fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n    });\n    return fontFace;\n  };\n  const restoreHandler = patch(\n    doc.fonts,\n    \"add\",\n    function(original) {\n      return function(fontFace) {\n        setTimeout$1(\n          callbackWrapper(() => {\n            const p = fontMap.get(fontFace);\n            if (p) {\n              fontCb(p);\n              fontMap.delete(fontFace);\n            }\n          }),\n          0\n        );\n        return original.apply(this, [fontFace]);\n      };\n    }\n  );\n  handlers.push(() => {\n    win.FontFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initSelectionObserver(param) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    selectionCb\n  } = param;\n  let collapsed = true;\n  const updateSelection = callbackWrapper(() => {\n    const selection = doc.getSelection();\n    if (!selection || collapsed && selection?.isCollapsed) return;\n    collapsed = selection.isCollapsed || false;\n    const ranges = [];\n    const count = selection.rangeCount || 0;\n    for (let i2 = 0; i2 < count; i2++) {\n      const range = selection.getRangeAt(i2);\n      const { startContainer, startOffset, endContainer, endOffset } = range;\n      const blocked = isBlocked(\n        startContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      ) || isBlocked(\n        endContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      );\n      if (blocked) continue;\n      ranges.push({\n        start: mirror2.getId(startContainer),\n        startOffset,\n        end: mirror2.getId(endContainer),\n        endOffset\n      });\n    }\n    selectionCb({ ranges });\n  });\n  updateSelection();\n  return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver({\n  doc,\n  customElementCb\n}) {\n  const win = doc.defaultView;\n  if (!win || !win.customElements) return () => {\n  };\n  const restoreHandler = patch(\n    win.customElements,\n    \"define\",\n    function(original) {\n      return function(name, constructor, options) {\n        try {\n          customElementCb({\n            define: {\n              name\n            }\n          });\n        } catch (e2) {\n        }\n        return original.apply(this, [name, constructor, options]);\n      };\n    }\n  );\n  return restoreHandler;\n}\nfunction initObservers(o2, _hooks = {}) {\n  const currentWindow = o2.doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n    };\n  }\n  let mutationObserver;\n  if (o2.recordDOM) {\n    mutationObserver = initMutationObserver(o2, o2.doc);\n  }\n  const mousemoveHandler = initMoveObserver(o2);\n  const mouseInteractionHandler = initMouseInteractionObserver(o2);\n  const scrollHandler = initScrollObserver(o2);\n  const viewportResizeHandler = initViewportResizeObserver(o2, {\n    win: currentWindow\n  });\n  const inputHandler = initInputObserver(o2);\n  const mediaInteractionHandler = initMediaInteractionObserver(o2);\n  let styleSheetObserver = () => {\n  };\n  let adoptedStyleSheetObserver = () => {\n  };\n  let styleDeclarationObserver = () => {\n  };\n  let fontObserver = () => {\n  };\n  if (o2.recordDOM) {\n    styleSheetObserver = initStyleSheetObserver(o2, { win: currentWindow });\n    adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);\n    styleDeclarationObserver = initStyleDeclarationObserver(o2, {\n      win: currentWindow\n    });\n    if (o2.collectFonts) {\n      fontObserver = initFontObserver(o2);\n    }\n  }\n  const selectionObserver = initSelectionObserver(o2);\n  const customElementObserver = initCustomElementObserver(o2);\n  const pluginHandlers = [];\n  for (const plugin of o2.plugins) {\n    pluginHandlers.push(\n      plugin.observer(plugin.callback, currentWindow, plugin.options)\n    );\n  }\n  return callbackWrapper(() => {\n    mutationBuffers.forEach((b) => b.reset());\n    mutationObserver?.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    adoptedStyleSheetObserver();\n    styleDeclarationObserver();\n    fontObserver();\n    selectionObserver();\n    customElementObserver();\n    pluginHandlers.forEach((h) => h());\n  });\n}\nfunction hasNestedCSSRule(prop) {\n  return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n  return Boolean(\n    typeof window[prop] !== \"undefined\" && // Note: Generally, this check _shouldn't_ be necessary\n    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here\n    window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype\n  );\n}\nclass CrossOriginIframeMirror {\n  constructor(generateIdFn) {\n    this.generateIdFn = generateIdFn;\n    this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n    this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n    let id = idToRemoteIdMap.get(remoteId);\n    if (!id) {\n      id = this.generateIdFn();\n      idToRemoteIdMap.set(remoteId, id);\n      remoteIdToIdMap.set(id, remoteId);\n    }\n    return id;\n  }\n  getIds(iframe, remoteId) {\n    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return remoteId.map(\n      (id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap)\n    );\n  }\n  getRemoteId(iframe, id, map) {\n    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n    if (typeof id !== \"number\") return id;\n    const remoteId = remoteIdToIdMap.get(id);\n    if (!remoteId) return -1;\n    return remoteId;\n  }\n  getRemoteIds(iframe, ids) {\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));\n  }\n  reset(iframe) {\n    if (!iframe) {\n      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n      return;\n    }\n    this.iframeIdToRemoteIdMap.delete(iframe);\n    this.iframeRemoteIdToIdMap.delete(iframe);\n  }\n  getIdToRemoteIdMap(iframe) {\n    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n    if (!idToRemoteIdMap) {\n      idToRemoteIdMap = /* @__PURE__ */ new Map();\n      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n    }\n    return idToRemoteIdMap;\n  }\n  getRemoteIdToIdMap(iframe) {\n    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n    if (!remoteIdToIdMap) {\n      remoteIdToIdMap = /* @__PURE__ */ new Map();\n      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n    }\n    return remoteIdToIdMap;\n  }\n}\nclass IframeManagerNoop {\n  constructor() {\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  addIframe() {\n  }\n  addLoadListener() {\n  }\n  attachIframe() {\n  }\n}\nclass IframeManager {\n  constructor(options) {\n    this.iframes = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n    this.mutationCb = options.mutationCb;\n    this.wrappedEmit = options.wrappedEmit;\n    this.stylesheetManager = options.stylesheetManager;\n    this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(\n      this.stylesheetManager.styleMirror.generateId.bind(\n        this.stylesheetManager.styleMirror\n      )\n    );\n    this.mirror = options.mirror;\n    if (this.recordCrossOriginIframes) {\n      window.addEventListener(\"message\", this.handleMessage.bind(this));\n    }\n  }\n  addIframe(iframeEl) {\n    this.iframes.set(iframeEl, true);\n    if (iframeEl.contentWindow)\n      this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n  }\n  addLoadListener(cb) {\n    this.loadListener = cb;\n  }\n  attachIframe(iframeEl, childSn) {\n    this.mutationCb({\n      adds: [\n        {\n          parentId: this.mirror.getId(iframeEl),\n          nextId: null,\n          node: childSn\n        }\n      ],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true\n    });\n    if (this.recordCrossOriginIframes)\n      iframeEl.contentWindow?.addEventListener(\n        \"message\",\n        this.handleMessage.bind(this)\n      );\n    this.loadListener?.(iframeEl);\n    const iframeDoc = getIFrameContentDocument(iframeEl);\n    if (iframeDoc && iframeDoc.adoptedStyleSheets && iframeDoc.adoptedStyleSheets.length > 0)\n      this.stylesheetManager.adoptStyleSheets(\n        iframeDoc.adoptedStyleSheets,\n        this.mirror.getId(iframeDoc)\n      );\n  }\n  handleMessage(message) {\n    const crossOriginMessageEvent = message;\n    if (crossOriginMessageEvent.data.type !== \"rrweb\" || // To filter out the rrweb messages which are forwarded by some sites.\n    crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)\n      return;\n    const iframeSourceWindow = message.source;\n    if (!iframeSourceWindow) return;\n    const iframeEl = this.crossOriginIframeMap.get(message.source);\n    if (!iframeEl) return;\n    const transformedEvent = this.transformCrossOriginEvent(\n      iframeEl,\n      crossOriginMessageEvent.data.event\n    );\n    if (transformedEvent)\n      this.wrappedEmit(\n        transformedEvent,\n        crossOriginMessageEvent.data.isCheckout\n      );\n  }\n  transformCrossOriginEvent(iframeEl, e2) {\n    switch (e2.type) {\n      case EventType.FullSnapshot: {\n        this.crossOriginIframeMirror.reset(iframeEl);\n        this.crossOriginIframeStyleMirror.reset(iframeEl);\n        this.replaceIdOnNode(e2.data.node, iframeEl);\n        const rootId = e2.data.node.id;\n        this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n        this.patchRootIdOnNode(e2.data.node, rootId);\n        return {\n          timestamp: e2.timestamp,\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.Mutation,\n            adds: [\n              {\n                parentId: this.mirror.getId(iframeEl),\n                nextId: null,\n                node: e2.data.node\n              }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n          }\n        };\n      }\n      case EventType.Meta:\n      case EventType.Load:\n      case EventType.DomContentLoaded: {\n        return false;\n      }\n      case EventType.Plugin: {\n        return e2;\n      }\n      case EventType.Custom: {\n        this.replaceIds(\n          e2.data.payload,\n          iframeEl,\n          [\"id\", \"parentId\", \"previousId\", \"nextId\"]\n        );\n        return e2;\n      }\n      case EventType.IncrementalSnapshot: {\n        switch (e2.data.source) {\n          case IncrementalSource.Mutation: {\n            e2.data.adds.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\n                \"parentId\",\n                \"nextId\",\n                \"previousId\"\n              ]);\n              this.replaceIdOnNode(n2.node, iframeEl);\n              const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\n              rootId && this.patchRootIdOnNode(n2.node, rootId);\n            });\n            e2.data.removes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"parentId\", \"id\"]);\n            });\n            e2.data.attributes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"id\"]);\n            });\n            e2.data.texts.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"id\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.Drag:\n          case IncrementalSource.TouchMove:\n          case IncrementalSource.MouseMove: {\n            e2.data.positions.forEach((p) => {\n              this.replaceIds(p, iframeEl, [\"id\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.ViewportResize: {\n            return false;\n          }\n          case IncrementalSource.MediaInteraction:\n          case IncrementalSource.MouseInteraction:\n          case IncrementalSource.Scroll:\n          case IncrementalSource.CanvasMutation:\n          case IncrementalSource.Input: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            return e2;\n          }\n          case IncrementalSource.StyleSheetRule:\n          case IncrementalSource.StyleDeclaration: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            this.replaceStyleIds(e2.data, iframeEl, [\"styleId\"]);\n            return e2;\n          }\n          case IncrementalSource.Font: {\n            return e2;\n          }\n          case IncrementalSource.Selection: {\n            e2.data.ranges.forEach((range) => {\n              this.replaceIds(range, iframeEl, [\"start\", \"end\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.AdoptedStyleSheet: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            this.replaceStyleIds(e2.data, iframeEl, [\"styleIds\"]);\n            e2.data.styles?.forEach((style) => {\n              this.replaceStyleIds(style, iframeEl, [\"styleId\"]);\n            });\n            return e2;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  replace(iframeMirror, obj, iframeEl, keys) {\n    for (const key of keys) {\n      if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n      if (Array.isArray(obj[key])) {\n        obj[key] = iframeMirror.getIds(\n          iframeEl,\n          obj[key]\n        );\n      } else {\n        obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n      }\n    }\n    return obj;\n  }\n  replaceIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n  }\n  replaceStyleIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n  }\n  replaceIdOnNode(node, iframeEl) {\n    this.replaceIds(node, iframeEl, [\"id\", \"rootId\"]);\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach((child) => {\n        this.replaceIdOnNode(child, iframeEl);\n      });\n    }\n  }\n  patchRootIdOnNode(node, rootId) {\n    if (node.type !== NodeType$2.Document && !node.rootId) node.rootId = rootId;\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach((child) => {\n        this.patchRootIdOnNode(child, rootId);\n      });\n    }\n  }\n}\nclass ShadowDomManagerNoop {\n  init() {\n  }\n  addShadowRoot() {\n  }\n  observeAttachShadow() {\n  }\n  reset() {\n  }\n}\nclass ShadowDomManager {\n  constructor(options) {\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.restoreHandlers = [];\n    this.mutationCb = options.mutationCb;\n    this.scrollCb = options.scrollCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n    this.init();\n  }\n  init() {\n    this.reset();\n    this.patchAttachShadow(Element, document);\n  }\n  addShadowRoot(shadowRoot, doc) {\n    if (!isNativeShadowDom(shadowRoot)) return;\n    if (this.shadowDoms.has(shadowRoot)) return;\n    this.shadowDoms.add(shadowRoot);\n    this.bypassOptions.canvasManager.addShadowRoot(shadowRoot);\n    const observer = initMutationObserver(\n      {\n        ...this.bypassOptions,\n        doc,\n        mutationCb: this.mutationCb,\n        mirror: this.mirror,\n        shadowDomManager: this\n      },\n      shadowRoot\n    );\n    this.restoreHandlers.push(() => observer.disconnect());\n    this.restoreHandlers.push(\n      initScrollObserver({\n        ...this.bypassOptions,\n        scrollCb: this.scrollCb,\n        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n        // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n        doc: shadowRoot,\n        mirror: this.mirror\n      })\n    );\n    setTimeout$1(() => {\n      if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0)\n        this.bypassOptions.stylesheetManager.adoptStyleSheets(\n          shadowRoot.adoptedStyleSheets,\n          this.mirror.getId(shadowRoot.host)\n        );\n      this.restoreHandlers.push(\n        initAdoptedStyleSheetObserver(\n          {\n            mirror: this.mirror,\n            stylesheetManager: this.bypassOptions.stylesheetManager\n          },\n          shadowRoot\n        )\n      );\n    }, 0);\n  }\n  /**\n   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.\n   */\n  observeAttachShadow(iframeElement) {\n    const iframeDoc = getIFrameContentDocument(iframeElement);\n    const iframeWindow = getIFrameContentWindow(iframeElement);\n    if (!iframeDoc || !iframeWindow) return;\n    this.patchAttachShadow(\n      iframeWindow.Element,\n      iframeDoc\n    );\n  }\n  /**\n   * Patch 'attachShadow' to observe newly added shadow doms.\n   */\n  patchAttachShadow(element, doc) {\n    const manager = this;\n    this.restoreHandlers.push(\n      patch(\n        element.prototype,\n        \"attachShadow\",\n        function(original) {\n          return function(option) {\n            const shadowRoot = original.call(this, option);\n            if (this.shadowRoot && inDom(this))\n              manager.addShadowRoot(this.shadowRoot, doc);\n            return shadowRoot;\n          };\n        }\n      )\n    );\n  }\n  reset() {\n    this.restoreHandlers.forEach((handler) => {\n      try {\n        handler();\n      } catch (e2) {\n      }\n    });\n    this.restoreHandlers = [];\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.bypassOptions.canvasManager.resetShadowRoots();\n  }\n}\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$1 = 0; i$1 < chars.length; i$1++) {\n  lookup[chars.charCodeAt(i$1)] = i$1;\n}\nvar encode = function(arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = \"\";\n  for (i2 = 0; i2 < len; i2 += 3) {\n    base64 += chars[bytes[i2] >> 2];\n    base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];\n    base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];\n    base64 += chars[bytes[i2 + 2] & 63];\n  }\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + \"=\";\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + \"==\";\n  }\n  return base64;\n};\nvar decode = function(base64) {\n  var bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;\n  if (base64[base64.length - 1] === \"=\") {\n    bufferLength--;\n    if (base64[base64.length - 2] === \"=\") {\n      bufferLength--;\n    }\n  }\n  var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n  for (i2 = 0; i2 < len; i2 += 4) {\n    encoded1 = lookup[base64.charCodeAt(i2)];\n    encoded2 = lookup[base64.charCodeAt(i2 + 1)];\n    encoded3 = lookup[base64.charCodeAt(i2 + 2)];\n    encoded4 = lookup[base64.charCodeAt(i2 + 3)];\n    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n  return arraybuffer;\n};\nconst canvasVarMap = /* @__PURE__ */ new Map();\nfunction variableListFor$1(ctx, ctor) {\n  let contextMap = canvasVarMap.get(ctx);\n  if (!contextMap) {\n    contextMap = /* @__PURE__ */ new Map();\n    canvasVarMap.set(ctx, contextMap);\n  }\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n  return contextMap.get(ctor);\n}\nconst saveWebGLVar = (value, win, ctx) => {\n  if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === \"object\"))\n    return;\n  const name = value.constructor.name;\n  const list = variableListFor$1(ctx, name);\n  let index = list.indexOf(value);\n  if (index === -1) {\n    index = list.length;\n    list.push(value);\n  }\n  return index;\n};\nfunction serializeArg(value, win, ctx) {\n  if (value instanceof Array) {\n    return value.map((arg) => serializeArg(arg, win, ctx));\n  } else if (value === null) {\n    return value;\n  } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [Object.values(value)]\n    };\n  } else if (\n    // SharedArrayBuffer disabled on most browsers due to spectre.\n    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer\n    // value instanceof SharedArrayBuffer ||\n    value instanceof ArrayBuffer\n  ) {\n    const name = value.constructor.name;\n    const base64 = encode(value);\n    return {\n      rr_type: name,\n      base64\n    };\n  } else if (value instanceof DataView) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [\n        serializeArg(value.buffer, win, ctx),\n        value.byteOffset,\n        value.byteLength\n      ]\n    };\n  } else if (value instanceof HTMLImageElement) {\n    const name = value.constructor.name;\n    const { src } = value;\n    return {\n      rr_type: name,\n      src\n    };\n  } else if (value instanceof HTMLCanvasElement) {\n    const name = \"HTMLImageElement\";\n    const src = value.toDataURL();\n    return {\n      rr_type: name,\n      src\n    };\n  } else if (value instanceof ImageData) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [serializeArg(value.data, win, ctx), value.width, value.height]\n    };\n  } else if (isInstanceOfWebGLObject(value, win) || typeof value === \"object\") {\n    const name = value.constructor.name;\n    const index = saveWebGLVar(value, win, ctx);\n    return {\n      rr_type: name,\n      index\n    };\n  }\n  return value;\n}\nconst serializeArgs = (args, win, ctx) => {\n  return args.map((arg) => serializeArg(arg, win, ctx));\n};\nconst isInstanceOfWebGLObject = (value, win) => {\n  const webGLConstructorNames = [\n    \"WebGLActiveInfo\",\n    \"WebGLBuffer\",\n    \"WebGLFramebuffer\",\n    \"WebGLProgram\",\n    \"WebGLRenderbuffer\",\n    \"WebGLShader\",\n    \"WebGLShaderPrecisionFormat\",\n    \"WebGLTexture\",\n    \"WebGLUniformLocation\",\n    \"WebGLVertexArrayObject\",\n    // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.\n    \"WebGLVertexArrayObjectOES\"\n  ];\n  const supportedWebGLConstructorNames = webGLConstructorNames.filter(\n    (name) => typeof win[name] === \"function\"\n  );\n  return Boolean(\n    supportedWebGLConstructorNames.find(\n      (name) => value instanceof win[name]\n    )\n  );\n};\nfunction initCanvas2DMutationObserver(cb, win, blockClass2, blockSelector, unblockSelector) {\n  const handlers = [];\n  const props2D = Object.getOwnPropertyNames(\n    win.CanvasRenderingContext2D.prototype\n  );\n  for (const prop of props2D) {\n    try {\n      if (typeof win.CanvasRenderingContext2D.prototype[prop] !== \"function\") {\n        continue;\n      }\n      const restoreHandler = patch(\n        win.CanvasRenderingContext2D.prototype,\n        prop,\n        function(original) {\n          return function(...args) {\n            if (!isBlocked(\n              this.canvas,\n              blockClass2,\n              blockSelector,\n              unblockSelector,\n              true\n            )) {\n              setTimeout$1(() => {\n                const recordArgs = serializeArgs(args, win, this);\n                cb(this.canvas, {\n                  type: CanvasContext[\"2D\"],\n                  property: prop,\n                  args: recordArgs\n                });\n              }, 0);\n            }\n            return original.apply(this, args);\n          };\n        }\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter(\n        win.CanvasRenderingContext2D.prototype,\n        prop,\n        {\n          set(v2) {\n            cb(this.canvas, {\n              type: CanvasContext[\"2D\"],\n              property: prop,\n              args: [v2],\n              setter: true\n            });\n          }\n        }\n      );\n      handlers.push(hookHandler);\n    }\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nfunction getNormalizedContextName(contextType) {\n  return contextType === \"experimental-webgl\" ? \"webgl\" : contextType;\n}\nfunction initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, setPreserveDrawingBufferToTrue) {\n  const handlers = [];\n  try {\n    const restoreHandler = patch(\n      win.HTMLCanvasElement.prototype,\n      \"getContext\",\n      function(original) {\n        return function(contextType, ...args) {\n          if (!isBlocked(this, blockClass, blockSelector, unblockSelector, true)) {\n            const ctxName = getNormalizedContextName(contextType);\n            if (!(\"__context\" in this)) this.__context = ctxName;\n            if (setPreserveDrawingBufferToTrue && [\"webgl\", \"webgl2\"].includes(ctxName)) {\n              if (args[0] && typeof args[0] === \"object\") {\n                const contextAttributes = args[0];\n                if (!contextAttributes.preserveDrawingBuffer) {\n                  contextAttributes.preserveDrawingBuffer = true;\n                }\n              } else {\n                args.splice(0, 1, {\n                  preserveDrawingBuffer: true\n                });\n              }\n            }\n          }\n          return original.apply(this, [contextType, ...args]);\n        };\n      }\n    );\n    handlers.push(restoreHandler);\n  } catch {\n    console.error(\"failed to patch HTMLCanvasElement.prototype.getContext\");\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nfunction patchGLPrototype(prototype, type, cb, blockClass2, blockSelector, unblockSelector, _mirror2, win) {\n  const handlers = [];\n  const props = Object.getOwnPropertyNames(prototype);\n  for (const prop of props) {\n    if (\n      //prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky\n      [\n        \"isContextLost\",\n        \"canvas\",\n        \"drawingBufferWidth\",\n        \"drawingBufferHeight\"\n      ].includes(prop)\n    ) {\n      continue;\n    }\n    try {\n      if (typeof prototype[prop] !== \"function\") {\n        continue;\n      }\n      const restoreHandler = patch(\n        prototype,\n        prop,\n        function(original) {\n          return function(...args) {\n            const result = original.apply(this, args);\n            saveWebGLVar(result, win, this);\n            if (\"tagName\" in this.canvas && !isBlocked(\n              this.canvas,\n              blockClass2,\n              blockSelector,\n              unblockSelector,\n              true\n            )) {\n              const recordArgs = serializeArgs(args, win, this);\n              const mutation = {\n                type,\n                property: prop,\n                args: recordArgs\n              };\n              cb(this.canvas, mutation);\n            }\n            return result;\n          };\n        }\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter(prototype, prop, {\n        set(v2) {\n          cb(this.canvas, {\n            type,\n            property: prop,\n            args: [v2],\n            setter: true\n          });\n        }\n      });\n      handlers.push(hookHandler);\n    }\n  }\n  return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass2, blockSelector, unblockSelector, mirror2) {\n  const handlers = [];\n  handlers.push(\n    ...patchGLPrototype(\n      win.WebGLRenderingContext.prototype,\n      CanvasContext.WebGL,\n      cb,\n      blockClass2,\n      blockSelector,\n      unblockSelector,\n      mirror2,\n      win\n    )\n  );\n  if (typeof win.WebGL2RenderingContext !== \"undefined\") {\n    handlers.push(\n      ...patchGLPrototype(\n        win.WebGL2RenderingContext.prototype,\n        CanvasContext.WebGL2,\n        cb,\n        blockClass2,\n        blockSelector,\n        unblockSelector,\n        mirror2,\n        win\n      )\n    );\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nconst r$1 = `for(var e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",t=\"undefined\"==typeof Uint8Array?[]:new Uint8Array(256),a=0;a<64;a++)t[e.charCodeAt(a)]=a;var n=function(t){var a,n=new Uint8Array(t),r=n.length,s=\"\";for(a=0;a<r;a+=3)s+=e[n[a]>>2],s+=e[(3&n[a])<<4|n[a+1]>>4],s+=e[(15&n[a+1])<<2|n[a+2]>>6],s+=e[63&n[a+2]];return r%3==2?s=s.substring(0,s.length-1)+\"=\":r%3==1&&(s=s.substring(0,s.length-2)+\"==\"),s};const r=new Map,s=new Map;const i=self;i.onmessage=async function(e){if(!(\"OffscreenCanvas\"in globalThis))return i.postMessage({id:e.data.id});{const{id:t,bitmap:a,width:o,height:f,maxCanvasSize:c,dataURLOptions:g}=e.data,u=async function(e,t,a){const r=e+\"-\"+t;if(\"OffscreenCanvas\"in globalThis){if(s.has(r))return s.get(r);const i=new OffscreenCanvas(e,t);i.getContext(\"2d\");const o=await i.convertToBlob(a),f=await o.arrayBuffer(),c=n(f);return s.set(r,c),c}return\"\"}(o,f,g),[h,d]=function(e,t,a){if(!a)return[e,t];const[n,r]=a;if(e<=n&&t<=r)return[e,t];let s=e,i=t;return s>n&&(i=Math.floor(n*t/e),s=n),i>r&&(s=Math.floor(r*e/t),i=r),[s,i]}(o,f,c),l=new OffscreenCanvas(h,d),w=l.getContext(\"bitmaprenderer\"),p=h===o&&d===f?a:await createImageBitmap(a,{resizeWidth:h,resizeHeight:d,resizeQuality:\"low\"});w.transferFromImageBitmap(p),a.close();const y=await l.convertToBlob(g),v=y.type,b=await y.arrayBuffer(),m=n(b);if(p.close(),!r.has(t)&&await u===m)return r.set(t,m),i.postMessage({id:t});if(r.get(t)===m)return i.postMessage({id:t});i.postMessage({id:t,type:v,base64:m,width:o,height:f}),r.set(t,m)}};`;\nfunction t$1() {\n  const t2 = new Blob([r$1]);\n  return URL.createObjectURL(t2);\n}\nclass CanvasManagerNoop {\n  reset() {\n  }\n  freeze() {\n  }\n  unfreeze() {\n  }\n  lock() {\n  }\n  unlock() {\n  }\n  snapshot() {\n  }\n  addWindow() {\n  }\n  addShadowRoot() {\n  }\n  resetShadowRoots() {\n  }\n}\nclass CanvasManager {\n  constructor(options) {\n    this.pendingCanvasMutations = /* @__PURE__ */ new Map();\n    this.rafStamps = { latestId: 0, invokeId: null };\n    this.shadowDoms = /* @__PURE__ */ new Set();\n    this.windowsSet = /* @__PURE__ */ new WeakSet();\n    this.windows = [];\n    this.restoreHandlers = [];\n    this.frozen = false;\n    this.locked = false;\n    this.snapshotInProgressMap = /* @__PURE__ */ new Map();\n    this.worker = null;\n    this.lastSnapshotTime = 0;\n    this.processMutation = (target, mutation) => {\n      const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;\n      if (newFrame || !this.rafStamps.invokeId)\n        this.rafStamps.invokeId = this.rafStamps.latestId;\n      if (!this.pendingCanvasMutations.has(target)) {\n        this.pendingCanvasMutations.set(target, []);\n      }\n      this.pendingCanvasMutations.get(target).push(mutation);\n    };\n    const {\n      sampling = \"all\",\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maxCanvasSize,\n      recordCanvas,\n      dataURLOptions,\n      errorHandler: errorHandler2\n    } = options;\n    this.mutationCb = options.mutationCb;\n    this.mirror = options.mirror;\n    this.options = options;\n    if (errorHandler2) {\n      registerErrorHandler(errorHandler2);\n    }\n    if (recordCanvas && typeof sampling === \"number\" || options.enableManualSnapshot) {\n      this.worker = this.initFPSWorker();\n    }\n    this.addWindow(win);\n    if (options.enableManualSnapshot) {\n      return;\n    }\n    callbackWrapper(() => {\n      if (recordCanvas && sampling === \"all\") {\n        this.startRAFTimestamping();\n        this.startPendingCanvasMutationFlusher();\n      }\n      if (recordCanvas && typeof sampling === \"number\") {\n        this.initCanvasFPSObserver(\n          sampling,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          maxCanvasSize,\n          {\n            dataURLOptions\n          }\n        );\n      }\n    })();\n  }\n  reset() {\n    this.pendingCanvasMutations.clear();\n    this.restoreHandlers.forEach((handler) => {\n      try {\n        handler();\n      } catch (e2) {\n      }\n    });\n    this.restoreHandlers = [];\n    this.windowsSet = /* @__PURE__ */ new WeakSet();\n    this.windows = [];\n    this.shadowDoms = /* @__PURE__ */ new Set();\n    this.worker?.terminate();\n    this.worker = null;\n    this.snapshotInProgressMap = /* @__PURE__ */ new Map();\n  }\n  freeze() {\n    this.frozen = true;\n  }\n  unfreeze() {\n    this.frozen = false;\n  }\n  lock() {\n    this.locked = true;\n  }\n  unlock() {\n    this.locked = false;\n  }\n  addWindow(win) {\n    const {\n      sampling = \"all\",\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      recordCanvas,\n      enableManualSnapshot\n    } = this.options;\n    if (this.windowsSet.has(win)) return;\n    if (enableManualSnapshot) {\n      this.windowsSet.add(win);\n      this.windows.push(new WeakRef(win));\n      return;\n    }\n    callbackWrapper(() => {\n      if (recordCanvas && sampling === \"all\") {\n        this.initCanvasMutationObserver(\n          win,\n          blockClass,\n          blockSelector,\n          unblockSelector\n        );\n      }\n      if (recordCanvas && typeof sampling === \"number\") {\n        const canvasContextReset = initCanvasContextObserver(\n          win,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        );\n        this.restoreHandlers.push(() => {\n          canvasContextReset();\n        });\n      }\n    })();\n    this.windowsSet.add(win);\n    this.windows.push(new WeakRef(win));\n  }\n  addShadowRoot(shadowRoot) {\n    this.shadowDoms.add(new WeakRef(shadowRoot));\n  }\n  resetShadowRoots() {\n    this.shadowDoms = /* @__PURE__ */ new Set();\n  }\n  initFPSWorker() {\n    const worker = new Worker(t$1());\n    worker.onmessage = (e2) => {\n      const data = e2.data;\n      const { id } = data;\n      this.snapshotInProgressMap.set(id, false);\n      if (!(\"base64\" in data)) return;\n      const { base64, type, width, height } = data;\n      this.mutationCb({\n        id,\n        type: CanvasContext[\"2D\"],\n        commands: [\n          {\n            property: \"clearRect\",\n            // wipe canvas\n            args: [0, 0, width, height]\n          },\n          {\n            property: \"drawImage\",\n            // draws (semi-transparent) image\n            args: [\n              {\n                rr_type: \"ImageBitmap\",\n                args: [\n                  {\n                    rr_type: \"Blob\",\n                    data: [{ rr_type: \"ArrayBuffer\", base64 }],\n                    type\n                  }\n                ]\n              },\n              0,\n              0,\n              // The below args are needed if we enforce a max size, we want to\n              // retain the original size when drawing the image (which should be smaller)\n              width,\n              height\n            ]\n          }\n        ]\n      });\n    };\n    return worker;\n  }\n  initCanvasFPSObserver(fps, blockClass, blockSelector, unblockSelector, maxCanvasSize, options) {\n    const rafId = this.takeSnapshot(\n      false,\n      fps,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maxCanvasSize,\n      options.dataURLOptions\n    );\n    this.restoreHandlers.push(() => {\n      cancelAnimationFrame(rafId);\n    });\n  }\n  initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector) {\n    const canvasContextReset = initCanvasContextObserver(\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      false\n    );\n    const canvas2DReset = initCanvas2DMutationObserver(\n      this.processMutation.bind(this),\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector\n    );\n    const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(\n      this.processMutation.bind(this),\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      this.mirror\n    );\n    this.restoreHandlers.push(() => {\n      canvasContextReset();\n      canvas2DReset();\n      canvasWebGL1and2Reset();\n    });\n  }\n  snapshot(canvasElement) {\n    const { options } = this;\n    const rafId = this.takeSnapshot(\n      true,\n      options.sampling === \"all\" ? 2 : options.sampling || 2,\n      options.blockClass,\n      options.blockSelector,\n      options.unblockSelector,\n      options.maxCanvasSize,\n      options.dataURLOptions,\n      canvasElement\n    );\n    this.restoreHandlers.push(() => {\n      cancelAnimationFrame(rafId);\n    });\n  }\n  takeSnapshot(isManualSnapshot, fps, blockClass, blockSelector, unblockSelector, maxCanvasSize, dataURLOptions, canvasElement) {\n    const timeBetweenSnapshots = 1e3 / fps;\n    let rafId;\n    const getCanvas = (canvasElement2) => {\n      if (canvasElement2) {\n        return [canvasElement2];\n      }\n      const matchedCanvas = [];\n      const searchCanvas = (root) => {\n        root.querySelectorAll(\"canvas\").forEach((canvas) => {\n          if (!isBlocked(canvas, blockClass, blockSelector, unblockSelector, true)) {\n            matchedCanvas.push(canvas);\n          }\n        });\n      };\n      for (const item of this.windows) {\n        const window2 = item.deref();\n        let _document;\n        try {\n          _document = window2 && window2.document;\n        } catch {\n        }\n        if (_document) {\n          searchCanvas(_document);\n        }\n      }\n      for (const item of this.shadowDoms) {\n        const shadowRoot = item.deref();\n        if (shadowRoot) {\n          searchCanvas(shadowRoot);\n        }\n      }\n      return matchedCanvas;\n    };\n    const takeCanvasSnapshots = (timestamp) => {\n      if (!this.windows.length) {\n        return;\n      }\n      if (this.lastSnapshotTime && timestamp - this.lastSnapshotTime < timeBetweenSnapshots) {\n        rafId = onRequestAnimationFrame(takeCanvasSnapshots);\n        return;\n      }\n      this.lastSnapshotTime = timestamp;\n      getCanvas(canvasElement).forEach((canvas) => {\n        if (!this.mirror.hasNode(canvas)) {\n          return;\n        }\n        const id = this.mirror.getId(canvas);\n        if (this.snapshotInProgressMap.get(id)) return;\n        if (!canvas.width || !canvas.height) return;\n        this.snapshotInProgressMap.set(id, true);\n        if (!isManualSnapshot && [\"webgl\", \"webgl2\"].includes(canvas.__context)) {\n          const context = canvas.getContext(canvas.__context);\n          if (context?.getContextAttributes()?.preserveDrawingBuffer === false) {\n            context.clear(context.COLOR_BUFFER_BIT);\n          }\n        }\n        createImageBitmap(canvas).then((bitmap) => {\n          this.worker?.postMessage(\n            {\n              id,\n              bitmap,\n              width: canvas.width,\n              height: canvas.height,\n              dataURLOptions,\n              maxCanvasSize\n            },\n            [bitmap]\n          );\n        }).catch((error) => {\n          callbackWrapper(() => {\n            throw error;\n          })();\n        });\n      });\n      if (!isManualSnapshot) {\n        rafId = onRequestAnimationFrame(takeCanvasSnapshots);\n      }\n    };\n    rafId = onRequestAnimationFrame(takeCanvasSnapshots);\n    return rafId;\n  }\n  startPendingCanvasMutationFlusher() {\n    onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  startRAFTimestamping() {\n    const setLatestRAFTimestamp = (timestamp) => {\n      this.rafStamps.latestId = timestamp;\n      onRequestAnimationFrame(setLatestRAFTimestamp);\n    };\n    onRequestAnimationFrame(setLatestRAFTimestamp);\n  }\n  flushPendingCanvasMutations() {\n    this.pendingCanvasMutations.forEach(\n      (_values, canvas) => {\n        const id = this.mirror.getId(canvas);\n        this.flushPendingCanvasMutationFor(canvas, id);\n      }\n    );\n    onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  flushPendingCanvasMutationFor(canvas, id) {\n    if (this.frozen || this.locked) {\n      return;\n    }\n    const valuesWithType = this.pendingCanvasMutations.get(canvas);\n    if (!valuesWithType || id === -1) return;\n    const values = valuesWithType.map((value) => {\n      const { type: type2, ...rest } = value;\n      return rest;\n    });\n    const { type } = valuesWithType[0];\n    this.mutationCb({ id, type, commands: values });\n    this.pendingCanvasMutations.delete(canvas);\n  }\n}\nclass StylesheetManager {\n  constructor(options) {\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n    this.styleMirror = new StyleSheetMirror();\n    this.mutationCb = options.mutationCb;\n    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n  }\n  attachLinkElement(linkEl, childSn) {\n    if (\"_cssText\" in childSn.attributes)\n      this.mutationCb({\n        adds: [],\n        removes: [],\n        texts: [],\n        attributes: [\n          {\n            id: childSn.id,\n            attributes: childSn.attributes\n          }\n        ]\n      });\n    this.trackLinkElement(linkEl);\n  }\n  trackLinkElement(linkEl) {\n    if (this.trackedLinkElements.has(linkEl)) return;\n    this.trackedLinkElements.add(linkEl);\n    this.trackStylesheetInLinkElement(linkEl);\n  }\n  adoptStyleSheets(sheets, hostId) {\n    if (sheets.length === 0) return;\n    const adoptedStyleSheetData = {\n      id: hostId,\n      styleIds: []\n    };\n    const styles = [];\n    for (const sheet of sheets) {\n      let styleId;\n      if (!this.styleMirror.has(sheet)) {\n        styleId = this.styleMirror.add(sheet);\n        styles.push({\n          styleId,\n          rules: Array.from(sheet.rules || CSSRule, (r2, index) => ({\n            rule: stringifyRule(r2),\n            index\n          }))\n        });\n      } else styleId = this.styleMirror.getId(sheet);\n      adoptedStyleSheetData.styleIds.push(styleId);\n    }\n    if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n    this.adoptedStyleSheetCb(adoptedStyleSheetData);\n  }\n  reset() {\n    this.styleMirror.reset();\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n  }\n  // TODO: take snapshot on stylesheet reload by applying event listener\n  trackStylesheetInLinkElement(_linkEl) {\n  }\n}\nclass ProcessedNodeManager {\n  constructor() {\n    this.nodeMap = /* @__PURE__ */ new WeakMap();\n    this.active = false;\n  }\n  inOtherBuffer(node, thisBuffer) {\n    const buffers = this.nodeMap.get(node);\n    return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);\n  }\n  add(node, buffer) {\n    if (!this.active) {\n      this.active = true;\n      onRequestAnimationFrame(() => {\n        this.nodeMap = /* @__PURE__ */ new WeakMap();\n        this.active = false;\n      });\n    }\n    this.nodeMap.set(node, (this.nodeMap.get(node) || /* @__PURE__ */ new Set()).add(buffer));\n  }\n  destroy() {\n  }\n}\nlet wrappedEmit;\nlet _wrappedEmit;\nlet _takeFullSnapshot;\ntry {\n  if (Array.from([1], (x) => x * 2)[0] !== 2) {\n    const cleanFrame = document.createElement(\"iframe\");\n    document.body.appendChild(cleanFrame);\n    Array.from = cleanFrame.contentWindow?.Array.from || Array.from;\n    document.body.removeChild(cleanFrame);\n  }\n} catch (err) {\n  console.debug(\"Unable to override Array.from\", err);\n}\nconst mirror = createMirror$2();\nfunction record(options = {}) {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    ignoreClass = \"rr-ignore\",\n    ignoreSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskAttributeFn,\n    maskInputFn,\n    maskTextFn,\n    maxCanvasSize = null,\n    packFn,\n    sampling = {},\n    dataURLOptions = {},\n    mousemoveWait,\n    recordDOM = true,\n    recordCanvas = false,\n    recordCrossOriginIframes = false,\n    recordAfter = options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\",\n    userTriggeredOnInput = false,\n    collectFonts = false,\n    inlineImages = false,\n    plugins,\n    keepIframeSrcFn = () => false,\n    ignoreCSSAttributes = /* @__PURE__ */ new Set([]),\n    errorHandler: errorHandler2,\n    onMutation,\n    getCanvasManager\n  } = options;\n  registerErrorHandler(errorHandler2);\n  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n  let passEmitsToParent = false;\n  if (!inEmittingFrame) {\n    try {\n      if (window.parent.document) {\n        passEmitsToParent = false;\n      }\n    } catch (e2) {\n      passEmitsToParent = true;\n    }\n  }\n  if (inEmittingFrame && !emit) {\n    throw new Error(\"emit function is required\");\n  }\n  if (!inEmittingFrame && !passEmitsToParent) {\n    return () => {\n    };\n  }\n  if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n    sampling.mousemove = mousemoveWait;\n  }\n  mirror.reset();\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true,\n    radio: true,\n    checkbox: true\n  } : _maskInputOptions !== void 0 ? _maskInputOptions : {};\n  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaVerification: true,\n    // the following are off for slimDOMOptions === true,\n    // as they destroy some (hidden) info:\n    headMetaAuthorship: _slimDOMOptions === \"all\",\n    headMetaDescKeywords: _slimDOMOptions === \"all\"\n  } : _slimDOMOptions ? _slimDOMOptions : {};\n  polyfill$1();\n  let lastFullSnapshotEvent;\n  let incrementalSnapshotCount = 0;\n  const eventProcessor = (e2) => {\n    for (const plugin of plugins || []) {\n      if (plugin.eventProcessor) {\n        e2 = plugin.eventProcessor(e2);\n      }\n    }\n    if (packFn && // Disable packing events which will be emitted to parent frames.\n    !passEmitsToParent) {\n      e2 = packFn(e2);\n    }\n    return e2;\n  };\n  wrappedEmit = (r2, isCheckout) => {\n    const e2 = r2;\n    e2.timestamp = nowTimestamp();\n    if (mutationBuffers[0]?.isFrozen() && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n      mutationBuffers.forEach((buf) => buf.unfreeze());\n    }\n    if (inEmittingFrame) {\n      emit?.(eventProcessor(e2), isCheckout);\n    } else if (passEmitsToParent) {\n      const message = {\n        type: \"rrweb\",\n        event: eventProcessor(e2),\n        origin: window.location.origin,\n        isCheckout\n      };\n      window.parent.postMessage(message, \"*\");\n    }\n    if (e2.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e2;\n      incrementalSnapshotCount = 0;\n    } else if (e2.type === EventType.IncrementalSnapshot) {\n      if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n        return;\n      }\n      incrementalSnapshotCount++;\n      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime = checkoutEveryNms && lastFullSnapshotEvent && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot2(true);\n      }\n    }\n  };\n  _wrappedEmit = wrappedEmit;\n  const wrappedMutationEmit = (m) => {\n    wrappedEmit({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.Mutation,\n        ...m\n      }\n    });\n  };\n  const wrappedScrollEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.Scroll,\n      ...p\n    }\n  });\n  const wrappedCanvasMutationEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.CanvasMutation,\n      ...p\n    }\n  });\n  const wrappedAdoptedStyleSheetEmit = (a2) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.AdoptedStyleSheet,\n      ...a2\n    }\n  });\n  const stylesheetManager = new StylesheetManager({\n    mutationCb: wrappedMutationEmit,\n    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n  });\n  const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === \"boolean\" && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop() : new IframeManager({\n    mirror,\n    mutationCb: wrappedMutationEmit,\n    stylesheetManager,\n    recordCrossOriginIframes,\n    wrappedEmit\n  });\n  for (const plugin of plugins || []) {\n    if (plugin.getMirror)\n      plugin.getMirror({\n        nodeMirror: mirror,\n        crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n        crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n      });\n  }\n  const processedNodeManager = new ProcessedNodeManager();\n  const canvasManager = _getCanvasManager(\n    getCanvasManager,\n    {\n      mirror,\n      win: window,\n      mutationCb: (p) => wrappedEmit({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.CanvasMutation,\n          ...p\n        }\n      }),\n      recordCanvas,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maxCanvasSize,\n      sampling: sampling[\"canvas\"],\n      dataURLOptions,\n      errorHandler: errorHandler2\n    }\n  );\n  const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === \"boolean\" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop() : new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    scrollCb: wrappedScrollEmit,\n    bypassOptions: {\n      onMutation,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      dataURLOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      recordCanvas,\n      inlineImages,\n      sampling,\n      slimDOMOptions,\n      iframeManager,\n      stylesheetManager,\n      canvasManager,\n      keepIframeSrcFn,\n      processedNodeManager\n    },\n    mirror\n  });\n  const takeFullSnapshot2 = (isCheckout = false) => {\n    if (!recordDOM) {\n      return;\n    }\n    wrappedEmit(\n      {\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight()\n        }\n      },\n      isCheckout\n    );\n    stylesheetManager.reset();\n    shadowDomManager.init();\n    mutationBuffers.forEach((buf) => buf.lock());\n    const node = snapshot(document, {\n      mirror,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskAttributeFn,\n      maskInputFn,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      dataURLOptions,\n      recordCanvas,\n      inlineImages,\n      onSerialize: (n2) => {\n        if (isSerializedIframe(n2, mirror)) {\n          iframeManager.addIframe(n2);\n        }\n        if (isSerializedStylesheet(n2, mirror)) {\n          stylesheetManager.trackLinkElement(n2);\n        }\n        if (hasShadowRoot(n2)) {\n          shadowDomManager.addShadowRoot(n2.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n        if (iframe.contentWindow) {\n          canvasManager.addWindow(iframe.contentWindow);\n        }\n        shadowDomManager.observeAttachShadow(iframe);\n      },\n      onStylesheetLoad: (linkEl, childSn) => {\n        stylesheetManager.attachLinkElement(linkEl, childSn);\n      },\n      keepIframeSrcFn\n    });\n    if (!node) {\n      return console.warn(\"Failed to snapshot the document\");\n    }\n    wrappedEmit({\n      type: EventType.FullSnapshot,\n      data: {\n        node,\n        initialOffset: getWindowScroll(window)\n      }\n    });\n    mutationBuffers.forEach((buf) => buf.unlock());\n    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)\n      stylesheetManager.adoptStyleSheets(\n        document.adoptedStyleSheets,\n        mirror.getId(document)\n      );\n  };\n  _takeFullSnapshot = takeFullSnapshot2;\n  try {\n    const handlers = [];\n    const observe = (doc) => {\n      return callbackWrapper(initObservers)(\n        {\n          onMutation,\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source,\n              positions\n            }\n          }),\n          mouseInteractionCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MouseInteraction,\n              ...d\n            }\n          }),\n          scrollCb: wrappedScrollEmit,\n          viewportResizeCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.ViewportResize,\n              ...d\n            }\n          }),\n          inputCb: (v2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Input,\n              ...v2\n            }\n          }),\n          mediaInteractionCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MediaInteraction,\n              ...p\n            }\n          }),\n          styleSheetRuleCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleSheetRule,\n              ...r2\n            }\n          }),\n          styleDeclarationCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleDeclaration,\n              ...r2\n            }\n          }),\n          canvasMutationCb: wrappedCanvasMutationEmit,\n          fontCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Font,\n              ...p\n            }\n          }),\n          selectionCb: (p) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.Selection,\n                ...p\n              }\n            });\n          },\n          customElementCb: (c2) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.CustomElement,\n                ...c2\n              }\n            });\n          },\n          blockClass,\n          ignoreClass,\n          ignoreSelector,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordDOM,\n          recordCanvas,\n          inlineImages,\n          userTriggeredOnInput,\n          collectFonts,\n          doc,\n          maskAttributeFn,\n          maskInputFn,\n          maskTextFn,\n          keepIframeSrcFn,\n          blockSelector,\n          unblockSelector,\n          slimDOMOptions,\n          dataURLOptions,\n          mirror,\n          iframeManager,\n          stylesheetManager,\n          shadowDomManager,\n          processedNodeManager,\n          canvasManager,\n          ignoreCSSAttributes,\n          plugins: plugins?.filter((p) => p.observer)?.map((p) => ({\n            observer: p.observer,\n            options: p.options,\n            callback: (payload) => wrappedEmit({\n              type: EventType.Plugin,\n              data: {\n                plugin: p.name,\n                payload\n              }\n            })\n          })) || []\n        },\n        {}\n      );\n    };\n    iframeManager.addLoadListener((iframeEl) => {\n      try {\n        handlers.push(observe(iframeEl.contentDocument));\n      } catch (error) {\n        console.warn(error);\n      }\n    });\n    const init = () => {\n      takeFullSnapshot2();\n      handlers.push(observe(document));\n    };\n    if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n      init();\n    } else {\n      handlers.push(\n        on(\"DOMContentLoaded\", () => {\n          wrappedEmit({\n            type: EventType.DomContentLoaded,\n            data: {}\n          });\n          if (recordAfter === \"DOMContentLoaded\") init();\n        })\n      );\n      handlers.push(\n        on(\n          \"load\",\n          () => {\n            wrappedEmit({\n              type: EventType.Load,\n              data: {}\n            });\n            if (recordAfter === \"load\") init();\n          },\n          window\n        )\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n      processedNodeManager.destroy();\n      _takeFullSnapshot = void 0;\n      unregisterErrorHandler();\n    };\n  } catch (error) {\n    console.warn(error);\n  }\n}\nfunction addCustomEvent(tag, payload) {\n  if (!_wrappedEmit) {\n    throw new Error(\"please add custom event after start recording\");\n  }\n  wrappedEmit({\n    type: EventType.Custom,\n    data: {\n      tag,\n      payload\n    }\n  });\n}\nfunction freezePage() {\n  mutationBuffers.forEach((buf) => buf.freeze());\n}\nfunction takeFullSnapshot(isCheckout) {\n  if (!_takeFullSnapshot) {\n    throw new Error(\"please take full snapshot after start recording\");\n  }\n  _takeFullSnapshot(isCheckout);\n}\nrecord.mirror = mirror;\nrecord.takeFullSnapshot = takeFullSnapshot;\nfunction _getCanvasManager(getCanvasManagerFn, options) {\n  try {\n    return getCanvasManagerFn ? getCanvasManagerFn(options) : new CanvasManagerNoop();\n  } catch {\n    console.warn(\"Unable to initialize CanvasManager\");\n    return new CanvasManagerNoop();\n  }\n}\nfunction mitt$1(n2) {\n  return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t2, e2) {\n    var i2 = n2.get(t2);\n    i2 ? i2.push(e2) : n2.set(t2, [e2]);\n  }, off: function(t2, e2) {\n    var i2 = n2.get(t2);\n    i2 && (e2 ? i2.splice(i2.indexOf(e2) >>> 0, 1) : n2.set(t2, []));\n  }, emit: function(t2, e2) {\n    var i2 = n2.get(t2);\n    i2 && i2.slice().map(function(n3) {\n      n3(e2);\n    }), (i2 = n2.get(\"*\")) && i2.slice().map(function(n3) {\n      n3(t2, e2);\n    });\n  } };\n}\nconst mittProxy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: mitt$1\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction polyfill(w = window, d = document) {\n  if (\"scrollBehavior\" in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n    return;\n  }\n  const Element2 = w.HTMLElement || w.Element;\n  const SCROLL_TIME = 468;\n  const original = {\n    scroll: w.scroll || w.scrollTo,\n    scrollBy: w.scrollBy,\n    elementScroll: Element2.prototype.scroll || scrollElement,\n    scrollIntoView: Element2.prototype.scrollIntoView\n  };\n  const now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n  function isMicrosoftBrowser(userAgent) {\n    const userAgentPatterns = [\"MSIE \", \"Trident/\", \"Edge/\"];\n    return new RegExp(userAgentPatterns.join(\"|\")).test(userAgent);\n  }\n  const ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n  function scrollElement(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n  }\n  function ease(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n  function shouldBailOut(firstArg) {\n    if (firstArg === null || typeof firstArg !== \"object\" || firstArg.behavior === void 0 || firstArg.behavior === \"auto\" || firstArg.behavior === \"instant\") {\n      return true;\n    }\n    if (typeof firstArg === \"object\" && firstArg.behavior === \"smooth\") {\n      return false;\n    }\n    throw new TypeError(\n      \"behavior member of ScrollOptions \" + firstArg.behavior + \" is not a valid value for enumeration ScrollBehavior.\"\n    );\n  }\n  function hasScrollableSpace(el, axis) {\n    if (axis === \"Y\") {\n      return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n    }\n    if (axis === \"X\") {\n      return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n    }\n  }\n  function canOverflow(el, axis) {\n    const overflowValue = w.getComputedStyle(el, null)[\"overflow\" + axis];\n    return overflowValue === \"auto\" || overflowValue === \"scroll\";\n  }\n  function isScrollable(el) {\n    const isScrollableY = hasScrollableSpace(el, \"Y\") && canOverflow(el, \"Y\");\n    const isScrollableX = hasScrollableSpace(el, \"X\") && canOverflow(el, \"X\");\n    return isScrollableY || isScrollableX;\n  }\n  function findScrollableParent(el) {\n    while (el !== d.body && isScrollable(el) === false) {\n      el = el.parentNode || el.host;\n    }\n    return el;\n  }\n  function step(context) {\n    const time = now();\n    let value;\n    let currentX;\n    let currentY;\n    let elapsed = (time - context.startTime) / SCROLL_TIME;\n    elapsed = elapsed > 1 ? 1 : elapsed;\n    value = ease(elapsed);\n    currentX = context.startX + (context.x - context.startX) * value;\n    currentY = context.startY + (context.y - context.startY) * value;\n    context.method.call(context.scrollable, currentX, currentY);\n    if (currentX !== context.x || currentY !== context.y) {\n      w.requestAnimationFrame(step.bind(w, context));\n    }\n  }\n  function smoothScroll(el, x, y) {\n    let scrollable;\n    let startX;\n    let startY;\n    let method;\n    const startTime = now();\n    if (el === d.body) {\n      scrollable = w;\n      startX = w.scrollX || w.pageXOffset;\n      startY = w.scrollY || w.pageYOffset;\n      method = original.scroll;\n    } else {\n      scrollable = el;\n      startX = el.scrollLeft;\n      startY = el.scrollTop;\n      method = scrollElement;\n    }\n    step({\n      scrollable,\n      method,\n      startTime,\n      startX,\n      startY,\n      x,\n      y\n    });\n  }\n  w.scroll = w.scrollTo = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scroll.call(\n        w,\n        arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : w.scrollX || w.pageXOffset,\n        // use top prop, second argument if present or fallback to scrollY\n        arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : w.scrollY || w.pageYOffset\n      );\n      return;\n    }\n    smoothScroll.call(\n      w,\n      d.body,\n      arguments[0].left !== void 0 ? ~~arguments[0].left : w.scrollX || w.pageXOffset,\n      arguments[0].top !== void 0 ? ~~arguments[0].top : w.scrollY || w.pageYOffset\n    );\n  };\n  w.scrollBy = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0])) {\n      original.scrollBy.call(\n        w,\n        arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : 0,\n        arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : 0\n      );\n      return;\n    }\n    smoothScroll.call(\n      w,\n      d.body,\n      ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n      ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n    );\n  };\n  Element2.prototype.scroll = Element2.prototype.scrollTo = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0]) === true) {\n      if (typeof arguments[0] === \"number\" && arguments[1] === void 0) {\n        throw new SyntaxError(\"Value could not be converted\");\n      }\n      original.elementScroll.call(\n        this,\n        // use left prop, first number argument or fallback to scrollLeft\n        arguments[0].left !== void 0 ? ~~arguments[0].left : typeof arguments[0] !== \"object\" ? ~~arguments[0] : this.scrollLeft,\n        // use top prop, second argument or fallback to scrollTop\n        arguments[0].top !== void 0 ? ~~arguments[0].top : arguments[1] !== void 0 ? ~~arguments[1] : this.scrollTop\n      );\n      return;\n    }\n    const left = arguments[0].left;\n    const top = arguments[0].top;\n    smoothScroll.call(\n      this,\n      this,\n      typeof left === \"undefined\" ? this.scrollLeft : ~~left,\n      typeof top === \"undefined\" ? this.scrollTop : ~~top\n    );\n  };\n  Element2.prototype.scrollBy = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0]) === true) {\n      original.elementScroll.call(\n        this,\n        arguments[0].left !== void 0 ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft,\n        arguments[0].top !== void 0 ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop\n      );\n      return;\n    }\n    this.scroll({\n      left: ~~arguments[0].left + this.scrollLeft,\n      top: ~~arguments[0].top + this.scrollTop,\n      behavior: arguments[0].behavior\n    });\n  };\n  Element2.prototype.scrollIntoView = function() {\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scrollIntoView.call(\n        this,\n        arguments[0] === void 0 ? true : arguments[0]\n      );\n      return;\n    }\n    const scrollableParent = findScrollableParent(this);\n    const parentRects = scrollableParent.getBoundingClientRect();\n    const clientRects = this.getBoundingClientRect();\n    if (scrollableParent !== d.body) {\n      smoothScroll.call(\n        this,\n        scrollableParent,\n        scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n        scrollableParent.scrollTop + clientRects.top - parentRects.top\n      );\n      if (w.getComputedStyle(scrollableParent).position !== \"fixed\") {\n        w.scrollBy({\n          left: parentRects.left,\n          top: parentRects.top,\n          behavior: \"smooth\"\n        });\n      }\n    } else {\n      w.scrollBy({\n        left: clientRects.left,\n        top: clientRects.top,\n        behavior: \"smooth\"\n      });\n    }\n  };\n}\nclass Timer {\n  constructor(actions = [], config) {\n    this.timeOffset = 0;\n    this.raf = null;\n    this.actions = actions;\n    this.speed = config.speed;\n  }\n  /**\n   * Add an action, possibly after the timer starts.\n   */\n  addAction(action) {\n    const rafWasActive = this.raf === true;\n    if (!this.actions.length || this.actions[this.actions.length - 1].delay <= action.delay) {\n      this.actions.push(action);\n    } else {\n      const index = this.findActionIndex(action);\n      this.actions.splice(index, 0, action);\n    }\n    if (rafWasActive) {\n      this.raf = onRequestAnimationFrame(this.rafCheck.bind(this));\n    }\n  }\n  start() {\n    this.timeOffset = 0;\n    this.lastTimestamp = performance.now();\n    this.raf = onRequestAnimationFrame(this.rafCheck.bind(this));\n  }\n  rafCheck() {\n    const time = performance.now();\n    this.timeOffset += (time - this.lastTimestamp) * this.speed;\n    this.lastTimestamp = time;\n    while (this.actions.length) {\n      const action = this.actions[0];\n      if (this.timeOffset >= action.delay) {\n        this.actions.shift();\n        action.doAction();\n      } else {\n        break;\n      }\n    }\n    if (this.actions.length > 0) {\n      this.raf = onRequestAnimationFrame(this.rafCheck.bind(this));\n    } else {\n      this.raf = true;\n    }\n  }\n  clear() {\n    if (this.raf) {\n      if (this.raf !== true) {\n        cancelAnimationFrame(this.raf);\n      }\n      this.raf = null;\n    }\n    this.actions.length = 0;\n  }\n  setSpeed(speed) {\n    this.speed = speed;\n  }\n  isActive() {\n    return this.raf !== null;\n  }\n  findActionIndex(action) {\n    let start = 0;\n    let end = this.actions.length - 1;\n    while (start <= end) {\n      const mid = Math.floor((start + end) / 2);\n      if (this.actions[mid].delay < action.delay) {\n        start = mid + 1;\n      } else if (this.actions[mid].delay > action.delay) {\n        end = mid - 1;\n      } else {\n        return mid + 1;\n      }\n    }\n    return start;\n  }\n}\nfunction addDelay(event, baselineTime) {\n  if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.MouseMove && event.data.positions && event.data.positions.length) {\n    const firstOffset = event.data.positions[0].timeOffset;\n    const firstTimestamp = event.timestamp + firstOffset;\n    event.delay = firstTimestamp - baselineTime;\n    return firstTimestamp - baselineTime;\n  }\n  event.delay = event.timestamp - baselineTime;\n  return event.delay;\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction t(t2, n2) {\n  var e2 = \"function\" == typeof Symbol && t2[Symbol.iterator];\n  if (!e2) return t2;\n  var r2, o2, i2 = e2.call(t2), a2 = [];\n  try {\n    for (; (void 0 === n2 || n2-- > 0) && !(r2 = i2.next()).done; ) a2.push(r2.value);\n  } catch (t3) {\n    o2 = { error: t3 };\n  } finally {\n    try {\n      r2 && !r2.done && (e2 = i2.return) && e2.call(i2);\n    } finally {\n      if (o2) throw o2.error;\n    }\n  }\n  return a2;\n}\nvar n;\n!function(t2) {\n  t2[t2.NotStarted = 0] = \"NotStarted\", t2[t2.Running = 1] = \"Running\", t2[t2.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\nvar e = { type: \"xstate.init\" };\nfunction r(t2) {\n  return void 0 === t2 ? [] : [].concat(t2);\n}\nfunction o(t2) {\n  return { type: \"xstate.assign\", assignment: t2 };\n}\nfunction i(t2, n2) {\n  return \"string\" == typeof (t2 = \"string\" == typeof t2 && n2 && n2[t2] ? n2[t2] : t2) ? { type: t2 } : \"function\" == typeof t2 ? { type: t2.name, exec: t2 } : t2;\n}\nfunction a(t2) {\n  return function(n2) {\n    return t2 === n2;\n  };\n}\nfunction u(t2) {\n  return \"string\" == typeof t2 ? { type: t2 } : t2;\n}\nfunction c(t2, n2) {\n  return { value: t2, context: n2, actions: [], changed: false, matches: a(t2) };\n}\nfunction f(t2, n2, e2) {\n  var r2 = n2, o2 = false;\n  return [t2.filter(function(t3) {\n    if (\"xstate.assign\" === t3.type) {\n      o2 = true;\n      var n3 = Object.assign({}, r2);\n      return \"function\" == typeof t3.assignment ? n3 = t3.assignment(r2, e2) : Object.keys(t3.assignment).forEach(function(o3) {\n        n3[o3] = \"function\" == typeof t3.assignment[o3] ? t3.assignment[o3](r2, e2) : t3.assignment[o3];\n      }), r2 = n3, false;\n    }\n    return true;\n  }), r2, o2];\n}\nfunction s(n2, o2) {\n  void 0 === o2 && (o2 = {});\n  var s2 = t(f(r(n2.states[n2.initial].entry).map(function(t2) {\n    return i(t2, o2.actions);\n  }), n2.context, e), 2), l2 = s2[0], v2 = s2[1], y = { config: n2, _options: o2, initialState: { value: n2.initial, actions: l2, context: v2, matches: a(n2.initial) }, transition: function(e2, o3) {\n    var s3, l3, v3 = \"string\" == typeof e2 ? { value: e2, context: n2.context } : e2, p = v3.value, g = v3.context, d = u(o3), x = n2.states[p];\n    if (x.on) {\n      var m = r(x.on[d.type]);\n      try {\n        for (var h = function(t2) {\n          var n3 = \"function\" == typeof Symbol && Symbol.iterator, e3 = n3 && t2[n3], r2 = 0;\n          if (e3) return e3.call(t2);\n          if (t2 && \"number\" == typeof t2.length) return { next: function() {\n            return t2 && r2 >= t2.length && (t2 = void 0), { value: t2 && t2[r2++], done: !t2 };\n          } };\n          throw new TypeError(n3 ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n        }(m), b = h.next(); !b.done; b = h.next()) {\n          var S = b.value;\n          if (void 0 === S) return c(p, g);\n          var w = \"string\" == typeof S ? { target: S } : S, j = w.target, E = w.actions, R = void 0 === E ? [] : E, N = w.cond, O = void 0 === N ? function() {\n            return true;\n          } : N, _ = void 0 === j, k = null != j ? j : p, T = n2.states[k];\n          if (O(g, d)) {\n            var q = t(f((_ ? r(R) : [].concat(x.exit, R, T.entry).filter(function(t2) {\n              return t2;\n            })).map(function(t2) {\n              return i(t2, y._options.actions);\n            }), g, d), 3), z = q[0], A = q[1], B = q[2], C = null != j ? j : p;\n            return { value: C, context: A, actions: z, changed: j !== p || z.length > 0 || B, matches: a(C) };\n          }\n        }\n      } catch (t2) {\n        s3 = { error: t2 };\n      } finally {\n        try {\n          b && !b.done && (l3 = h.return) && l3.call(h);\n        } finally {\n          if (s3) throw s3.error;\n        }\n      }\n    }\n    return c(p, g);\n  } };\n  return y;\n}\nvar l = function(t2, n2) {\n  return t2.actions.forEach(function(e2) {\n    var r2 = e2.exec;\n    return r2 && r2(t2.context, n2);\n  });\n};\nfunction v(t2) {\n  var r2 = t2.initialState, o2 = n.NotStarted, i2 = /* @__PURE__ */ new Set(), c2 = { _machine: t2, send: function(e2) {\n    o2 === n.Running && (r2 = t2.transition(r2, e2), l(r2, u(e2)), i2.forEach(function(t3) {\n      return t3(r2);\n    }));\n  }, subscribe: function(t3) {\n    return i2.add(t3), t3(r2), { unsubscribe: function() {\n      return i2.delete(t3);\n    } };\n  }, start: function(i3) {\n    if (i3) {\n      var u2 = \"object\" == typeof i3 ? i3 : { context: t2.config.context, value: i3 };\n      r2 = { value: u2.value, actions: [], context: u2.context, matches: a(u2.value) };\n    }\n    return o2 = n.Running, l(r2, e), c2;\n  }, stop: function() {\n    return o2 = n.Stopped, i2.clear(), c2;\n  }, get state() {\n    return r2;\n  }, get status() {\n    return o2;\n  } };\n  return c2;\n}\nfunction discardPriorSnapshots(events, baselineTime) {\n  for (let idx = events.length - 1; idx >= 0; idx--) {\n    const event = events[idx];\n    if (event.type === EventType.Meta) {\n      if (event.timestamp <= baselineTime) {\n        return events.slice(idx);\n      }\n    }\n  }\n  return events;\n}\nfunction createPlayerService(context, { getCastFn, applyEventsSynchronously, emitter }) {\n  const playerMachine = s(\n    {\n      id: \"player\",\n      context,\n      initial: \"paused\",\n      states: {\n        playing: {\n          on: {\n            PAUSE: {\n              target: \"paused\",\n              actions: [\"pause\"]\n            },\n            CAST_EVENT: {\n              target: \"playing\",\n              actions: \"castEvent\"\n            },\n            END: {\n              target: \"paused\",\n              actions: [\"resetLastPlayedEvent\", \"pause\"]\n            },\n            ADD_EVENT: {\n              target: \"playing\",\n              actions: [\"addEvent\"]\n            }\n          }\n        },\n        paused: {\n          on: {\n            PLAY: {\n              target: \"playing\",\n              actions: [\"recordTimeOffset\", \"play\"]\n            },\n            CAST_EVENT: {\n              target: \"paused\",\n              actions: \"castEvent\"\n            },\n            TO_LIVE: {\n              target: \"live\",\n              actions: [\"startLive\"]\n            },\n            ADD_EVENT: {\n              target: \"paused\",\n              actions: [\"addEvent\"]\n            }\n          }\n        },\n        live: {\n          on: {\n            ADD_EVENT: {\n              target: \"live\",\n              actions: [\"addEvent\"]\n            },\n            CAST_EVENT: {\n              target: \"live\",\n              actions: [\"castEvent\"]\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        castEvent: o({\n          lastPlayedEvent: (ctx, event) => {\n            if (event.type === \"CAST_EVENT\") {\n              return event.payload.event;\n            }\n            return ctx.lastPlayedEvent;\n          }\n        }),\n        recordTimeOffset: o((ctx, event) => {\n          let timeOffset = ctx.timeOffset;\n          if (\"payload\" in event && \"timeOffset\" in event.payload) {\n            timeOffset = event.payload.timeOffset;\n          }\n          return {\n            ...ctx,\n            timeOffset,\n            baselineTime: ctx.events[0].timestamp + timeOffset\n          };\n        }),\n        play(ctx) {\n          const { timer, events, baselineTime, lastPlayedEvent } = ctx;\n          timer.clear();\n          for (const event of events) {\n            addDelay(event, baselineTime);\n          }\n          const neededEvents = discardPriorSnapshots(events, baselineTime);\n          let lastPlayedTimestamp = lastPlayedEvent?.timestamp;\n          if (lastPlayedEvent?.type === EventType.IncrementalSnapshot && lastPlayedEvent.data.source === IncrementalSource.MouseMove) {\n            lastPlayedTimestamp = lastPlayedEvent.timestamp + lastPlayedEvent.data.positions[0]?.timeOffset;\n          }\n          if (baselineTime < (lastPlayedTimestamp || 0)) {\n            emitter.emit(ReplayerEvents.PlayBack);\n          }\n          const syncEvents = new Array();\n          for (const event of neededEvents) {\n            if (lastPlayedTimestamp && lastPlayedTimestamp < baselineTime && (event.timestamp <= lastPlayedTimestamp || event === lastPlayedEvent)) {\n              continue;\n            }\n            if (event.timestamp < baselineTime) {\n              syncEvents.push(event);\n            } else {\n              const castFn = getCastFn(event, false);\n              timer.addAction({\n                doAction: () => {\n                  castFn();\n                },\n                delay: event.delay\n              });\n            }\n          }\n          applyEventsSynchronously(syncEvents);\n          emitter.emit(ReplayerEvents.Flush);\n          timer.start();\n        },\n        pause(ctx) {\n          ctx.timer.clear();\n        },\n        resetLastPlayedEvent: o((ctx) => {\n          return {\n            ...ctx,\n            lastPlayedEvent: null\n          };\n        }),\n        startLive: o({\n          baselineTime: (ctx, event) => {\n            ctx.timer.start();\n            if (event.type === \"TO_LIVE\" && event.payload.baselineTime) {\n              return event.payload.baselineTime;\n            }\n            return Date.now();\n          }\n        }),\n        addEvent: o((ctx, machineEvent) => {\n          const { baselineTime, timer, events } = ctx;\n          if (machineEvent.type === \"ADD_EVENT\") {\n            const { event } = machineEvent.payload;\n            addDelay(event, baselineTime);\n            let end = events.length - 1;\n            if (!events[end] || events[end].timestamp <= event.timestamp) {\n              events.push(event);\n            } else {\n              let insertionIndex = -1;\n              let start = 0;\n              while (start <= end) {\n                const mid = Math.floor((start + end) / 2);\n                if (events[mid].timestamp <= event.timestamp) {\n                  start = mid + 1;\n                } else {\n                  end = mid - 1;\n                }\n              }\n              if (insertionIndex === -1) {\n                insertionIndex = start;\n              }\n              events.splice(insertionIndex, 0, event);\n            }\n            const isSync = event.timestamp < baselineTime;\n            const castFn = getCastFn(event, isSync);\n            if (isSync) {\n              castFn();\n            } else if (timer.isActive()) {\n              timer.addAction({\n                doAction: () => {\n                  castFn();\n                },\n                delay: event.delay\n              });\n            }\n          }\n          return { ...ctx, events };\n        })\n      }\n    }\n  );\n  return v(playerMachine);\n}\nfunction createSpeedService(context) {\n  const speedMachine = s(\n    {\n      id: \"speed\",\n      context,\n      initial: \"normal\",\n      states: {\n        normal: {\n          on: {\n            FAST_FORWARD: {\n              target: \"skipping\",\n              actions: [\"recordSpeed\", \"setSpeed\"]\n            },\n            SET_SPEED: {\n              target: \"normal\",\n              actions: [\"setSpeed\"]\n            }\n          }\n        },\n        skipping: {\n          on: {\n            BACK_TO_NORMAL: {\n              target: \"normal\",\n              actions: [\"restoreSpeed\"]\n            },\n            SET_SPEED: {\n              target: \"normal\",\n              actions: [\"setSpeed\"]\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        setSpeed: (ctx, event) => {\n          if (\"payload\" in event) {\n            ctx.timer.setSpeed(event.payload.speed);\n          }\n        },\n        recordSpeed: o({\n          normalSpeed: (ctx) => ctx.timer.speed\n        }),\n        restoreSpeed: (ctx) => {\n          ctx.timer.setSpeed(ctx.normalSpeed);\n        }\n      }\n    }\n  );\n  return v(speedMachine);\n}\nconst rules = (blockClass) => [\n  `.${blockClass} { background: currentColor }`,\n  \"noscript { display: none !important; }\"\n];\nconst webGLVarMap = /* @__PURE__ */ new Map();\nfunction variableListFor(ctx, ctor) {\n  let contextMap = webGLVarMap.get(ctx);\n  if (!contextMap) {\n    contextMap = /* @__PURE__ */ new Map();\n    webGLVarMap.set(ctx, contextMap);\n  }\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n  return contextMap.get(ctor);\n}\nfunction deserializeArg(imageMap, ctx, preload) {\n  return async (arg) => {\n    if (arg && typeof arg === \"object\" && \"rr_type\" in arg) {\n      if (preload) preload.isUnchanged = false;\n      if (arg.rr_type === \"ImageBitmap\" && \"args\" in arg) {\n        const args = await deserializeArg(imageMap, ctx, preload)(arg.args);\n        return await createImageBitmap.apply(null, args);\n      } else if (\"index\" in arg) {\n        if (preload || ctx === null) return arg;\n        const { rr_type: name, index } = arg;\n        return variableListFor(ctx, name)[index];\n      } else if (\"args\" in arg) {\n        const { rr_type: name, args } = arg;\n        const ctor = window[name];\n        return new ctor(\n          ...await Promise.all(\n            args.map(deserializeArg(imageMap, ctx, preload))\n          )\n        );\n      } else if (\"base64\" in arg) {\n        return decode(arg.base64);\n      } else if (\"src\" in arg) {\n        const image = imageMap.get(arg.src);\n        if (image) {\n          return image;\n        } else {\n          const image2 = new Image();\n          image2.src = arg.src;\n          imageMap.set(arg.src, image2);\n          return image2;\n        }\n      } else if (\"data\" in arg && arg.rr_type === \"Blob\") {\n        const blobContents = await Promise.all(\n          arg.data.map(deserializeArg(imageMap, ctx, preload))\n        );\n        const blob = new Blob(blobContents, {\n          type: arg.type\n        });\n        return blob;\n      }\n    } else if (Array.isArray(arg)) {\n      const result = await Promise.all(\n        arg.map(deserializeArg(imageMap, ctx, preload))\n      );\n      return result;\n    }\n    return arg;\n  };\n}\nfunction getContext(target, type) {\n  try {\n    if (type === CanvasContext.WebGL) {\n      return target.getContext(\"webgl\") || target.getContext(\"experimental-webgl\");\n    }\n    return target.getContext(\"webgl2\");\n  } catch (e2) {\n    return null;\n  }\n}\nconst WebGLVariableConstructorsNames = [\n  \"WebGLActiveInfo\",\n  \"WebGLBuffer\",\n  \"WebGLFramebuffer\",\n  \"WebGLProgram\",\n  \"WebGLRenderbuffer\",\n  \"WebGLShader\",\n  \"WebGLShaderPrecisionFormat\",\n  \"WebGLTexture\",\n  \"WebGLUniformLocation\",\n  \"WebGLVertexArrayObject\"\n];\nfunction saveToWebGLVarMap(ctx, result) {\n  if (!result?.constructor) return;\n  const { name } = result.constructor;\n  if (!WebGLVariableConstructorsNames.includes(name)) return;\n  const variables = variableListFor(ctx, name);\n  if (!variables.includes(result)) variables.push(result);\n}\nasync function webglMutation({\n  mutation,\n  target,\n  type,\n  imageMap,\n  errorHandler: errorHandler2\n}) {\n  try {\n    const ctx = getContext(target, type);\n    if (!ctx) return;\n    if (mutation.setter) {\n      ctx[mutation.property] = mutation.args[0];\n      return;\n    }\n    const original = ctx[mutation.property];\n    const args = await Promise.all(\n      mutation.args.map(deserializeArg(imageMap, ctx))\n    );\n    const result = original.apply(ctx, args);\n    saveToWebGLVarMap(ctx, result);\n    const debugMode = false;\n    if (debugMode) ;\n  } catch (error) {\n    errorHandler2(mutation, error);\n  }\n}\nasync function canvasMutation$1({\n  event,\n  mutations,\n  target,\n  imageMap,\n  errorHandler: errorHandler2\n}) {\n  const ctx = target.getContext(\"2d\");\n  if (!ctx) {\n    errorHandler2(mutations[0], new Error(\"Canvas context is null\"));\n    return;\n  }\n  const mutationArgsPromises = mutations.map(\n    async (mutation) => {\n      return Promise.all(mutation.args.map(deserializeArg(imageMap, ctx)));\n    }\n  );\n  const args = await Promise.all(mutationArgsPromises);\n  args.forEach((args2, index) => {\n    const mutation = mutations[index];\n    try {\n      if (mutation.setter) {\n        ctx[mutation.property] = mutation.args[0];\n        return;\n      }\n      const original = ctx[mutation.property];\n      if (mutation.property === \"drawImage\" && typeof mutation.args[0] === \"string\") {\n        imageMap.get(event);\n        original.apply(ctx, mutation.args);\n      } else {\n        original.apply(ctx, args2);\n      }\n    } catch (error) {\n      errorHandler2(mutation, error);\n    }\n    return;\n  });\n}\nasync function canvasMutation({\n  event,\n  mutation,\n  target,\n  imageMap,\n  canvasEventMap,\n  errorHandler: errorHandler2\n}) {\n  try {\n    const precomputedMutation = canvasEventMap.get(event) || mutation;\n    const commands = \"commands\" in precomputedMutation ? precomputedMutation.commands : [precomputedMutation];\n    if ([CanvasContext.WebGL, CanvasContext.WebGL2].includes(mutation.type)) {\n      for (let i2 = 0; i2 < commands.length; i2++) {\n        const command = commands[i2];\n        await webglMutation({\n          mutation: command,\n          type: mutation.type,\n          target,\n          imageMap,\n          errorHandler: errorHandler2\n        });\n      }\n      return;\n    }\n    await canvasMutation$1({\n      event,\n      mutations: commands,\n      target,\n      imageMap,\n      errorHandler: errorHandler2\n    });\n  } catch (error) {\n    errorHandler2(mutation, error);\n  }\n}\nconst SKIP_TIME_INTERVAL = 5 * 1e3;\nconst mitt = mitt$1 || mittProxy;\nconst REPLAY_CONSOLE_PREFIX = \"[replayer]\";\nconst defaultMouseTailConfig = {\n  duration: 500,\n  lineCap: \"round\",\n  lineWidth: 3,\n  strokeStyle: \"red\"\n};\nfunction indicatesTouchDevice(e2) {\n  return e2.type == EventType.IncrementalSnapshot && (e2.data.source == IncrementalSource.TouchMove || e2.data.source == IncrementalSource.MouseInteraction && e2.data.type == MouseInteractions.TouchStart);\n}\nfunction getPointerId(d) {\n  const pointerId = \"pointerId\" in d && typeof d.pointerId === \"number\" ? d.pointerId : -1;\n  return pointerId;\n}\nclass Replayer {\n  constructor(events, config) {\n    this.usingVirtualDom = false;\n    this.virtualDom = new RRDocument();\n    this.emitter = mitt();\n    this.legacy_missingNodeRetryMap = {};\n    this.cache = createCache();\n    this.imageMap = /* @__PURE__ */ new Map();\n    this.canvasEventMap = /* @__PURE__ */ new Map();\n    this.mirror = createMirror$2();\n    this.styleMirror = new StyleSheetMirror();\n    this.firstFullSnapshot = null;\n    this.newDocumentQueue = [];\n    this.pointers = {};\n    this.lastMouseDownEvent = null;\n    this.lastSelectionData = null;\n    this.constructedStyleMutations = [];\n    this.adoptedStyleSheets = [];\n    this.handleResize = (dimension) => {\n      this.iframe.style.display = \"inherit\";\n      for (const el of [\n        ...Object.values(this.pointers).flatMap((a2) => a2.mouseTail),\n        this.iframe\n      ]) {\n        if (!el) {\n          continue;\n        }\n        el.setAttribute(\"width\", String(dimension.width));\n        el.setAttribute(\"height\", String(dimension.height));\n      }\n    };\n    this.applyEventsSynchronously = (events2) => {\n      for (const event of events2) {\n        switch (event.type) {\n          case EventType.DomContentLoaded:\n          case EventType.Load:\n          case EventType.Custom:\n            continue;\n          case EventType.FullSnapshot:\n          case EventType.Meta:\n          case EventType.Plugin:\n          case EventType.IncrementalSnapshot:\n            break;\n        }\n        const castFn = this.getCastFn(event, true);\n        castFn();\n      }\n    };\n    this.getCastFn = (event, isSync = false) => {\n      let castFn;\n      switch (event.type) {\n        case EventType.DomContentLoaded:\n        case EventType.Load:\n          break;\n        case EventType.Custom:\n          castFn = () => {\n            this.emitter.emit(ReplayerEvents.CustomEvent, event);\n          };\n          break;\n        case EventType.Meta:\n          castFn = () => this.emitter.emit(ReplayerEvents.Resize, {\n            width: event.data.width,\n            height: event.data.height\n          });\n          break;\n        case EventType.FullSnapshot:\n          castFn = () => {\n            if (this.firstFullSnapshot) {\n              if (this.firstFullSnapshot === event) {\n                this.firstFullSnapshot = true;\n                return;\n              }\n            } else {\n              this.firstFullSnapshot = true;\n            }\n            this.rebuildFullSnapshot(event, isSync);\n            this.iframe.contentWindow?.scrollTo(event.data.initialOffset);\n            this.styleMirror.reset();\n          };\n          break;\n        case EventType.IncrementalSnapshot:\n          castFn = () => {\n            this.applyIncremental(event, isSync);\n            if (isSync) {\n              return;\n            }\n            if (event === this.nextUserInteractionEvent) {\n              this.nextUserInteractionEvent = null;\n              this.backToNormal();\n            }\n            if (this.config.skipInactive && !this.nextUserInteractionEvent) {\n              for (const _event of this.service.state.context.events) {\n                if (_event.timestamp <= event.timestamp) {\n                  continue;\n                }\n                if (this.isUserInteraction(_event)) {\n                  if (\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    _event.delay - event.delay > this.config.inactivePeriodThreshold * this.speedService.state.context.timer.speed\n                  ) {\n                    this.nextUserInteractionEvent = _event;\n                  }\n                  break;\n                }\n              }\n              if (this.nextUserInteractionEvent) {\n                const skipTime = (\n                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  this.nextUserInteractionEvent.delay - event.delay\n                );\n                const payload = {\n                  speed: Math.min(\n                    Math.round(skipTime / SKIP_TIME_INTERVAL),\n                    this.config.maxSpeed\n                  )\n                };\n                this.speedService.send({ type: \"FAST_FORWARD\", payload });\n                this.emitter.emit(ReplayerEvents.SkipStart, payload);\n              }\n            }\n          };\n          break;\n      }\n      const wrappedCastFn = () => {\n        if (castFn) {\n          castFn();\n        }\n        for (const plugin of this.config.plugins || []) {\n          if (plugin.handler) plugin.handler(event, isSync, { replayer: this });\n        }\n        this.service.send({ type: \"CAST_EVENT\", payload: { event } });\n        const last_index = this.service.state.context.events.length - 1;\n        if (!this.config.liveMode && event === this.service.state.context.events[last_index]) {\n          const finish = () => {\n            if (last_index < this.service.state.context.events.length - 1) {\n              return;\n            }\n            this.backToNormal();\n            this.service.send(\"END\");\n            this.emitter.emit(ReplayerEvents.Finish);\n          };\n          let finish_buffer = 50;\n          if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.MouseMove && event.data.positions.length) {\n            finish_buffer += Math.max(0, -event.data.positions[0].timeOffset);\n          }\n          setTimeout$1(finish, finish_buffer);\n        }\n        this.emitter.emit(ReplayerEvents.EventCast, event);\n      };\n      return wrappedCastFn;\n    };\n    if (!config?.liveMode && events.length < 2) {\n      throw new Error(\"Replayer need at least 2 events.\");\n    }\n    const defaultConfig = {\n      speed: 1,\n      maxSpeed: 360,\n      root: document.body,\n      loadTimeout: 0,\n      skipInactive: false,\n      inactivePeriodThreshold: 10 * 1e3,\n      showWarning: true,\n      showDebug: false,\n      blockClass: \"rr-block\",\n      liveMode: false,\n      insertStyleRules: [],\n      triggerFocus: true,\n      UNSAFE_replayCanvas: false,\n      pauseAnimation: true,\n      mouseTail: defaultMouseTailConfig,\n      useVirtualDom: true,\n      // Virtual-dom optimization is enabled by default.\n      logger: console\n    };\n    this.config = Object.assign({}, defaultConfig, config);\n    this.handleResize = this.handleResize.bind(this);\n    this.getCastFn = this.getCastFn.bind(this);\n    this.applyEventsSynchronously = this.applyEventsSynchronously.bind(this);\n    this.emitter.on(ReplayerEvents.Resize, this.handleResize);\n    this.setupDom();\n    for (const plugin of this.config.plugins || []) {\n      if (plugin.getMirror) plugin.getMirror({ nodeMirror: this.mirror });\n    }\n    this.emitter.on(ReplayerEvents.Flush, () => {\n      if (this.usingVirtualDom) {\n        const replayerHandler = {\n          mirror: this.mirror,\n          applyCanvas: (canvasEvent, canvasMutationData2, target) => {\n            void canvasMutation({\n              event: canvasEvent,\n              mutation: canvasMutationData2,\n              target,\n              imageMap: this.imageMap,\n              canvasEventMap: this.canvasEventMap,\n              errorHandler: this.warnCanvasMutationFailed.bind(this)\n            });\n          },\n          applyInput: this.applyInput.bind(this),\n          applyScroll: this.applyScroll.bind(this),\n          applyStyleSheetMutation: (data, styleSheet) => {\n            if (data.source === IncrementalSource.StyleSheetRule)\n              this.applyStyleSheetRule(data, styleSheet);\n            else if (data.source === IncrementalSource.StyleDeclaration)\n              this.applyStyleDeclaration(data, styleSheet);\n          },\n          afterAppend: (node, id) => {\n            for (const plugin of this.config.plugins || []) {\n              if (plugin.onBuild) plugin.onBuild(node, { id, replayer: this });\n            }\n          }\n        };\n        const iframeDoc = getIFrameContentDocument(this.iframe);\n        if (iframeDoc)\n          try {\n            diff(\n              iframeDoc,\n              this.virtualDom,\n              replayerHandler,\n              this.virtualDom.mirror\n            );\n          } catch (e2) {\n            console.warn(e2);\n          }\n        this.virtualDom.destroyTree();\n        this.usingVirtualDom = false;\n        if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n          for (const key in this.legacy_missingNodeRetryMap) {\n            try {\n              const value = this.legacy_missingNodeRetryMap[key];\n              const realNode = createOrGetNode(\n                value.node,\n                this.mirror,\n                this.virtualDom.mirror\n              );\n              diff(\n                realNode,\n                value.node,\n                replayerHandler,\n                this.virtualDom.mirror\n              );\n              value.node = realNode;\n            } catch (error) {\n              this.warn(error);\n            }\n          }\n        }\n        this.constructedStyleMutations.forEach((data) => {\n          this.applyStyleSheetMutation(data);\n        });\n        this.constructedStyleMutations = [];\n        this.adoptedStyleSheets.forEach((data) => {\n          this.applyAdoptedStyleSheet(data);\n        });\n        this.adoptedStyleSheets = [];\n      }\n      for (const [\n        pointerId,\n        { pointerPosition, touchActive }\n      ] of Object.entries(this.pointers)) {\n        const id = parseInt(pointerId);\n        const pointer = this.pointers[id];\n        if (pointerPosition) {\n          this.moveAndHover(\n            pointerPosition.x,\n            pointerPosition.y,\n            pointerPosition.id,\n            true,\n            pointerPosition.debugData,\n            id\n          );\n          pointer.pointerPosition = null;\n        }\n        if (touchActive === true) {\n          pointer.pointerEl.classList.add(\"touch-active\");\n        } else if (touchActive === false) {\n          pointer.pointerEl.classList.remove(\"touch-active\");\n        }\n        pointer.touchActive = null;\n      }\n      if (this.lastMouseDownEvent) {\n        const [target, event] = this.lastMouseDownEvent;\n        target.dispatchEvent(event);\n      }\n      this.lastMouseDownEvent = null;\n      if (this.lastSelectionData) {\n        this.applySelection(this.lastSelectionData);\n        this.lastSelectionData = null;\n      }\n    });\n    this.emitter.on(ReplayerEvents.PlayBack, () => {\n      this.firstFullSnapshot = null;\n      this.mirror.reset();\n      this.styleMirror.reset();\n    });\n    const timer = new Timer([], {\n      speed: this.config.speed\n    });\n    this.service = createPlayerService(\n      {\n        events: events.map((e2) => {\n          if (config && config.unpackFn) {\n            return config.unpackFn(e2);\n          }\n          return e2;\n        }).sort((a1, a2) => a1.timestamp - a2.timestamp),\n        timer,\n        timeOffset: 0,\n        baselineTime: 0,\n        lastPlayedEvent: null\n      },\n      {\n        getCastFn: this.getCastFn,\n        applyEventsSynchronously: this.applyEventsSynchronously,\n        emitter: this.emitter\n      }\n    );\n    this.service.start();\n    this.service.subscribe((state) => {\n      this.emitter.emit(ReplayerEvents.StateChange, {\n        player: state\n      });\n    });\n    this.speedService = createSpeedService({\n      normalSpeed: -1,\n      timer\n    });\n    this.speedService.start();\n    this.speedService.subscribe((state) => {\n      this.emitter.emit(ReplayerEvents.StateChange, {\n        speed: state\n      });\n    });\n    const firstMeta = this.service.state.context.events.find(\n      (e2) => e2.type === EventType.Meta\n    );\n    const firstFullsnapshot = this.service.state.context.events.find(\n      (e2) => e2.type === EventType.FullSnapshot\n    );\n    if (firstMeta) {\n      const { width, height } = firstMeta.data;\n      setTimeout$1(() => {\n        this.emitter.emit(ReplayerEvents.Resize, {\n          width,\n          height\n        });\n      }, 0);\n    }\n    if (firstFullsnapshot) {\n      setTimeout$1(() => {\n        if (this.firstFullSnapshot) {\n          return;\n        }\n        this.firstFullSnapshot = firstFullsnapshot;\n        this.rebuildFullSnapshot(\n          firstFullsnapshot\n        );\n        this.iframe.contentWindow?.scrollTo(\n          firstFullsnapshot.data.initialOffset\n        );\n      }, 1);\n    }\n  }\n  get timer() {\n    return this.service.state.context.timer;\n  }\n  createPointer(pointerId, event) {\n    const mouseTail = document.createElement(\"canvas\");\n    mouseTail.classList.add(\"replayer-mouse-tail\");\n    mouseTail.width = Number.parseFloat(this.iframe.width);\n    mouseTail.height = Number.parseFloat(this.iframe.height);\n    this.wrapper.insertBefore(mouseTail, this.iframe);\n    mouseTail.style.display = this.config.mouseTail === false ? \"none\" : \"inherit\";\n    const newMouse = document.createElement(\"div\");\n    newMouse.classList.add(\"replayer-mouse\");\n    this.pointers[pointerId] = {\n      touchActive: null,\n      pointerEl: newMouse,\n      tailPositions: [],\n      pointerPosition: null,\n      mouseTail\n    };\n    if (indicatesTouchDevice(event)) {\n      newMouse.classList.add(\"touch-device\");\n    }\n    this.wrapper.appendChild(newMouse);\n  }\n  on(event, handler) {\n    this.emitter.on(event, handler);\n    return this;\n  }\n  off(event, handler) {\n    this.emitter.off(event, handler);\n    return this;\n  }\n  setConfig(config) {\n    Object.keys(config).forEach((key) => {\n      config[key];\n      this.config[key] = config[key];\n    });\n    if (!this.config.skipInactive) {\n      this.backToNormal();\n    }\n    if (typeof config.speed !== \"undefined\") {\n      this.speedService.send({\n        type: \"SET_SPEED\",\n        payload: {\n          speed: config.speed\n        }\n      });\n    }\n    if (typeof config.mouseTail !== \"undefined\") {\n      if (config.mouseTail === false) {\n        for (const { mouseTail } of Object.values(this.pointers)) {\n          if (mouseTail) {\n            mouseTail.style.display = \"none\";\n          }\n        }\n      } else {\n        for (let { mouseTail } of Object.values(this.pointers)) {\n          if (!mouseTail) {\n            mouseTail = document.createElement(\"canvas\");\n            mouseTail.width = Number.parseFloat(this.iframe.width);\n            mouseTail.height = Number.parseFloat(this.iframe.height);\n            mouseTail.classList.add(\"replayer-mouse-tail\");\n            this.wrapper.insertBefore(mouseTail, this.iframe);\n          }\n          mouseTail.style.display = \"inherit\";\n        }\n      }\n    }\n  }\n  getMetaData() {\n    const firstEvent = this.service.state.context.events[0];\n    const lastEvent = this.service.state.context.events[this.service.state.context.events.length - 1];\n    return {\n      startTime: firstEvent.timestamp,\n      endTime: lastEvent.timestamp,\n      totalTime: lastEvent.timestamp - firstEvent.timestamp\n    };\n  }\n  getCurrentTime() {\n    return this.timer.timeOffset + this.getTimeOffset();\n  }\n  getTimeOffset() {\n    const { baselineTime, events } = this.service.state.context;\n    return baselineTime - events[0].timestamp;\n  }\n  getMirror() {\n    return this.mirror;\n  }\n  /**\n   * This API was designed to be used as play at any time offset.\n   * Since we minimized the data collected from recorder, we do not\n   * have the ability of undo an event.\n   * So the implementation of play at any time offset will always iterate\n   * all of the events, cast event before the offset synchronously\n   * and cast event after the offset asynchronously with timer.\n   * @param timeOffset - number\n   */\n  play(timeOffset = 0) {\n    if (this.service.state.matches(\"paused\")) {\n      this.service.send({ type: \"PLAY\", payload: { timeOffset } });\n    } else {\n      this.service.send({ type: \"PAUSE\" });\n      this.service.send({ type: \"PLAY\", payload: { timeOffset } });\n    }\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    iframeDoc?.getElementsByTagName(\"html\")[0]?.classList.remove(\"rrweb-paused\");\n    this.emitter.emit(ReplayerEvents.Start);\n  }\n  pause(timeOffset) {\n    if (timeOffset === void 0 && this.service.state.matches(\"playing\")) {\n      this.service.send({ type: \"PAUSE\" });\n    }\n    if (typeof timeOffset === \"number\") {\n      this.play(timeOffset);\n      this.service.send({ type: \"PAUSE\" });\n    }\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    iframeDoc?.getElementsByTagName(\"html\")[0]?.classList.add(\"rrweb-paused\");\n    this.emitter.emit(ReplayerEvents.Pause);\n  }\n  resume(timeOffset = 0) {\n    this.warn(\n      `The 'resume' was deprecated in 1.0. Please use 'play' method which has the same interface.`\n    );\n    this.play(timeOffset);\n    this.emitter.emit(ReplayerEvents.Resume);\n  }\n  /**\n   * Totally destroy this replayer and please be careful that this operation is irreversible.\n   * Memory occupation can be released by removing all references to this replayer.\n   */\n  destroy() {\n    this.pause();\n    this.config.root.removeChild(this.wrapper);\n    this.emitter.emit(ReplayerEvents.Destroy);\n  }\n  startLive(baselineTime) {\n    this.service.send({ type: \"TO_LIVE\", payload: { baselineTime } });\n  }\n  addEvent(rawEvent) {\n    const event = this.config.unpackFn ? this.config.unpackFn(rawEvent) : rawEvent;\n    void Promise.resolve().then(\n      () => this.service.send({ type: \"ADD_EVENT\", payload: { event } })\n    );\n  }\n  enableInteract() {\n    this.iframe.setAttribute(\"scrolling\", \"auto\");\n    this.iframe.style.pointerEvents = \"auto\";\n  }\n  disableInteract() {\n    this.iframe.setAttribute(\"scrolling\", \"no\");\n    this.iframe.style.pointerEvents = \"none\";\n  }\n  /**\n   * Empties the replayer's cache and reclaims memory.\n   * The replayer will use this cache to speed up the playback.\n   */\n  resetCache() {\n    this.cache = createCache();\n  }\n  setupDom() {\n    this.wrapper = document.createElement(\"div\");\n    this.wrapper.classList.add(\"replayer-wrapper\");\n    this.config.root.appendChild(this.wrapper);\n    this.iframe = document.createElement(\"iframe\");\n    const attributes2 = [\"allow-same-origin\"];\n    if (this.config.UNSAFE_replayCanvas) {\n      attributes2.push(\"allow-scripts\");\n    }\n    this.iframe.style.display = \"none\";\n    this.iframe.setAttribute(\"sandbox\", attributes2.join(\" \"));\n    this.disableInteract();\n    this.wrapper.appendChild(this.iframe);\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    const iframeWindow = getIFrameContentWindow(this.iframe);\n    if (iframeWindow && iframeDoc) {\n      polyfill(iframeWindow, iframeDoc);\n      polyfill$1(iframeWindow);\n    }\n  }\n  rebuildFullSnapshot(event, isSync = false) {\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    if (!iframeDoc) {\n      return this.warn(\"Looks like your replayer has been destroyed.\");\n    }\n    if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n      this.warn(\n        \"Found unresolved missing node map\",\n        this.legacy_missingNodeRetryMap\n      );\n    }\n    this.legacy_missingNodeRetryMap = {};\n    const collected = [];\n    const afterAppend = (builtNode, id) => {\n      this.collectIframeAndAttachDocument(collected, builtNode);\n      for (const plugin of this.config.plugins || []) {\n        if (plugin.onBuild)\n          plugin.onBuild(builtNode, {\n            id,\n            replayer: this\n          });\n      }\n    };\n    if (this.usingVirtualDom) {\n      this.virtualDom.destroyTree();\n      this.usingVirtualDom = false;\n    }\n    this.mirror.reset();\n    rebuild(event.data.node, {\n      doc: iframeDoc,\n      afterAppend,\n      cache: this.cache,\n      mirror: this.mirror\n    });\n    afterAppend(iframeDoc, event.data.node.id);\n    for (const { mutationInQueue, builtNode } of collected) {\n      this.attachDocumentToIframe(mutationInQueue, builtNode);\n      this.newDocumentQueue = this.newDocumentQueue.filter(\n        (m) => m !== mutationInQueue\n      );\n    }\n    const { documentElement, head } = iframeDoc;\n    this.insertStyleRules(documentElement, head);\n    if (!this.service.state.matches(\"playing\")) {\n      const iframeHtmlElement = iframeDoc.getElementsByTagName(\"html\")[0];\n      iframeHtmlElement && iframeHtmlElement.classList.add(\"rrweb-paused\");\n    }\n    this.emitter.emit(ReplayerEvents.FullsnapshotRebuilded, event);\n    if (!isSync) {\n      this.waitForStylesheetLoad();\n    }\n    if (this.config.UNSAFE_replayCanvas) {\n      void this.preloadAllImages();\n    }\n  }\n  insertStyleRules(documentElement, head) {\n    const injectStylesRules = rules(\n      this.config.blockClass\n    ).concat(this.config.insertStyleRules);\n    if (this.config.pauseAnimation) {\n      injectStylesRules.push(\n        \"html.rrweb-paused *, html.rrweb-paused *:before, html.rrweb-paused *:after { animation-play-state: paused !important; }\"\n      );\n    }\n    if (this.usingVirtualDom) {\n      const styleEl = this.virtualDom.createElement(\"style\");\n      this.virtualDom.mirror.add(\n        styleEl,\n        getDefaultSN(styleEl, this.virtualDom.unserializedId)\n      );\n      documentElement.insertBefore(styleEl, head);\n      styleEl.rules.push({\n        source: IncrementalSource.StyleSheetRule,\n        adds: injectStylesRules.map((cssText, index) => ({\n          rule: cssText,\n          index\n        }))\n      });\n    } else {\n      const styleEl = document.createElement(\"style\");\n      documentElement.insertBefore(\n        styleEl,\n        head\n      );\n      for (let idx = 0; idx < injectStylesRules.length; idx++) {\n        styleEl.sheet?.insertRule(injectStylesRules[idx], idx);\n      }\n    }\n  }\n  attachDocumentToIframe(mutation, iframeEl) {\n    const mirror2 = this.usingVirtualDom ? this.virtualDom.mirror : this.mirror;\n    const iframeContentDoc = getIFrameContentDocument(\n      iframeEl\n    );\n    const collected = [];\n    const afterAppend = (builtNode, id) => {\n      this.collectIframeAndAttachDocument(collected, builtNode);\n      const sn = mirror2.getMeta(builtNode);\n      if (sn?.type === NodeType$2.Element && sn?.tagName.toUpperCase() === \"HTML\" && iframeContentDoc) {\n        const { documentElement, head } = iframeContentDoc;\n        this.insertStyleRules(\n          documentElement,\n          head\n        );\n      }\n      if (this.usingVirtualDom) return;\n      for (const plugin of this.config.plugins || []) {\n        if (plugin.onBuild)\n          plugin.onBuild(builtNode, {\n            id,\n            replayer: this\n          });\n      }\n    };\n    buildNodeWithSN(mutation.node, {\n      doc: iframeContentDoc,\n      mirror: mirror2,\n      hackCss: true,\n      skipChild: false,\n      afterAppend,\n      cache: this.cache\n    });\n    afterAppend(iframeContentDoc, mutation.node.id);\n    for (const { mutationInQueue, builtNode } of collected) {\n      this.attachDocumentToIframe(mutationInQueue, builtNode);\n      this.newDocumentQueue = this.newDocumentQueue.filter(\n        (m) => m !== mutationInQueue\n      );\n    }\n  }\n  collectIframeAndAttachDocument(collected, builtNode) {\n    if (isSerializedIframe(builtNode, this.mirror)) {\n      const mutationInQueue = this.newDocumentQueue.find(\n        (m) => m.parentId === this.mirror.getId(builtNode)\n      );\n      if (mutationInQueue) {\n        collected.push({\n          mutationInQueue,\n          builtNode\n        });\n      }\n    }\n  }\n  /**\n   * pause when loading style sheet, resume when loaded all timeout exceed\n   */\n  waitForStylesheetLoad() {\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    const head = iframeDoc?.head;\n    if (head) {\n      const unloadSheets = /* @__PURE__ */ new Set();\n      let timer;\n      let beforeLoadState = this.service.state;\n      const stateHandler = () => {\n        beforeLoadState = this.service.state;\n      };\n      this.emitter.on(ReplayerEvents.Start, stateHandler);\n      this.emitter.on(ReplayerEvents.Pause, stateHandler);\n      const unsubscribe = () => {\n        this.emitter.off(ReplayerEvents.Start, stateHandler);\n        this.emitter.off(ReplayerEvents.Pause, stateHandler);\n      };\n      head.querySelectorAll('link[rel=\"stylesheet\"]').forEach((css) => {\n        if (!css.sheet) {\n          unloadSheets.add(css);\n          css.addEventListener(\"load\", () => {\n            unloadSheets.delete(css);\n            if (unloadSheets.size === 0 && timer !== -1) {\n              if (beforeLoadState.matches(\"playing\")) {\n                this.play(this.getCurrentTime());\n              }\n              this.emitter.emit(ReplayerEvents.LoadStylesheetEnd);\n              if (timer) {\n                clearTimeout(timer);\n              }\n              unsubscribe();\n            }\n          });\n        }\n      });\n      if (unloadSheets.size > 0) {\n        this.service.send({ type: \"PAUSE\" });\n        this.emitter.emit(ReplayerEvents.LoadStylesheetStart);\n        timer = setTimeout$1(() => {\n          if (beforeLoadState.matches(\"playing\")) {\n            this.play(this.getCurrentTime());\n          }\n          timer = -1;\n          unsubscribe();\n        }, this.config.loadTimeout);\n      }\n    }\n  }\n  /**\n   * pause when there are some canvas drawImage args need to be loaded\n   */\n  async preloadAllImages() {\n    const promises = [];\n    for (const event of this.service.state.context.events) {\n      if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.CanvasMutation) {\n        promises.push(\n          this.deserializeAndPreloadCanvasEvents(event.data, event)\n        );\n        const commands = \"commands\" in event.data ? event.data.commands : [event.data];\n        commands.forEach((c2) => {\n          this.preloadImages(c2, event);\n        });\n      }\n    }\n    return Promise.all(promises);\n  }\n  preloadImages(data, event) {\n    if (data.property === \"drawImage\" && typeof data.args[0] === \"string\" && !this.imageMap.has(event)) {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      const imgd = ctx?.createImageData(canvas.width, canvas.height);\n      ctx?.putImageData(imgd, 0, 0);\n    }\n  }\n  async deserializeAndPreloadCanvasEvents(data, event) {\n    if (!this.canvasEventMap.has(event)) {\n      const status = {\n        isUnchanged: true\n      };\n      if (\"commands\" in data) {\n        const commands = await Promise.all(\n          data.commands.map(async (c2) => {\n            const args = await Promise.all(\n              c2.args.map(deserializeArg(this.imageMap, null, status))\n            );\n            return { ...c2, args };\n          })\n        );\n        if (status.isUnchanged === false)\n          this.canvasEventMap.set(event, { ...data, commands });\n      } else {\n        const args = await Promise.all(\n          data.args.map(deserializeArg(this.imageMap, null, status))\n        );\n        if (status.isUnchanged === false)\n          this.canvasEventMap.set(event, { ...data, args });\n      }\n    }\n  }\n  applyIncremental(e2, isSync) {\n    const { data: d } = e2;\n    switch (d.source) {\n      case IncrementalSource.Mutation: {\n        try {\n          this.applyMutation(d, isSync);\n        } catch (error) {\n          this.warn(`Exception in mutation ${error.message || error}`, d);\n        }\n        break;\n      }\n      case IncrementalSource.Drag:\n      case IncrementalSource.TouchMove:\n      case IncrementalSource.MouseMove: {\n        const pointerId = getPointerId(d);\n        if (!this.pointers[pointerId]) {\n          this.createPointer(pointerId, e2);\n        }\n        const pointer = this.pointers[pointerId];\n        if (isSync) {\n          const lastPosition = d.positions[d.positions.length - 1];\n          pointer.pointerPosition = {\n            x: lastPosition.x,\n            y: lastPosition.y,\n            id: lastPosition.id,\n            debugData: d\n          };\n        } else {\n          d.positions.forEach((p) => {\n            const action = {\n              doAction: () => {\n                this.moveAndHover(p.x, p.y, p.id, isSync, d, pointerId);\n              },\n              delay: p.timeOffset + e2.timestamp - this.service.state.context.baselineTime\n            };\n            this.timer.addAction(action);\n          });\n          this.timer.addAction({\n            doAction() {\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            delay: e2.delay - d.positions[0]?.timeOffset\n          });\n        }\n        break;\n      }\n      case IncrementalSource.MouseInteraction: {\n        const pointerId = getPointerId(d);\n        if (!this.pointers[pointerId]) {\n          this.createPointer(pointerId, e2);\n        }\n        const pointer = this.pointers[pointerId];\n        if (d.id === -1) {\n          break;\n        }\n        const event = new Event(toLowerCase(MouseInteractions[d.type]));\n        const target = this.mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        this.emitter.emit(ReplayerEvents.MouseInteraction, {\n          type: d.type,\n          target\n        });\n        const { triggerFocus } = this.config;\n        switch (d.type) {\n          case MouseInteractions.Blur:\n            if (\"blur\" in target) {\n              target.blur();\n            }\n            break;\n          case MouseInteractions.Focus:\n            if (triggerFocus && target.focus) {\n              target.focus({\n                preventScroll: true\n              });\n            }\n            break;\n          case MouseInteractions.Click:\n          case MouseInteractions.TouchStart:\n          case MouseInteractions.TouchEnd:\n          case MouseInteractions.MouseDown:\n          case MouseInteractions.MouseUp:\n            if (isSync) {\n              if (d.type === MouseInteractions.TouchStart) {\n                pointer.touchActive = true;\n                Object.values(this.pointers).forEach((p) => {\n                  if (p !== pointer && !p.touchActive) {\n                    p.touchActive = false;\n                  }\n                });\n              } else if (d.type === MouseInteractions.TouchEnd) {\n                pointer.touchActive = false;\n                pointer.pointerEl.remove();\n                if (pointer.mouseTail) {\n                  pointer.mouseTail.remove();\n                }\n                delete this.pointers[pointerId];\n              }\n              if (d.type === MouseInteractions.MouseDown) {\n                this.lastMouseDownEvent = [target, event];\n              } else if (d.type === MouseInteractions.MouseUp) {\n                this.lastMouseDownEvent = null;\n              }\n              pointer.pointerPosition = {\n                x: d.x || 0,\n                y: d.y || 0,\n                id: d.id,\n                debugData: d\n              };\n            } else {\n              if (d.type === MouseInteractions.TouchStart) {\n                pointer.tailPositions.length = 0;\n              }\n              this.moveAndHover(d.x || 0, d.y || 0, d.id, isSync, d, pointerId);\n              if (d.type === MouseInteractions.Click) {\n                pointer.pointerEl.classList.remove(\"active\");\n                void pointer.pointerEl.offsetWidth;\n                pointer.pointerEl.classList.add(\"active\");\n              } else if (d.type === MouseInteractions.TouchStart) {\n                void pointer.pointerEl.offsetWidth;\n                pointer.pointerEl.classList.add(\"touch-active\");\n              } else if (d.type === MouseInteractions.TouchEnd) {\n                pointer.pointerEl.remove();\n                if (pointer.mouseTail) {\n                  pointer.mouseTail.remove();\n                }\n                delete this.pointers[pointerId];\n              } else {\n                target.dispatchEvent(event);\n              }\n            }\n            break;\n          case MouseInteractions.TouchCancel:\n            if (isSync) {\n              pointer.touchActive = false;\n            } else {\n              pointer.pointerEl.classList.remove(\"touch-active\");\n            }\n            break;\n          default:\n            target.dispatchEvent(event);\n        }\n        break;\n      }\n      case IncrementalSource.Scroll: {\n        if (d.id === -1) {\n          break;\n        }\n        if (this.usingVirtualDom) {\n          const target = this.virtualDom.mirror.getNode(d.id);\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          target.scrollData = d;\n          break;\n        }\n        this.applyScroll(d, isSync);\n        break;\n      }\n      case IncrementalSource.ViewportResize:\n        this.emitter.emit(ReplayerEvents.Resize, {\n          width: d.width,\n          height: d.height\n        });\n        break;\n      case IncrementalSource.Input: {\n        if (d.id === -1) {\n          break;\n        }\n        if (this.usingVirtualDom) {\n          const target = this.virtualDom.mirror.getNode(d.id);\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          target.inputData = d;\n          break;\n        }\n        this.applyInput(d);\n        break;\n      }\n      case IncrementalSource.MediaInteraction: {\n        const target = this.usingVirtualDom ? this.virtualDom.mirror.getNode(d.id) : this.mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        const mediaEl = target;\n        try {\n          if (d.currentTime !== void 0) {\n            mediaEl.currentTime = d.currentTime;\n          }\n          if (d.volume !== void 0) {\n            mediaEl.volume = d.volume;\n          }\n          if (d.muted !== void 0) {\n            mediaEl.muted = d.muted;\n          }\n          if (d.type === MediaInteractions.Pause) {\n            mediaEl.pause();\n          }\n          if (d.type === MediaInteractions.Play) {\n            void mediaEl.play();\n          }\n          if (d.type === MediaInteractions.RateChange) {\n            mediaEl.playbackRate = d.playbackRate;\n          }\n        } catch (error) {\n          this.warn(\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions\n            `Failed to replay media interactions: ${error.message || error}`\n          );\n        }\n        break;\n      }\n      case IncrementalSource.StyleSheetRule:\n      case IncrementalSource.StyleDeclaration: {\n        if (this.usingVirtualDom) {\n          if (d.styleId) this.constructedStyleMutations.push(d);\n          else if (d.id)\n            this.virtualDom.mirror.getNode(d.id)?.rules?.push(d);\n        } else this.applyStyleSheetMutation(d);\n        break;\n      }\n      case IncrementalSource.CanvasMutation: {\n        if (!this.config.UNSAFE_replayCanvas) {\n          return;\n        }\n        if (this.usingVirtualDom) {\n          const target = this.virtualDom.mirror.getNode(\n            d.id\n          );\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          target.canvasMutations.push({\n            event: e2,\n            mutation: d\n          });\n        } else {\n          const target = this.mirror.getNode(d.id);\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          void canvasMutation({\n            event: e2,\n            mutation: d,\n            target,\n            imageMap: this.imageMap,\n            canvasEventMap: this.canvasEventMap,\n            errorHandler: this.warnCanvasMutationFailed.bind(this)\n          });\n        }\n        break;\n      }\n      case IncrementalSource.Font: {\n        try {\n          const fontFace = new FontFace(\n            d.family,\n            d.buffer ? new Uint8Array(JSON.parse(d.fontSource)) : d.fontSource,\n            d.descriptors\n          );\n          getIFrameContentDocument(this.iframe)?.fonts.add(fontFace);\n        } catch (error) {\n          this.warn(error);\n        }\n        break;\n      }\n      case IncrementalSource.Selection: {\n        if (isSync) {\n          this.lastSelectionData = d;\n          break;\n        }\n        this.applySelection(d);\n        break;\n      }\n      case IncrementalSource.AdoptedStyleSheet: {\n        if (this.usingVirtualDom) this.adoptedStyleSheets.push(d);\n        else this.applyAdoptedStyleSheet(d);\n        break;\n      }\n    }\n  }\n  applyMutation(d, isSync) {\n    if (this.config.useVirtualDom && !this.usingVirtualDom && isSync) {\n      this.usingVirtualDom = true;\n      const iframeDoc = getIFrameContentDocument(this.iframe);\n      if (iframeDoc) {\n        buildFromDom(iframeDoc, this.mirror, this.virtualDom);\n      }\n      if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n        for (const key in this.legacy_missingNodeRetryMap) {\n          try {\n            const value = this.legacy_missingNodeRetryMap[key];\n            const virtualNode = buildFromNode(\n              value.node,\n              this.virtualDom,\n              this.mirror\n            );\n            if (virtualNode) value.node = virtualNode;\n          } catch (error) {\n            this.warn(error);\n          }\n        }\n      }\n    }\n    const mirror2 = this.usingVirtualDom ? this.virtualDom.mirror : this.mirror;\n    d.removes = d.removes.filter((mutation) => {\n      if (!mirror2.getNode(mutation.id)) {\n        this.warnNodeNotFound(d, mutation.id);\n        return false;\n      }\n      return true;\n    });\n    d.removes.forEach((mutation) => {\n      const target = mirror2.getNode(mutation.id);\n      if (!target) {\n        return;\n      }\n      let parent = mirror2.getNode(\n        mutation.parentId\n      );\n      if (!parent) {\n        return this.warnNodeNotFound(d, mutation.parentId);\n      }\n      if (mutation.isShadow && hasShadowRoot(parent)) {\n        parent = parent.shadowRoot;\n      }\n      mirror2.removeNodeFromMap(target);\n      if (parent)\n        try {\n          parent.removeChild(target);\n          if (this.usingVirtualDom && target.nodeName === \"#text\" && parent.nodeName === \"STYLE\" && parent.rules?.length > 0)\n            parent.rules = [];\n        } catch (error) {\n          if (error instanceof DOMException) {\n            this.warn(\n              \"parent could not remove child in mutation\",\n              parent,\n              target,\n              d\n            );\n          } else {\n            throw error;\n          }\n        }\n    });\n    const legacy_missingNodeMap = {\n      ...this.legacy_missingNodeRetryMap\n    };\n    const queue = [];\n    const nextNotInDOM = (mutation) => {\n      let next = null;\n      if (mutation.nextId) {\n        next = mirror2.getNode(mutation.nextId);\n      }\n      if (mutation.nextId !== null && mutation.nextId !== void 0 && mutation.nextId !== -1 && !next) {\n        return true;\n      }\n      return false;\n    };\n    const appendNode = (mutation) => {\n      const iframeDoc = getIFrameContentDocument(this.iframe);\n      if (!iframeDoc) {\n        return this.warn(\"Looks like your replayer has been destroyed.\");\n      }\n      let parent = mirror2.getNode(\n        mutation.parentId\n      );\n      if (!parent) {\n        if (mutation.node.type === NodeType$2.Document) {\n          return this.newDocumentQueue.push(mutation);\n        }\n        return queue.push(mutation);\n      }\n      if (mutation.node.isShadow) {\n        if (!hasShadowRoot(parent)) {\n          parent.attachShadow({ mode: \"open\" });\n          parent = parent.shadowRoot;\n        } else parent = parent.shadowRoot;\n      }\n      let previous = null;\n      let next = null;\n      if (mutation.previousId) {\n        previous = mirror2.getNode(mutation.previousId);\n      }\n      if (mutation.nextId) {\n        next = mirror2.getNode(mutation.nextId);\n      }\n      if (nextNotInDOM(mutation)) {\n        return queue.push(mutation);\n      }\n      if (mutation.node.rootId && !mirror2.getNode(mutation.node.rootId)) {\n        return;\n      }\n      const targetDoc = mutation.node.rootId ? mirror2.getNode(mutation.node.rootId) : this.usingVirtualDom ? this.virtualDom : iframeDoc;\n      if (isSerializedIframe(parent, mirror2)) {\n        this.attachDocumentToIframe(\n          mutation,\n          parent\n        );\n        return;\n      }\n      const afterAppend = (node, id) => {\n        if (this.usingVirtualDom) return;\n        for (const plugin of this.config.plugins || []) {\n          if (plugin.onBuild) plugin.onBuild(node, { id, replayer: this });\n        }\n      };\n      const target = buildNodeWithSN(mutation.node, {\n        doc: targetDoc,\n        // can be Document or RRDocument\n        mirror: mirror2,\n        // can be this.mirror or virtualDom.mirror\n        skipChild: true,\n        hackCss: true,\n        cache: this.cache,\n        /**\n         * caveat: `afterAppend` only gets called on child nodes of target\n         * we have to call it again below when this target was added to the DOM\n         */\n        afterAppend\n      });\n      if (mutation.previousId === -1 || mutation.nextId === -1) {\n        legacy_missingNodeMap[mutation.node.id] = {\n          node: target,\n          mutation\n        };\n        return;\n      }\n      const parentSn = mirror2.getMeta(parent);\n      if (parentSn && parentSn.type === NodeType$2.Element && parentSn.tagName === \"textarea\" && mutation.node.type === NodeType$2.Text) {\n        const childNodeArray = Array.isArray(parent.childNodes) ? parent.childNodes : Array.from(parent.childNodes);\n        for (const c2 of childNodeArray) {\n          if (c2.nodeType === parent.TEXT_NODE) {\n            parent.removeChild(c2);\n          }\n        }\n      } else if (parentSn?.type === NodeType$2.Document) {\n        const parentDoc = parent;\n        if (mutation.node.type === NodeType$2.DocumentType && parentDoc.childNodes[0]?.nodeType === Node.DOCUMENT_TYPE_NODE)\n          parentDoc.removeChild(parentDoc.childNodes[0]);\n        if (target.nodeName === \"HTML\" && parentDoc.documentElement)\n          parentDoc.removeChild(\n            parentDoc.documentElement\n          );\n      }\n      if (previous && previous.nextSibling && previous.nextSibling.parentNode) {\n        parent.insertBefore(\n          target,\n          previous.nextSibling\n        );\n      } else if (next && next.parentNode) {\n        parent.contains(next) ? parent.insertBefore(target, next) : parent.insertBefore(target, null);\n      } else {\n        parent.appendChild(target);\n      }\n      afterAppend(target, mutation.node.id);\n      if (this.usingVirtualDom && target.nodeName === \"#text\" && parent.nodeName === \"STYLE\" && parent.rules?.length > 0)\n        parent.rules = [];\n      if (isSerializedIframe(target, this.mirror)) {\n        const targetId = this.mirror.getId(target);\n        const mutationInQueue = this.newDocumentQueue.find(\n          (m) => m.parentId === targetId\n        );\n        if (mutationInQueue) {\n          this.attachDocumentToIframe(\n            mutationInQueue,\n            target\n          );\n          this.newDocumentQueue = this.newDocumentQueue.filter(\n            (m) => m !== mutationInQueue\n          );\n        }\n      }\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(\n          legacy_missingNodeMap,\n          parent,\n          target,\n          mutation\n        );\n      }\n    };\n    d.adds.forEach((mutation) => {\n      appendNode(mutation);\n    });\n    const startTime = Date.now();\n    while (queue.length) {\n      const resolveTrees = queueToResolveTrees(queue);\n      queue.length = 0;\n      if (Date.now() - startTime > 500) {\n        this.warn(\n          \"Timeout in the loop, please check the resolve tree data:\",\n          resolveTrees\n        );\n        break;\n      }\n      for (const tree of resolveTrees) {\n        const parent = mirror2.getNode(tree.value.parentId);\n        if (!parent) {\n          this.debug(\n            \"Drop resolve tree since there is no parent for the root node.\",\n            tree\n          );\n        } else {\n          iterateResolveTree(tree, (mutation) => {\n            appendNode(mutation);\n          });\n        }\n      }\n    }\n    if (Object.keys(legacy_missingNodeMap).length) {\n      Object.assign(this.legacy_missingNodeRetryMap, legacy_missingNodeMap);\n    }\n    uniqueTextMutations(d.texts).forEach((mutation) => {\n      const target = mirror2.getNode(mutation.id);\n      if (!target) {\n        if (d.removes.find((r2) => r2.id === mutation.id)) {\n          return;\n        }\n        return this.warnNodeNotFound(d, mutation.id);\n      }\n      target.textContent = mutation.value;\n      if (this.usingVirtualDom) {\n        const parent = target.parentNode;\n        if (parent?.rules?.length > 0) parent.rules = [];\n      }\n    });\n    d.attributes.forEach((mutation) => {\n      const target = mirror2.getNode(mutation.id);\n      if (!target) {\n        if (d.removes.find((r2) => r2.id === mutation.id)) {\n          return;\n        }\n        return this.warnNodeNotFound(d, mutation.id);\n      }\n      for (const attributeName in mutation.attributes) {\n        if (typeof attributeName === \"string\") {\n          const value = mutation.attributes[attributeName];\n          if (value === null) {\n            target.removeAttribute(attributeName);\n          } else if (typeof value === \"string\") {\n            try {\n              if (attributeName === \"_cssText\" && (target.nodeName === \"LINK\" || target.nodeName === \"STYLE\")) {\n                try {\n                  const newSn = mirror2.getMeta(\n                    target\n                  );\n                  const newNode = buildNodeWithSN(\n                    {\n                      ...newSn,\n                      attributes: {\n                        ...newSn.attributes,\n                        ...mutation.attributes\n                      }\n                    },\n                    {\n                      doc: target.ownerDocument,\n                      // can be Document or RRDocument\n                      mirror: mirror2,\n                      skipChild: true,\n                      hackCss: true,\n                      cache: this.cache\n                    }\n                  );\n                  const siblingNode = target.nextSibling;\n                  const parentNode = target.parentNode;\n                  if (newNode && parentNode) {\n                    parentNode.removeChild(target);\n                    parentNode.insertBefore(\n                      newNode,\n                      siblingNode\n                    );\n                    mirror2.replace(mutation.id, newNode);\n                    break;\n                  }\n                } catch (e2) {\n                }\n              }\n              target.setAttribute(\n                attributeName,\n                value\n              );\n            } catch (error) {\n              this.warn(\n                \"An error occurred may due to the checkout feature.\",\n                error\n              );\n            }\n          } else if (attributeName === \"style\") {\n            const styleValues = value;\n            const targetEl = target;\n            for (const s2 in styleValues) {\n              if (styleValues[s2] === false) {\n                targetEl.style.removeProperty(s2);\n              } else if (styleValues[s2] instanceof Array) {\n                const svp = styleValues[s2];\n                targetEl.style.setProperty(s2, svp[0], svp[1]);\n              } else {\n                const svs = styleValues[s2];\n                targetEl.style.setProperty(s2, svs);\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Apply the scroll data on real elements.\n   * If the replayer is in sync mode, smooth scroll behavior should be disabled.\n   * @param d - the scroll data\n   * @param isSync - whether the replayer is in sync mode(fast-forward)\n   */\n  applyScroll(d, isSync) {\n    const target = this.mirror.getNode(d.id);\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n    const sn = this.mirror.getMeta(target);\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    if (target === iframeDoc) {\n      this.iframe.contentWindow?.scrollTo({\n        top: d.y,\n        left: d.x,\n        behavior: isSync ? \"auto\" : \"smooth\"\n      });\n    } else if (sn?.type === NodeType$2.Document) {\n      target.defaultView?.scrollTo({\n        top: d.y,\n        left: d.x,\n        behavior: isSync ? \"auto\" : \"smooth\"\n      });\n    } else {\n      try {\n        target.scrollTo({\n          top: d.y,\n          left: d.x,\n          behavior: isSync ? \"auto\" : \"smooth\"\n        });\n      } catch (error) {\n      }\n    }\n  }\n  applyInput(d) {\n    const target = this.mirror.getNode(d.id);\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n    try {\n      target.checked = d.isChecked;\n      target.value = d.text;\n    } catch (error) {\n    }\n  }\n  applySelection(d) {\n    try {\n      const selectionSet = /* @__PURE__ */ new Set();\n      const ranges = d.ranges.map(({ start, startOffset, end, endOffset }) => {\n        const startContainer = this.mirror.getNode(start);\n        const endContainer = this.mirror.getNode(end);\n        if (!startContainer || !endContainer) return;\n        const result = new Range();\n        result.setStart(startContainer, startOffset);\n        result.setEnd(endContainer, endOffset);\n        const doc = startContainer.ownerDocument;\n        const selection = doc?.getSelection();\n        selection && selectionSet.add(selection);\n        return {\n          range: result,\n          selection\n        };\n      });\n      selectionSet.forEach((s2) => s2.removeAllRanges());\n      ranges.forEach((r2) => r2 && r2.selection?.addRange(r2.range));\n    } catch (error) {\n    }\n  }\n  applyStyleSheetMutation(data) {\n    let styleSheet = null;\n    if (data.styleId) styleSheet = this.styleMirror.getStyle(data.styleId);\n    else if (data.id)\n      styleSheet = this.mirror.getNode(data.id)?.sheet || null;\n    if (!styleSheet) return;\n    if (data.source === IncrementalSource.StyleSheetRule)\n      this.applyStyleSheetRule(data, styleSheet);\n    else if (data.source === IncrementalSource.StyleDeclaration)\n      this.applyStyleDeclaration(data, styleSheet);\n  }\n  applyStyleSheetRule(data, styleSheet) {\n    data.adds?.forEach(({ rule, index: nestedIndex }) => {\n      try {\n        if (Array.isArray(nestedIndex)) {\n          const { positions, index } = getPositionsAndIndex(nestedIndex);\n          const nestedRule = getNestedRule(styleSheet.cssRules, positions);\n          nestedRule.insertRule(rule, index);\n        } else {\n          const index = nestedIndex === void 0 ? void 0 : Math.min(nestedIndex, styleSheet.cssRules.length);\n          styleSheet?.insertRule(rule, index);\n        }\n      } catch (e2) {\n      }\n    });\n    data.removes?.forEach(({ index: nestedIndex }) => {\n      try {\n        if (Array.isArray(nestedIndex)) {\n          const { positions, index } = getPositionsAndIndex(nestedIndex);\n          const nestedRule = getNestedRule(styleSheet.cssRules, positions);\n          nestedRule.deleteRule(index || 0);\n        } else {\n          styleSheet?.deleteRule(nestedIndex);\n        }\n      } catch (e2) {\n      }\n    });\n    if (data.replace)\n      try {\n        void styleSheet.replace?.(data.replace);\n      } catch (e2) {\n      }\n    if (data.replaceSync)\n      try {\n        styleSheet.replaceSync?.(data.replaceSync);\n      } catch (e2) {\n      }\n  }\n  applyStyleDeclaration(data, styleSheet) {\n    if (data.set) {\n      const rule = getNestedRule(\n        styleSheet.rules,\n        data.index\n      );\n      rule && rule.style && rule.style.setProperty(\n        data.set.property,\n        data.set.value,\n        data.set.priority\n      );\n    }\n    if (data.remove) {\n      const rule = getNestedRule(\n        styleSheet.rules,\n        data.index\n      );\n      rule && rule.style && rule.style.removeProperty(data.remove.property);\n    }\n  }\n  applyAdoptedStyleSheet(data) {\n    const targetHost = this.mirror.getNode(data.id);\n    if (!targetHost) return;\n    data.styles?.forEach((style) => {\n      let newStyleSheet = null;\n      let hostWindow = null;\n      if (hasShadowRoot(targetHost))\n        hostWindow = targetHost.ownerDocument?.defaultView || null;\n      else if (targetHost.nodeName === \"#document\")\n        hostWindow = targetHost.defaultView;\n      if (!hostWindow) return;\n      try {\n        newStyleSheet = new hostWindow.CSSStyleSheet();\n        this.styleMirror.add(newStyleSheet, style.styleId);\n        this.applyStyleSheetRule(\n          {\n            source: IncrementalSource.StyleSheetRule,\n            adds: style.rules\n          },\n          newStyleSheet\n        );\n      } catch (e2) {\n      }\n    });\n    const MAX_RETRY_TIME = 10;\n    let count = 0;\n    const adoptStyleSheets = (targetHost2, styleIds) => {\n      const stylesToAdopt = styleIds.map((styleId) => this.styleMirror.getStyle(styleId)).filter((style) => style !== null);\n      if (hasShadowRoot(targetHost2))\n        targetHost2.shadowRoot.adoptedStyleSheets = stylesToAdopt;\n      else if (targetHost2.nodeName === \"#document\")\n        targetHost2.adoptedStyleSheets = stylesToAdopt;\n      if (stylesToAdopt.length !== styleIds.length && count < MAX_RETRY_TIME) {\n        setTimeout$1(\n          () => adoptStyleSheets(targetHost2, styleIds),\n          0 + 100 * count\n        );\n        count++;\n      }\n    };\n    adoptStyleSheets(targetHost, data.styleIds);\n  }\n  legacy_resolveMissingNode(map, parent, target, targetMutation) {\n    const { previousId, nextId } = targetMutation;\n    const previousInMap = previousId && map[previousId];\n    const nextInMap = nextId && map[nextId];\n    if (previousInMap) {\n      const { node, mutation } = previousInMap;\n      parent.insertBefore(node, target);\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node, mutation);\n      }\n    }\n    if (nextInMap) {\n      const { node, mutation } = nextInMap;\n      parent.insertBefore(\n        node,\n        target.nextSibling\n      );\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node, mutation);\n      }\n    }\n  }\n  moveAndHover(x, y, id, isSync, debugData, pointerId) {\n    const target = this.mirror.getNode(id);\n    if (!target) {\n      return this.debugNodeNotFound(debugData, id);\n    }\n    const base = getBaseDimension(target, this.iframe);\n    const _x = x * base.absoluteScale + base.x;\n    const _y = y * base.absoluteScale + base.y;\n    const pointer = this.pointers[pointerId];\n    if (pointer && pointer.pointerEl) {\n      pointer.pointerEl.style.left = `${_x}px`;\n      pointer.pointerEl.style.top = `${_y}px`;\n    }\n    if (!isSync) {\n      this.drawMouseTail({ x: _x, y: _y }, pointerId);\n    }\n    this.hoverElements(target);\n  }\n  drawMouseTail(position, pointerId) {\n    const pointer = this.pointers[pointerId];\n    if (!pointer || !pointer.mouseTail) {\n      return;\n    }\n    const { lineCap, lineWidth, strokeStyle, duration } = this.config.mouseTail === true ? defaultMouseTailConfig : Object.assign({}, defaultMouseTailConfig, this.config.mouseTail);\n    const draw = () => {\n      if (!pointer || !pointer.mouseTail) {\n        return;\n      }\n      const mouseTail = pointer.mouseTail;\n      const ctx = mouseTail.getContext(\"2d\");\n      if (!ctx || !pointer.tailPositions.length) {\n        return;\n      }\n      ctx.clearRect(0, 0, mouseTail.width, mouseTail.height);\n      ctx.beginPath();\n      ctx.lineWidth = lineWidth;\n      ctx.lineCap = lineCap;\n      ctx.strokeStyle = strokeStyle;\n      ctx.moveTo(pointer.tailPositions[0].x, pointer.tailPositions[0].y);\n      pointer.tailPositions.forEach((p) => ctx.lineTo(p.x, p.y));\n      ctx.stroke();\n    };\n    pointer.tailPositions.push(position);\n    draw();\n    setTimeout$1(() => {\n      if (pointerId in this.pointers) {\n        pointer.tailPositions = pointer.tailPositions.filter(\n          (p) => p !== position\n        );\n        draw();\n      }\n    }, duration / this.speedService.state.context.timer.speed);\n  }\n  hoverElements(el) {\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    const rootElement = this.lastHoveredRootNode || iframeDoc;\n    if (rootElement && typeof rootElement.querySelectorAll === \"function\") {\n      rootElement.querySelectorAll(\".\\\\:hover\").forEach((hoveredEl) => {\n        hoveredEl.classList.remove(\":hover\");\n      });\n    }\n    this.lastHoveredRootNode = el.getRootNode();\n    let currentEl = el;\n    while (currentEl) {\n      if (currentEl.classList) {\n        currentEl.classList.add(\":hover\");\n      }\n      currentEl = currentEl.parentElement;\n    }\n  }\n  isUserInteraction(event) {\n    if (event.type !== EventType.IncrementalSnapshot) {\n      return false;\n    }\n    return event.data.source > IncrementalSource.Mutation && event.data.source <= IncrementalSource.Input;\n  }\n  backToNormal() {\n    this.nextUserInteractionEvent = null;\n    if (this.speedService.state.matches(\"normal\")) {\n      return;\n    }\n    this.speedService.send({ type: \"BACK_TO_NORMAL\" });\n    this.emitter.emit(ReplayerEvents.SkipEnd, {\n      speed: this.speedService.state.context.normalSpeed\n    });\n  }\n  warnNodeNotFound(d, id) {\n    this.warn(`Node with id '${id}' not found. `, d);\n  }\n  warnCanvasMutationFailed(d, error) {\n    this.warn(`Has error on canvas update`, error, \"canvas mutation:\", d);\n  }\n  debugNodeNotFound(d, id) {\n    this.debug(`Node with id '${id}' not found. `, d);\n  }\n  warn(...args) {\n    if (!this.config.showWarning) {\n      return;\n    }\n    this.config.logger.warn(REPLAY_CONSOLE_PREFIX, ...args);\n  }\n  debug(...args) {\n    if (!this.config.showDebug) {\n      return;\n    }\n    this.config.logger.log(REPLAY_CONSOLE_PREFIX, ...args);\n  }\n}\nexport {\n  CanvasManager,\n  EventType,\n  IncrementalSource,\n  MouseInteractions,\n  Replayer,\n  ReplayerEvents,\n  addCustomEvent,\n  canvasMutation,\n  deserializeArg,\n  freezePage,\n  record,\n  takeFullSnapshot,\n  utils\n};\n//# sourceMappingURL=rrweb.js.map\n","import type { Integration, IntegrationFn } from '@sentry/core';\nimport { defineIntegration } from '@sentry/core';\nimport type { CanvasManagerInterface, CanvasManagerOptions } from '@sentry-internal/replay';\nimport { CanvasManager } from '@sentry-internal/rrweb';\n\ninterface ReplayCanvasIntegration extends Integration {\n  snapshot: (canvasElement?: HTMLCanvasElement) => Promise<void>;\n}\n\ninterface ReplayCanvasOptions {\n  enableManualSnapshot?: boolean;\n  maxCanvasSize?: [width: number, height: number];\n  quality: 'low' | 'medium' | 'high';\n}\n\ntype GetCanvasManager = (options: CanvasManagerOptions) => CanvasManagerInterface;\nexport interface ReplayCanvasIntegrationOptions {\n  enableManualSnapshot?: boolean;\n  maxCanvasSize?: number;\n  recordCanvas: true;\n  getCanvasManager: GetCanvasManager;\n  sampling: {\n    canvas: number;\n  };\n  dataURLOptions: {\n    type: string;\n    quality: number;\n  };\n}\n\nconst CANVAS_QUALITY = {\n  low: {\n    sampling: {\n      canvas: 1,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.25,\n    },\n  },\n  medium: {\n    sampling: {\n      canvas: 2,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.4,\n    },\n  },\n  high: {\n    sampling: {\n      canvas: 4,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.5,\n    },\n  },\n};\n\nconst INTEGRATION_NAME = 'ReplayCanvas';\nconst DEFAULT_MAX_CANVAS_SIZE = 1280;\n\n/** Exported only for type safe tests. */\nexport const _replayCanvasIntegration = ((options: Partial<ReplayCanvasOptions> = {}) => {\n  const [maxCanvasWidth, maxCanvasHeight] = options.maxCanvasSize || [];\n  const _canvasOptions = {\n    quality: options.quality || 'medium',\n    enableManualSnapshot: options.enableManualSnapshot,\n    maxCanvasSize: [\n      maxCanvasWidth ? Math.min(maxCanvasWidth, DEFAULT_MAX_CANVAS_SIZE) : DEFAULT_MAX_CANVAS_SIZE,\n      maxCanvasHeight ? Math.min(maxCanvasHeight, DEFAULT_MAX_CANVAS_SIZE) : DEFAULT_MAX_CANVAS_SIZE,\n    ] as [number, number],\n  };\n\n  let canvasManagerResolve: (value: CanvasManager) => void;\n  const _canvasManager: Promise<CanvasManager> = new Promise(resolve => (canvasManagerResolve = resolve));\n\n  return {\n    name: INTEGRATION_NAME,\n    getOptions(): ReplayCanvasIntegrationOptions {\n      const { quality, enableManualSnapshot, maxCanvasSize } = _canvasOptions;\n\n      return {\n        enableManualSnapshot,\n        recordCanvas: true,\n        getCanvasManager: (getCanvasManagerOptions: CanvasManagerOptions) => {\n          const manager = new CanvasManager({\n            ...getCanvasManagerOptions,\n            enableManualSnapshot,\n            maxCanvasSize,\n            errorHandler: (err: unknown) => {\n              try {\n                if (typeof err === 'object') {\n                  (err as Error & { __rrweb__?: boolean }).__rrweb__ = true;\n                }\n              } catch (error) {\n                // ignore errors here\n                // this can happen if the error is frozen or does not allow mutation for other reasons\n              }\n            },\n          });\n          canvasManagerResolve(manager);\n          return manager;\n        },\n        ...(CANVAS_QUALITY[quality || 'medium'] || CANVAS_QUALITY.medium),\n      };\n    },\n    async snapshot(canvasElement?: HTMLCanvasElement) {\n      const canvasManager = await _canvasManager;\n      canvasManager.snapshot(canvasElement);\n    },\n  };\n}) satisfies IntegrationFn<ReplayCanvasIntegration>;\n\n/**\n * Add this in addition to `replayIntegration()` to enable canvas recording.\n */\nexport const replayCanvasIntegration = defineIntegration(\n  _replayCanvasIntegration,\n) as IntegrationFn<ReplayCanvasIntegration>;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4333, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4338, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/commons.js"],"sourcesContent":["const PACKET_TYPES = Object.create(null); // no Map = no polyfill\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nObject.keys(PACKET_TYPES).forEach((key) => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\nexport { PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET };\n"],"names":[],"mappings":";;;;;AAAA,MAAM,eAAe,OAAO,MAAM,CAAC,OAAO,uBAAuB;AACjE,YAAY,CAAC,OAAO,GAAG;AACvB,YAAY,CAAC,QAAQ,GAAG;AACxB,YAAY,CAAC,OAAO,GAAG;AACvB,YAAY,CAAC,OAAO,GAAG;AACvB,YAAY,CAAC,UAAU,GAAG;AAC1B,YAAY,CAAC,UAAU,GAAG;AAC1B,YAAY,CAAC,OAAO,GAAG;AACvB,MAAM,uBAAuB,OAAO,MAAM,CAAC;AAC3C,OAAO,IAAI,CAAC,cAAc,OAAO,CAAC,CAAC;IAC/B,oBAAoB,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG;AAC9C;AACA,MAAM,eAAe;IAAE,MAAM;IAAS,MAAM;AAAe"}},
    {"offset": {"line": 4360, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4365, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/encodePacket.browser.js"],"sourcesContent":["import { PACKET_TYPES } from \"./commons.js\";\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer &&\n        (data instanceof ArrayBuffer || isView(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + (content || \"\"));\n    };\n    return fileReader.readAsDataURL(data);\n};\nfunction toArray(data) {\n    if (data instanceof Uint8Array) {\n        return data;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n    }\n    else {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    }\n}\nlet TEXT_ENCODER;\nexport function encodePacketToBinary(packet, callback) {\n    if (withNativeBlob && packet.data instanceof Blob) {\n        return packet.data.arrayBuffer().then(toArray).then(callback);\n    }\n    else if (withNativeArrayBuffer &&\n        (packet.data instanceof ArrayBuffer || isView(packet.data))) {\n        return callback(toArray(packet.data));\n    }\n    encodePacket(packet, false, (encoded) => {\n        if (!TEXT_ENCODER) {\n            TEXT_ENCODER = new TextEncoder();\n        }\n        callback(TEXT_ENCODER.encode(encoded));\n    });\n}\nexport { encodePacket };\n"],"names":[],"mappings":";;;;;;;AACA,MAAM,iBAAiB,OAAO,SAAS,cAClC,OAAO,SAAS,eACb,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU;AACjD,MAAM,wBAAwB,OAAO,gBAAgB;AACrD,mDAAmD;AACnD,MAAM,SAAS,CAAC;IACZ,OAAO,OAAO,YAAY,MAAM,KAAK,aAC/B,YAAY,MAAM,CAAC,OACnB,OAAO,IAAI,MAAM,YAAY;AACvC;AACA,MAAM,eAAe,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,gBAAgB;IAClD,IAAI,kBAAkB,gBAAgB,MAAM;QACxC,IAAI,gBAAgB;YAChB,OAAO,SAAS;QACpB,OACK;YACD,OAAO,mBAAmB,MAAM;QACpC;IACJ,OACK,IAAI,yBACL,CAAC,gBAAgB,eAAe,OAAO,KAAK,GAAG;QAC/C,IAAI,gBAAgB;YAChB,OAAO,SAAS;QACpB,OACK;YACD,OAAO,mBAAmB,IAAI,KAAK;gBAAC;aAAK,GAAG;QAChD;IACJ;IACA,eAAe;IACf,OAAO,SAAS,uOAAA,CAAA,eAAY,CAAC,KAAK,GAAG,CAAC,QAAQ,EAAE;AACpD;AACA,MAAM,qBAAqB,CAAC,MAAM;IAC9B,MAAM,aAAa,IAAI;IACvB,WAAW,MAAM,GAAG;QAChB,MAAM,UAAU,WAAW,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;QAC/C,SAAS,MAAM,CAAC,WAAW,EAAE;IACjC;IACA,OAAO,WAAW,aAAa,CAAC;AACpC;AACA,SAAS,QAAQ,IAAI;IACjB,IAAI,gBAAgB,YAAY;QAC5B,OAAO;IACX,OACK,IAAI,gBAAgB,aAAa;QAClC,OAAO,IAAI,WAAW;IAC1B,OACK;QACD,OAAO,IAAI,WAAW,KAAK,MAAM,EAAE,KAAK,UAAU,EAAE,KAAK,UAAU;IACvE;AACJ;AACA,IAAI;AACG,SAAS,qBAAqB,MAAM,EAAE,QAAQ;IACjD,IAAI,kBAAkB,OAAO,IAAI,YAAY,MAAM;QAC/C,OAAO,OAAO,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,SAAS,IAAI,CAAC;IACxD,OACK,IAAI,yBACL,CAAC,OAAO,IAAI,YAAY,eAAe,OAAO,OAAO,IAAI,CAAC,GAAG;QAC7D,OAAO,SAAS,QAAQ,OAAO,IAAI;IACvC;IACA,aAAa,QAAQ,OAAO,CAAC;QACzB,IAAI,CAAC,cAAc;YACf,eAAe,IAAI;QACvB;QACA,SAAS,aAAa,MAAM,CAAC;IACjC;AACJ"}},
    {"offset": {"line": 4429, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4434, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js"],"sourcesContent":["// imported from https://github.com/socketio/base64-arraybuffer\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nexport const encode = (arraybuffer) => {\n    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nexport const decode = (base64) => {\n    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n"],"names":[],"mappings":"AAAA,+DAA+D;;;;;AAC/D,MAAM,QAAQ;AACd,wCAAwC;AACxC,MAAM,SAAS,OAAO,eAAe,cAAc,EAAE,GAAG,IAAI,WAAW;AACvE,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;IACnC,MAAM,CAAC,MAAM,UAAU,CAAC,GAAG,GAAG;AAClC;AACO,MAAM,SAAS,CAAC;IACnB,IAAI,QAAQ,IAAI,WAAW,cAAc,GAAG,MAAM,MAAM,MAAM,EAAE,SAAS;IACzE,IAAK,IAAI,GAAG,IAAI,KAAK,KAAK,EAAG;QACzB,UAAU,KAAK,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE;QAC9B,UAAU,KAAK,CAAC,AAAC,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC,KAAK,IAAM,KAAK,CAAC,IAAI,EAAE,IAAI,EAAG;QAC5D,UAAU,KAAK,CAAC,AAAC,CAAC,KAAK,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,IAAM,KAAK,CAAC,IAAI,EAAE,IAAI,EAAG;QACjE,UAAU,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,GAAG,GAAG;IACtC;IACA,IAAI,MAAM,MAAM,GAAG;QACf,SAAS,OAAO,SAAS,CAAC,GAAG,OAAO,MAAM,GAAG,KAAK;IACtD,OACK,IAAI,MAAM,MAAM,GAAG;QACpB,SAAS,OAAO,SAAS,CAAC,GAAG,OAAO,MAAM,GAAG,KAAK;IACtD;IACA,OAAO;AACX;AACO,MAAM,SAAS,CAAC;IACnB,IAAI,eAAe,OAAO,MAAM,GAAG,MAAM,MAAM,OAAO,MAAM,EAAE,GAAG,IAAI,GAAG,UAAU,UAAU,UAAU;IACtG,IAAI,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,KAAK,KAAK;QACnC;QACA,IAAI,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,KAAK,KAAK;YACnC;QACJ;IACJ;IACA,MAAM,cAAc,IAAI,YAAY,eAAe,QAAQ,IAAI,WAAW;IAC1E,IAAK,IAAI,GAAG,IAAI,KAAK,KAAK,EAAG;QACzB,WAAW,MAAM,CAAC,OAAO,UAAU,CAAC,GAAG;QACvC,WAAW,MAAM,CAAC,OAAO,UAAU,CAAC,IAAI,GAAG;QAC3C,WAAW,MAAM,CAAC,OAAO,UAAU,CAAC,IAAI,GAAG;QAC3C,WAAW,MAAM,CAAC,OAAO,UAAU,CAAC,IAAI,GAAG;QAC3C,KAAK,CAAC,IAAI,GAAG,AAAC,YAAY,IAAM,YAAY;QAC5C,KAAK,CAAC,IAAI,GAAG,AAAC,CAAC,WAAW,EAAE,KAAK,IAAM,YAAY;QACnD,KAAK,CAAC,IAAI,GAAG,AAAC,CAAC,WAAW,CAAC,KAAK,IAAM,WAAW;IACrD;IACA,OAAO;AACX"}},
    {"offset": {"line": 4480, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4485, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/decodePacket.browser.js"],"sourcesContent":["import { ERROR_PACKET, PACKET_TYPES_REVERSE, } from \"./commons.js\";\nimport { decode } from \"./contrib/base64-arraybuffer.js\";\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nexport const decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType),\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType),\n        };\n    }\n    const packetType = PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1),\n        }\n        : {\n            type: PACKET_TYPES_REVERSE[type],\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = decode(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            if (data instanceof Blob) {\n                // from WebSocket + binaryType \"blob\"\n                return data;\n            }\n            else {\n                // from HTTP long-polling or WebTransport\n                return new Blob([data]);\n            }\n        case \"arraybuffer\":\n        default:\n            if (data instanceof ArrayBuffer) {\n                // from HTTP long-polling (base64) or WebSocket + binaryType \"arraybuffer\"\n                return data;\n            }\n            else {\n                // from WebTransport (Uint8Array)\n                return data.buffer;\n            }\n    }\n};\n"],"names":[],"mappings":";;;;;;;;AAEA,MAAM,wBAAwB,OAAO,gBAAgB;AAC9C,MAAM,eAAe,CAAC,eAAe;IACxC,IAAI,OAAO,kBAAkB,UAAU;QACnC,OAAO;YACH,MAAM;YACN,MAAM,UAAU,eAAe;QACnC;IACJ;IACA,MAAM,OAAO,cAAc,MAAM,CAAC;IAClC,IAAI,SAAS,KAAK;QACd,OAAO;YACH,MAAM;YACN,MAAM,mBAAmB,cAAc,SAAS,CAAC,IAAI;QACzD;IACJ;IACA,MAAM,aAAa,uOAAA,CAAA,uBAAoB,CAAC,KAAK;IAC7C,IAAI,CAAC,YAAY;QACb,OAAO,uOAAA,CAAA,eAAY;IACvB;IACA,OAAO,cAAc,MAAM,GAAG,IACxB;QACE,MAAM,uOAAA,CAAA,uBAAoB,CAAC,KAAK;QAChC,MAAM,cAAc,SAAS,CAAC;IAClC,IACE;QACE,MAAM,uOAAA,CAAA,uBAAoB,CAAC,KAAK;IACpC;AACR;AACA,MAAM,qBAAqB,CAAC,MAAM;IAC9B,IAAI,uBAAuB;QACvB,MAAM,UAAU,CAAA,GAAA,gQAAA,CAAA,SAAM,AAAD,EAAE;QACvB,OAAO,UAAU,SAAS;IAC9B,OACK;QACD,OAAO;YAAE,QAAQ;YAAM;QAAK,GAAG,4BAA4B;IAC/D;AACJ;AACA,MAAM,YAAY,CAAC,MAAM;IACrB,OAAQ;QACJ,KAAK;YACD,IAAI,gBAAgB,MAAM;gBACtB,qCAAqC;gBACrC,OAAO;YACX,OACK;gBACD,yCAAyC;gBACzC,OAAO,IAAI,KAAK;oBAAC;iBAAK;YAC1B;QACJ,KAAK;QACL;YACI,IAAI,gBAAgB,aAAa;gBAC7B,0EAA0E;gBAC1E,OAAO;YACX,OACK;gBACD,iCAAiC;gBACjC,OAAO,KAAK,MAAM;YACtB;IACR;AACJ"}},
    {"offset": {"line": 4553, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4558, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/index.js"],"sourcesContent":["import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\nimport { decodePacket } from \"./decodePacket.js\";\nimport { ERROR_PACKET, } from \"./commons.js\";\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        encodePacket(packet, false, (encodedPacket) => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nexport function createPacketEncoderStream() {\n    return new TransformStream({\n        transform(packet, controller) {\n            encodePacketToBinary(packet, (encodedPacket) => {\n                const payloadLength = encodedPacket.length;\n                let header;\n                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\n                if (payloadLength < 126) {\n                    header = new Uint8Array(1);\n                    new DataView(header.buffer).setUint8(0, payloadLength);\n                }\n                else if (payloadLength < 65536) {\n                    header = new Uint8Array(3);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 126);\n                    view.setUint16(1, payloadLength);\n                }\n                else {\n                    header = new Uint8Array(9);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 127);\n                    view.setBigUint64(1, BigInt(payloadLength));\n                }\n                // first bit indicates whether the payload is plain text (0) or binary (1)\n                if (packet.data && typeof packet.data !== \"string\") {\n                    header[0] |= 0x80;\n                }\n                controller.enqueue(header);\n                controller.enqueue(encodedPacket);\n            });\n        },\n    });\n}\nlet TEXT_DECODER;\nfunction totalLength(chunks) {\n    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n}\nfunction concatChunks(chunks, size) {\n    if (chunks[0].length === size) {\n        return chunks.shift();\n    }\n    const buffer = new Uint8Array(size);\n    let j = 0;\n    for (let i = 0; i < size; i++) {\n        buffer[i] = chunks[0][j++];\n        if (j === chunks[0].length) {\n            chunks.shift();\n            j = 0;\n        }\n    }\n    if (chunks.length && j < chunks[0].length) {\n        chunks[0] = chunks[0].slice(j);\n    }\n    return buffer;\n}\nexport function createPacketDecoderStream(maxPayload, binaryType) {\n    if (!TEXT_DECODER) {\n        TEXT_DECODER = new TextDecoder();\n    }\n    const chunks = [];\n    let state = 0 /* State.READ_HEADER */;\n    let expectedLength = -1;\n    let isBinary = false;\n    return new TransformStream({\n        transform(chunk, controller) {\n            chunks.push(chunk);\n            while (true) {\n                if (state === 0 /* State.READ_HEADER */) {\n                    if (totalLength(chunks) < 1) {\n                        break;\n                    }\n                    const header = concatChunks(chunks, 1);\n                    isBinary = (header[0] & 0x80) === 0x80;\n                    expectedLength = header[0] & 0x7f;\n                    if (expectedLength < 126) {\n                        state = 3 /* State.READ_PAYLOAD */;\n                    }\n                    else if (expectedLength === 126) {\n                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */;\n                    }\n                    else {\n                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */;\n                    }\n                }\n                else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {\n                    if (totalLength(chunks) < 2) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 2);\n                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\n                    state = 3 /* State.READ_PAYLOAD */;\n                }\n                else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {\n                    if (totalLength(chunks) < 8) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 8);\n                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);\n                    const n = view.getUint32(0);\n                    if (n > Math.pow(2, 53 - 32) - 1) {\n                        // the maximum safe integer in JavaScript is 2^53 - 1\n                        controller.enqueue(ERROR_PACKET);\n                        break;\n                    }\n                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\n                    state = 3 /* State.READ_PAYLOAD */;\n                }\n                else {\n                    if (totalLength(chunks) < expectedLength) {\n                        break;\n                    }\n                    const data = concatChunks(chunks, expectedLength);\n                    controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\n                    state = 0 /* State.READ_HEADER */;\n                }\n                if (expectedLength === 0 || expectedLength > maxPayload) {\n                    controller.enqueue(ERROR_PACKET);\n                    break;\n                }\n            }\n        },\n    });\n}\nexport const protocol = 4;\nexport { encodePacket, encodePayload, decodePacket, decodePayload, };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4718, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4734, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@socket.io+component-emitter@3.1.2/node_modules/@socket.io/component-emitter/lib/esm/index.js"],"sourcesContent":["/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nexport function Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4865, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4870, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/globals.js"],"sourcesContent":["export const nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return (cb) => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nexport const globalThisShim = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\nexport const defaultBinaryType = \"arraybuffer\";\nexport function createCookieJar() { }\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,WAAW,CAAC;IACrB,MAAM,qBAAqB,OAAO,YAAY,cAAc,OAAO,QAAQ,OAAO,KAAK;IACvF,IAAI,oBAAoB;QACpB,OAAO,CAAC,KAAO,QAAQ,OAAO,GAAG,IAAI,CAAC;IAC1C,OACK;QACD,OAAO,CAAC,IAAI,eAAiB,aAAa,IAAI;IAClD;AACJ,CAAC;AACM,MAAM,iBAAiB,CAAC;IAC3B,IAAI,OAAO,SAAS,aAAa;QAC7B,OAAO;IACX,OACK,IAAI,OAAO,WAAW,aAAa;QACpC,OAAO;IACX,OACK;QACD,OAAO,SAAS;IACpB;AACJ,CAAC;AACM,MAAM,oBAAoB;AAC1B,SAAS,mBAAoB"}},
    {"offset": {"line": 4895, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4900, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/util.js"],"sourcesContent":["import { globalThisShim as globalThis } from \"./globals.node.js\";\nexport function pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = globalThis.setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = globalThis.clearTimeout;\nexport function installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis);\n    }\n    else {\n        obj.setTimeoutFn = globalThis.setTimeout.bind(globalThis);\n        obj.clearTimeoutFn = globalThis.clearTimeout.bind(globalThis);\n    }\n}\n// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\nconst BASE64_OVERHEAD = 1.33;\n// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\nexport function byteLength(obj) {\n    if (typeof obj === \"string\") {\n        return utf8Length(obj);\n    }\n    // arraybuffer or blob\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(str) {\n    let c = 0, length = 0;\n    for (let i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\n/**\n * Generates a random 8-characters string.\n */\nexport function randomString() {\n    return (Date.now().toString(36).substring(3) +\n        Math.random().toString(36).substring(2, 5));\n}\n"],"names":[],"mappings":";;;;;;;;;AACO,SAAS,KAAK,GAAG,EAAE,GAAG,IAAI;IAC7B,OAAO,KAAK,MAAM,CAAC,CAAC,KAAK;QACrB,IAAI,IAAI,cAAc,CAAC,IAAI;YACvB,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE;QACnB;QACA,OAAO;IACX,GAAG,CAAC;AACR;AACA,qFAAqF;AACrF,MAAM,qBAAqB,uOAAA,CAAA,iBAAU,CAAC,UAAU;AAChD,MAAM,uBAAuB,uOAAA,CAAA,iBAAU,CAAC,YAAY;AAC7C,SAAS,sBAAsB,GAAG,EAAE,IAAI;IAC3C,IAAI,KAAK,eAAe,EAAE;QACtB,IAAI,YAAY,GAAG,mBAAmB,IAAI,CAAC,uOAAA,CAAA,iBAAU;QACrD,IAAI,cAAc,GAAG,qBAAqB,IAAI,CAAC,uOAAA,CAAA,iBAAU;IAC7D,OACK;QACD,IAAI,YAAY,GAAG,uOAAA,CAAA,iBAAU,CAAC,UAAU,CAAC,IAAI,CAAC,uOAAA,CAAA,iBAAU;QACxD,IAAI,cAAc,GAAG,uOAAA,CAAA,iBAAU,CAAC,YAAY,CAAC,IAAI,CAAC,uOAAA,CAAA,iBAAU;IAChE;AACJ;AACA,qFAAqF;AACrF,MAAM,kBAAkB;AAEjB,SAAS,WAAW,GAAG;IAC1B,IAAI,OAAO,QAAQ,UAAU;QACzB,OAAO,WAAW;IACtB;IACA,sBAAsB;IACtB,OAAO,KAAK,IAAI,CAAC,CAAC,IAAI,UAAU,IAAI,IAAI,IAAI,IAAI;AACpD;AACA,SAAS,WAAW,GAAG;IACnB,IAAI,IAAI,GAAG,SAAS;IACpB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAI,GAAG,IAAK;QACxC,IAAI,IAAI,UAAU,CAAC;QACnB,IAAI,IAAI,MAAM;YACV,UAAU;QACd,OACK,IAAI,IAAI,OAAO;YAChB,UAAU;QACd,OACK,IAAI,IAAI,UAAU,KAAK,QAAQ;YAChC,UAAU;QACd,OACK;YACD;YACA,UAAU;QACd;IACJ;IACA,OAAO;AACX;AAIO,SAAS;IACZ,OAAQ,KAAK,GAAG,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,KACtC,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG;AAChD"}},
    {"offset": {"line": 4958, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4963, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/contrib/parseqs.js"],"sourcesContent":["// imported from https://github.com/galkn/querystring\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\nexport function encode(obj) {\n    let str = '';\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (str.length)\n                str += '&';\n            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n        }\n    }\n    return str;\n}\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\nexport function decode(qs) {\n    let qry = {};\n    let pairs = qs.split('&');\n    for (let i = 0, l = pairs.length; i < l; i++) {\n        let pair = pairs[i].split('=');\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n    return qry;\n}\n"],"names":[],"mappings":"AAAA,qDAAqD;AACrD;;;;;;CAMC;;;;AACM,SAAS,OAAO,GAAG;IACtB,IAAI,MAAM;IACV,IAAK,IAAI,KAAK,IAAK;QACf,IAAI,IAAI,cAAc,CAAC,IAAI;YACvB,IAAI,IAAI,MAAM,EACV,OAAO;YACX,OAAO,mBAAmB,KAAK,MAAM,mBAAmB,GAAG,CAAC,EAAE;QAClE;IACJ;IACA,OAAO;AACX;AAOO,SAAS,OAAO,EAAE;IACrB,IAAI,MAAM,CAAC;IACX,IAAI,QAAQ,GAAG,KAAK,CAAC;IACrB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAI,GAAG,IAAK;QAC1C,IAAI,OAAO,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC;QAC1B,GAAG,CAAC,mBAAmB,IAAI,CAAC,EAAE,EAAE,GAAG,mBAAmB,IAAI,CAAC,EAAE;IACjE;IACA,OAAO;AACX"}},
    {"offset": {"line": 4993, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4998, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transport.js"],"sourcesContent":["import { decodePacket } from \"engine.io-parser\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { installTimerFunctions } from \"./util.js\";\nimport { encode } from \"./contrib/parseqs.js\";\nexport class TransportError extends Error {\n    constructor(reason, description, context) {\n        super(reason);\n        this.description = description;\n        this.context = context;\n        this.type = \"TransportError\";\n    }\n}\nexport class Transport extends Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        installTimerFunctions(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.socket = opts.socket;\n        this.supportsBinary = !opts.forceBase64;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */\n    onError(reason, description, context) {\n        super.emitReserved(\"error\", new TransportError(reason, description, context));\n        return this;\n    }\n    /**\n     * Opens the transport.\n     */\n    open() {\n        this.readyState = \"opening\";\n        this.doOpen();\n        return this;\n    }\n    /**\n     * Closes the transport.\n     */\n    close() {\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     */\n    send(packets) {\n        if (this.readyState === \"open\") {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emitReserved(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @protected\n     */\n    onData(data) {\n        const packet = decodePacket(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @protected\n     */\n    onPacket(packet) {\n        super.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @protected\n     */\n    onClose(details) {\n        this.readyState = \"closed\";\n        super.emitReserved(\"close\", details);\n    }\n    /**\n     * Pauses the transport, in order not to lose packets during an upgrade.\n     *\n     * @param onPause\n     */\n    pause(onPause) { }\n    createUri(schema, query = {}) {\n        return (schema +\n            \"://\" +\n            this._hostname() +\n            this._port() +\n            this.opts.path +\n            this._query(query));\n    }\n    _hostname() {\n        const hostname = this.opts.hostname;\n        return hostname.indexOf(\":\") === -1 ? hostname : \"[\" + hostname + \"]\";\n    }\n    _port() {\n        if (this.opts.port &&\n            ((this.opts.secure && Number(this.opts.port !== 443)) ||\n                (!this.opts.secure && Number(this.opts.port) !== 80))) {\n            return \":\" + this.opts.port;\n        }\n        else {\n            return \"\";\n        }\n    }\n    _query(query) {\n        const encodedQuery = encode(query);\n        return encodedQuery.length ? \"?\" + encodedQuery : \"\";\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5131, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5136, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transports/polling.js"],"sourcesContent":["import { Transport } from \"../transport.js\";\nimport { randomString } from \"../util.js\";\nimport { encodePayload, decodePayload } from \"engine.io-parser\";\nexport class Polling extends Transport {\n    constructor() {\n        super(...arguments);\n        this._polling = false;\n    }\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @protected\n     */\n    doOpen() {\n        this._poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n     * @package\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this._polling || !this.writable) {\n            let total = 0;\n            if (this._polling) {\n                total++;\n                this.once(\"pollComplete\", function () {\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                total++;\n                this.once(\"drain\", function () {\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @private\n     */\n    _poll() {\n        this._polling = true;\n        this.doPoll();\n        this.emitReserved(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @protected\n     */\n    onData(data) {\n        const callback = (packet) => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose({ description: \"transport closed by the server\" });\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        decodePayload(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this._polling = false;\n            this.emitReserved(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this._poll();\n            }\n            else {\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @protected\n     */\n    doClose() {\n        const close = () => {\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} packets - data packets\n     * @protected\n     */\n    write(packets) {\n        this.writable = false;\n        encodePayload(packets, (data) => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emitReserved(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        const query = this.query || {};\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = randomString();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5284, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5289, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/contrib/has-cors.js"],"sourcesContent":["// imported from https://github.com/component/has-cors\nlet value = false;\ntry {\n    value = typeof XMLHttpRequest !== 'undefined' &&\n        'withCredentials' in new XMLHttpRequest();\n}\ncatch (err) {\n    // if XMLHttp support is disabled in IE then it will throw\n    // when trying to create\n}\nexport const hasCORS = value;\n"],"names":[],"mappings":"AAAA,sDAAsD;;;;AACtD,IAAI,QAAQ;AACZ,IAAI;IACA,QAAQ,OAAO,mBAAmB,eAC9B,qBAAqB,IAAI;AACjC,EACA,OAAO,KAAK;AACR,0DAA0D;AAC1D,wBAAwB;AAC5B;AACO,MAAM,UAAU"}},
    {"offset": {"line": 5301, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5306, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transports/polling-xhr.js"],"sourcesContent":["import { Polling } from \"./polling.js\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { installTimerFunctions, pick } from \"../util.js\";\nimport { globalThisShim as globalThis } from \"../globals.node.js\";\nimport { hasCORS } from \"../contrib/has-cors.js\";\nfunction empty() { }\nexport class BaseXHR extends Polling {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */\n    constructor(opts) {\n        super(opts);\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n        }\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data,\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr post error\", xhrStatus, context);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @private\n     */\n    doPoll() {\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr poll error\", xhrStatus, context);\n        });\n        this.pollXhr = req;\n    }\n}\nexport class Request extends Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */\n    constructor(createRequest, uri, opts) {\n        super();\n        this.createRequest = createRequest;\n        installTimerFunctions(this, opts);\n        this._opts = opts;\n        this._method = opts.method || \"GET\";\n        this._uri = uri;\n        this._data = undefined !== opts.data ? opts.data : null;\n        this._create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */\n    _create() {\n        var _a;\n        const opts = pick(this._opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this._opts.xd;\n        const xhr = (this._xhr = this.createRequest(opts));\n        try {\n            xhr.open(this._method, this._uri, true);\n            try {\n                if (this._opts.extraHeaders) {\n                    // @ts-ignore\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this._opts.extraHeaders) {\n                        if (this._opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this._method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this._opts.withCredentials;\n            }\n            if (this._opts.requestTimeout) {\n                xhr.timeout = this._opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                var _a;\n                if (xhr.readyState === 3) {\n                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(\n                    // @ts-ignore\n                    xhr.getResponseHeader(\"set-cookie\"));\n                }\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this._onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this._onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            xhr.send(this._data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this._onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this._index = Request.requestsCount++;\n            Request.requests[this._index] = this;\n        }\n    }\n    /**\n     * Called upon error.\n     *\n     * @private\n     */\n    _onError(err) {\n        this.emitReserved(\"error\", err, this._xhr);\n        this._cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @private\n     */\n    _cleanup(fromError) {\n        if (\"undefined\" === typeof this._xhr || null === this._xhr) {\n            return;\n        }\n        this._xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this._xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this._index];\n        }\n        this._xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @private\n     */\n    _onLoad() {\n        const data = this._xhr.responseText;\n        if (data !== null) {\n            this.emitReserved(\"data\", data);\n            this.emitReserved(\"success\");\n            this._cleanup();\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @package\n     */\n    abort() {\n        this._cleanup();\n    }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in globalThis ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\nconst hasXHR2 = (function () {\n    const xhr = newRequest({\n        xdomain: false,\n    });\n    return xhr && xhr.responseType !== null;\n})();\n/**\n * HTTP long-polling based on the built-in `XMLHttpRequest` object.\n *\n * Usage: browser\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n */\nexport class XHR extends BaseXHR {\n    constructor(opts) {\n        super(opts);\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd }, this.opts);\n        return new Request(newRequest, this.uri(), opts);\n    }\n}\nfunction newRequest(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new globalThis[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5561, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5566, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transports/websocket.js"],"sourcesContent":["import { Transport } from \"../transport.js\";\nimport { pick, randomString } from \"../util.js\";\nimport { encodePacket } from \"engine.io-parser\";\nimport { globalThisShim as globalThis, nextTick } from \"../globals.node.js\";\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nexport class BaseWS extends Transport {\n    get name() {\n        return \"websocket\";\n    }\n    doOpen() {\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws = this.createSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = (closeEvent) => this.onClose({\n            description: \"websocket connection closed\",\n            context: closeEvent,\n        });\n        this.ws.onmessage = (ev) => this.onData(ev.data);\n        this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n    }\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            encodePacket(packet, this.supportsBinary, (data) => {\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    this.doWrite(packet, data);\n                }\n                catch (e) {\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    nextTick(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.onerror = () => { };\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        const query = this.query || {};\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = randomString();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n}\nconst WebSocketCtor = globalThis.WebSocket || globalThis.MozWebSocket;\n/**\n * WebSocket transport based on the built-in `WebSocket` object.\n *\n * Usage: browser, Node.js (since v21), Deno, Bun\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n * @see https://caniuse.com/mdn-api_websocket\n * @see https://nodejs.org/api/globals.html#websocket\n */\nexport class WS extends BaseWS {\n    createSocket(uri, protocols, opts) {\n        return !isReactNative\n            ? protocols\n                ? new WebSocketCtor(uri, protocols)\n                : new WebSocketCtor(uri)\n            : new WebSocketCtor(uri, protocols, opts);\n    }\n    doWrite(_packet, data) {\n        this.ws.send(data);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5679, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5684, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transports/webtransport.js"],"sourcesContent":["import { Transport } from \"../transport.js\";\nimport { nextTick } from \"../globals.node.js\";\nimport { createPacketDecoderStream, createPacketEncoderStream, } from \"engine.io-parser\";\n/**\n * WebTransport transport based on the built-in `WebTransport` object.\n *\n * Usage: browser, Node.js (with the `@fails-components/webtransport` package)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport\n * @see https://caniuse.com/webtransport\n */\nexport class WT extends Transport {\n    get name() {\n        return \"webtransport\";\n    }\n    doOpen() {\n        try {\n            // @ts-ignore\n            this._transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this._transport.closed\n            .then(() => {\n            this.onClose();\n        })\n            .catch((err) => {\n            this.onError(\"webtransport error\", err);\n        });\n        // note: we could have used async/await, but that would require some additional polyfills\n        this._transport.ready.then(() => {\n            this._transport.createBidirectionalStream().then((stream) => {\n                const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n                const reader = stream.readable.pipeThrough(decoderStream).getReader();\n                const encoderStream = createPacketEncoderStream();\n                encoderStream.readable.pipeTo(stream.writable);\n                this._writer = encoderStream.writable.getWriter();\n                const read = () => {\n                    reader\n                        .read()\n                        .then(({ done, value }) => {\n                        if (done) {\n                            return;\n                        }\n                        this.onPacket(value);\n                        read();\n                    })\n                        .catch((err) => {\n                    });\n                };\n                read();\n                const packet = { type: \"open\" };\n                if (this.query.sid) {\n                    packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n                }\n                this._writer.write(packet).then(() => this.onOpen());\n            });\n        });\n    }\n    write(packets) {\n        this.writable = false;\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            this._writer.write(packet).then(() => {\n                if (lastPacket) {\n                    nextTick(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        var _a;\n        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAWO,MAAM,WAAW,yOAAA,CAAA,YAAS;IAC7B,IAAI,OAAO;QACP,OAAO;IACX;IACA,SAAS;QACL,IAAI;YACA,aAAa;YACb,IAAI,CAAC,UAAU,GAAG,IAAI,aAAa,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC;QACrG,EACA,OAAO,KAAK;YACR,OAAO,IAAI,CAAC,YAAY,CAAC,SAAS;QACtC;QACA,IAAI,CAAC,UAAU,CAAC,MAAM,CACjB,IAAI,CAAC;YACN,IAAI,CAAC,OAAO;QAChB,GACK,KAAK,CAAC,CAAC;YACR,IAAI,CAAC,OAAO,CAAC,sBAAsB;QACvC;QACA,yFAAyF;QACzF,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC;YACvB,IAAI,CAAC,UAAU,CAAC,yBAAyB,GAAG,IAAI,CAAC,CAAC;gBAC9C,MAAM,gBAAgB,CAAA,GAAA,qPAAA,CAAA,4BAAyB,AAAD,EAAE,OAAO,gBAAgB,EAAE,IAAI,CAAC,MAAM,CAAC,UAAU;gBAC/F,MAAM,SAAS,OAAO,QAAQ,CAAC,WAAW,CAAC,eAAe,SAAS;gBACnE,MAAM,gBAAgB,CAAA,GAAA,qPAAA,CAAA,4BAAyB,AAAD;gBAC9C,cAAc,QAAQ,CAAC,MAAM,CAAC,OAAO,QAAQ;gBAC7C,IAAI,CAAC,OAAO,GAAG,cAAc,QAAQ,CAAC,SAAS;gBAC/C,MAAM,OAAO;oBACT,OACK,IAAI,GACJ,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE;wBACtB,IAAI,MAAM;4BACN;wBACJ;wBACA,IAAI,CAAC,QAAQ,CAAC;wBACd;oBACJ,GACK,KAAK,CAAC,CAAC,OACZ;gBACJ;gBACA;gBACA,MAAM,SAAS;oBAAE,MAAM;gBAAO;gBAC9B,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE;oBAChB,OAAO,IAAI,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC;gBAC/C;gBACA,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,IAAI,CAAC,IAAM,IAAI,CAAC,MAAM;YACrD;QACJ;IACJ;IACA,MAAM,OAAO,EAAE;QACX,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAAK;YACrC,MAAM,SAAS,OAAO,CAAC,EAAE;YACzB,MAAM,aAAa,MAAM,QAAQ,MAAM,GAAG;YAC1C,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,IAAI,CAAC;gBAC5B,IAAI,YAAY;oBACZ,CAAA,GAAA,uOAAA,CAAA,WAAQ,AAAD,EAAE;wBACL,IAAI,CAAC,QAAQ,GAAG;wBAChB,IAAI,CAAC,YAAY,CAAC;oBACtB,GAAG,IAAI,CAAC,YAAY;gBACxB;YACJ;QACJ;IACJ;IACA,UAAU;QACN,IAAI;QACJ,CAAC,KAAK,IAAI,CAAC,UAAU,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,KAAK;IACxE;AACJ"}},
    {"offset": {"line": 5759, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5764, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transports/index.js"],"sourcesContent":["import { XHR } from \"./polling-xhr.node.js\";\nimport { WS } from \"./websocket.node.js\";\nimport { WT } from \"./webtransport.js\";\nexport const transports = {\n    websocket: WS,\n    webtransport: WT,\n    polling: XHR,\n};\n"],"names":[],"mappings":";;;;;;;;;;AAGO,MAAM,aAAa;IACtB,WAAW,uPAAA,CAAA,KAAE;IACb,cAAc,0PAAA,CAAA,KAAE;IAChB,SAAS,4PAAA,CAAA,MAAG;AAChB"}},
    {"offset": {"line": 5779, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5784, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/contrib/parseuri.js"],"sourcesContent":["// imported from https://github.com/galkn/parseuri\n/**\n * Parses a URI\n *\n * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n *\n * See:\n * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n * - https://caniuse.com/url\n * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n *\n * History of the parse() method:\n * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\nconst re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nconst parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\nexport function parse(str) {\n    if (str.length > 8000) {\n        throw \"URI too long\";\n    }\n    const src = str, b = str.indexOf('['), e = str.indexOf(']');\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n    let m = re.exec(str || ''), uri = {}, i = 14;\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n    return uri;\n}\nfunction pathNames(obj, path) {\n    const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n    if (path.slice(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.slice(-1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n    return names;\n}\nfunction queryKey(uri, query) {\n    const data = {};\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n    return data;\n}\n"],"names":[],"mappings":"AAAA,kDAAkD;AAClD;;;;;;;;;;;;;;;;;CAiBC;;;AACD,MAAM,KAAK;AACX,MAAM,QAAQ;IACV;IAAU;IAAY;IAAa;IAAY;IAAQ;IAAY;IAAQ;IAAQ;IAAY;IAAQ;IAAa;IAAQ;IAAS;CACxI;AACM,SAAS,MAAM,GAAG;IACrB,IAAI,IAAI,MAAM,GAAG,MAAM;QACnB,MAAM;IACV;IACA,MAAM,MAAM,KAAK,IAAI,IAAI,OAAO,CAAC,MAAM,IAAI,IAAI,OAAO,CAAC;IACvD,IAAI,KAAK,CAAC,KAAK,KAAK,CAAC,GAAG;QACpB,MAAM,IAAI,SAAS,CAAC,GAAG,KAAK,IAAI,SAAS,CAAC,GAAG,GAAG,OAAO,CAAC,MAAM,OAAO,IAAI,SAAS,CAAC,GAAG,IAAI,MAAM;IACpG;IACA,IAAI,IAAI,GAAG,IAAI,CAAC,OAAO,KAAK,MAAM,CAAC,GAAG,IAAI;IAC1C,MAAO,IAAK;QACR,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI;IAC5B;IACA,IAAI,KAAK,CAAC,KAAK,KAAK,CAAC,GAAG;QACpB,IAAI,MAAM,GAAG;QACb,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,GAAG,GAAG,OAAO,CAAC,MAAM;QACpE,IAAI,SAAS,GAAG,IAAI,SAAS,CAAC,OAAO,CAAC,KAAK,IAAI,OAAO,CAAC,KAAK,IAAI,OAAO,CAAC,MAAM;QAC9E,IAAI,OAAO,GAAG;IAClB;IACA,IAAI,SAAS,GAAG,UAAU,KAAK,GAAG,CAAC,OAAO;IAC1C,IAAI,QAAQ,GAAG,SAAS,KAAK,GAAG,CAAC,QAAQ;IACzC,OAAO;AACX;AACA,SAAS,UAAU,GAAG,EAAE,IAAI;IACxB,MAAM,OAAO,YAAY,QAAQ,KAAK,OAAO,CAAC,MAAM,KAAK,KAAK,CAAC;IAC/D,IAAI,KAAK,KAAK,CAAC,GAAG,MAAM,OAAO,KAAK,MAAM,KAAK,GAAG;QAC9C,MAAM,MAAM,CAAC,GAAG;IACpB;IACA,IAAI,KAAK,KAAK,CAAC,CAAC,MAAM,KAAK;QACvB,MAAM,MAAM,CAAC,MAAM,MAAM,GAAG,GAAG;IACnC;IACA,OAAO;AACX;AACA,SAAS,SAAS,GAAG,EAAE,KAAK;IACxB,MAAM,OAAO,CAAC;IACd,MAAM,OAAO,CAAC,6BAA6B,SAAU,EAAE,EAAE,EAAE,EAAE,EAAE;QAC3D,IAAI,IAAI;YACJ,IAAI,CAAC,GAAG,GAAG;QACf;IACJ;IACA,OAAO;AACX"}},
    {"offset": {"line": 5863, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5868, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/socket.js"],"sourcesContent":["import { transports as DEFAULT_TRANSPORTS } from \"./transports/index.js\";\nimport { installTimerFunctions, byteLength } from \"./util.js\";\nimport { decode } from \"./contrib/parseqs.js\";\nimport { parse } from \"./contrib/parseuri.js\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { protocol } from \"engine.io-parser\";\nimport { createCookieJar, defaultBinaryType, nextTick, } from \"./globals.node.js\";\nconst withEventListeners = typeof addEventListener === \"function\" &&\n    typeof removeEventListener === \"function\";\nconst OFFLINE_EVENT_LISTENERS = [];\nif (withEventListeners) {\n    // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the\n    // script, so we create one single event listener here which will forward the event to the socket instances\n    addEventListener(\"offline\", () => {\n        OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());\n    }, false);\n}\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that\n * successfully establishes the connection.\n *\n * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.\n *\n * @example\n * import { SocketWithoutUpgrade, WebSocket } from \"engine.io-client\";\n *\n * const socket = new SocketWithoutUpgrade({\n *   transports: [WebSocket]\n * });\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithUpgrade\n * @see Socket\n */\nexport class SocketWithoutUpgrade extends Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */\n    constructor(uri, opts) {\n        super();\n        this.binaryType = defaultBinaryType;\n        this.writeBuffer = [];\n        this._prevBufferLen = 0;\n        this._pingInterval = -1;\n        this._pingTimeout = -1;\n        this._maxPayload = -1;\n        /**\n         * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the\n         * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.\n         */\n        this._pingTimeoutTime = Infinity;\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            const parsedUri = parse(uri);\n            opts.hostname = parsedUri.host;\n            opts.secure =\n                parsedUri.protocol === \"https\" || parsedUri.protocol === \"wss\";\n            opts.port = parsedUri.port;\n            if (parsedUri.query)\n                opts.query = parsedUri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = parse(opts.host).host;\n        }\n        installTimerFunctions(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = [];\n        this._transportsByName = {};\n        opts.transports.forEach((t) => {\n            const transportName = t.prototype.name;\n            this.transports.push(transportName);\n            this._transportsByName[transportName] = t;\n        });\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            addTrailingSlash: true,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024,\n            },\n            transportOptions: {},\n            closeOnBeforeunload: false,\n        }, opts);\n        this.opts.path =\n            this.opts.path.replace(/\\/$/, \"\") +\n                (this.opts.addTrailingSlash ? \"/\" : \"\");\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = decode(this.opts.query);\n        }\n        if (withEventListeners) {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                this._beforeunloadEventListener = () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                };\n                addEventListener(\"beforeunload\", this._beforeunloadEventListener, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this._offlineEventListener = () => {\n                    this._onClose(\"transport close\", {\n                        description: \"network connection lost\",\n                    });\n                };\n                OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);\n            }\n        }\n        if (this.opts.withCredentials) {\n            this._cookieJar = createCookieJar();\n        }\n        this._open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */\n    createTransport(name) {\n        const query = Object.assign({}, this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port,\n        }, this.opts.transportOptions[name]);\n        return new this._transportsByName[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @private\n     */\n    _open() {\n        if (this.transports.length === 0) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        const transportName = this.opts.rememberUpgrade &&\n            SocketWithoutUpgrade.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1\n            ? \"websocket\"\n            : this.transports[0];\n        this.readyState = \"opening\";\n        const transport = this.createTransport(transportName);\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @private\n     */\n    setTransport(transport) {\n        if (this.transport) {\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this._onDrain.bind(this))\n            .on(\"packet\", this._onPacket.bind(this))\n            .on(\"error\", this._onError.bind(this))\n            .on(\"close\", (reason) => this._onClose(\"transport close\", reason));\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        SocketWithoutUpgrade.priorWebsocketSuccess =\n            \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n    }\n    /**\n     * Handles a packet.\n     *\n     * @private\n     */\n    _onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this._sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    this._resetPingTimeout();\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this._onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this._pingInterval = data.pingInterval;\n        this._pingTimeout = data.pingTimeout;\n        this._maxPayload = data.maxPayload;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this._resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @private\n     */\n    _resetPingTimeout() {\n        this.clearTimeoutFn(this._pingTimeoutTimer);\n        const delay = this._pingInterval + this._pingTimeout;\n        this._pingTimeoutTime = Date.now() + delay;\n        this._pingTimeoutTimer = this.setTimeoutFn(() => {\n            this._onClose(\"ping timeout\");\n        }, delay);\n        if (this.opts.autoUnref) {\n            this._pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @private\n     */\n    _onDrain() {\n        this.writeBuffer.splice(0, this._prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this._prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            const packets = this._getWritablePackets();\n            this.transport.send(packets);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this._prevBufferLen = packets.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n     * long-polling)\n     *\n     * @private\n     */\n    _getWritablePackets() {\n        const shouldCheckPayloadSize = this._maxPayload &&\n            this.transport.name === \"polling\" &&\n            this.writeBuffer.length > 1;\n        if (!shouldCheckPayloadSize) {\n            return this.writeBuffer;\n        }\n        let payloadSize = 1; // first packet type\n        for (let i = 0; i < this.writeBuffer.length; i++) {\n            const data = this.writeBuffer[i].data;\n            if (data) {\n                payloadSize += byteLength(data);\n            }\n            if (i > 0 && payloadSize > this._maxPayload) {\n                return this.writeBuffer.slice(0, i);\n            }\n            payloadSize += 2; // separator + packet type\n        }\n        return this.writeBuffer;\n    }\n    /**\n     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.\n     *\n     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the\n     * `write()` method then the message would not be buffered by the Socket.IO client.\n     *\n     * @return {boolean}\n     * @private\n     */\n    /* private */ _hasPingExpired() {\n        if (!this._pingTimeoutTime)\n            return true;\n        const hasExpired = Date.now() > this._pingTimeoutTime;\n        if (hasExpired) {\n            this._pingTimeoutTime = 0;\n            nextTick(() => {\n                this._onClose(\"ping timeout\");\n            }, this.setTimeoutFn);\n        }\n        return hasExpired;\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @return {Socket} for chaining.\n     */\n    write(msg, options, fn) {\n        this._sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a message. Alias of {@link Socket#write}.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @return {Socket} for chaining.\n     */\n    send(msg, options, fn) {\n        this._sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type: packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @private\n     */\n    _sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options,\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     */\n    close() {\n        const close = () => {\n            this._onClose(\"forced close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @private\n     */\n    _onError(err) {\n        SocketWithoutUpgrade.priorWebsocketSuccess = false;\n        if (this.opts.tryAllTransports &&\n            this.transports.length > 1 &&\n            this.readyState === \"opening\") {\n            this.transports.shift();\n            return this._open();\n        }\n        this.emitReserved(\"error\", err);\n        this._onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @private\n     */\n    _onClose(reason, description) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            // clear timers\n            this.clearTimeoutFn(this._pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (withEventListeners) {\n                if (this._beforeunloadEventListener) {\n                    removeEventListener(\"beforeunload\", this._beforeunloadEventListener, false);\n                }\n                if (this._offlineEventListener) {\n                    const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);\n                    if (i !== -1) {\n                        OFFLINE_EVENT_LISTENERS.splice(i, 1);\n                    }\n                }\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, description);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this._prevBufferLen = 0;\n        }\n    }\n}\nSocketWithoutUpgrade.protocol = protocol;\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes with an upgrade mechanism, which means that once the connection is established with the first\n * low-level transport, it will try to upgrade to a better transport.\n *\n * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.\n *\n * @example\n * import { SocketWithUpgrade, WebSocket } from \"engine.io-client\";\n *\n * const socket = new SocketWithUpgrade({\n *   transports: [WebSocket]\n * });\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithoutUpgrade\n * @see Socket\n */\nexport class SocketWithUpgrade extends SocketWithoutUpgrade {\n    constructor() {\n        super(...arguments);\n        this._upgrades = [];\n    }\n    onOpen() {\n        super.onOpen();\n        if (\"open\" === this.readyState && this.opts.upgrade) {\n            for (let i = 0; i < this._upgrades.length; i++) {\n                this._probe(this._upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} name - transport name\n     * @private\n     */\n    _probe(name) {\n        let transport = this.createTransport(name);\n        let failed = false;\n        SocketWithoutUpgrade.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", (msg) => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    SocketWithoutUpgrade.priorWebsocketSuccess =\n                        \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = (err) => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        if (this._upgrades.indexOf(\"webtransport\") !== -1 &&\n            name !== \"webtransport\") {\n            // favor WebTransport\n            this.setTimeoutFn(() => {\n                if (!failed) {\n                    transport.open();\n                }\n            }, 200);\n        }\n        else {\n            transport.open();\n        }\n    }\n    onHandshake(data) {\n        this._upgrades = this._filterUpgrades(data.upgrades);\n        super.onHandshake(data);\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} upgrades - server upgrades\n     * @private\n     */\n    _filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        for (let i = 0; i < upgrades.length; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes with an upgrade mechanism, which means that once the connection is established with the first\n * low-level transport, it will try to upgrade to a better transport.\n *\n * @example\n * import { Socket } from \"engine.io-client\";\n *\n * const socket = new Socket();\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithoutUpgrade\n * @see SocketWithUpgrade\n */\nexport class Socket extends SocketWithUpgrade {\n    constructor(uri, opts = {}) {\n        const o = typeof uri === \"object\" ? uri : opts;\n        if (!o.transports ||\n            (o.transports && typeof o.transports[0] === \"string\")) {\n            o.transports = (o.transports || [\"polling\", \"websocket\", \"webtransport\"])\n                .map((transportName) => DEFAULT_TRANSPORTS[transportName])\n                .filter((t) => !!t);\n        }\n        super(uri, o);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6475, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6480, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/transports/polling-fetch.js"],"sourcesContent":["import { Polling } from \"./polling.js\";\n/**\n * HTTP long-polling based on the built-in `fetch()` method.\n *\n * Usage: browser, Node.js (since v18), Deno, Bun\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/fetch\n * @see https://caniuse.com/fetch\n * @see https://nodejs.org/api/globals.html#fetch\n */\nexport class Fetch extends Polling {\n    doPoll() {\n        this._fetch()\n            .then((res) => {\n            if (!res.ok) {\n                return this.onError(\"fetch read error\", res.status, res);\n            }\n            res.text().then((data) => this.onData(data));\n        })\n            .catch((err) => {\n            this.onError(\"fetch read error\", err);\n        });\n    }\n    doWrite(data, callback) {\n        this._fetch(data)\n            .then((res) => {\n            if (!res.ok) {\n                return this.onError(\"fetch write error\", res.status, res);\n            }\n            callback();\n        })\n            .catch((err) => {\n            this.onError(\"fetch write error\", err);\n        });\n    }\n    _fetch(data) {\n        var _a;\n        const isPost = data !== undefined;\n        const headers = new Headers(this.opts.extraHeaders);\n        if (isPost) {\n            headers.set(\"content-type\", \"text/plain;charset=UTF-8\");\n        }\n        (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);\n        return fetch(this.uri(), {\n            method: isPost ? \"POST\" : \"GET\",\n            body: isPost ? data : null,\n            headers,\n            credentials: this.opts.withCredentials ? \"include\" : \"omit\",\n        }).then((res) => {\n            var _a;\n            // @ts-ignore getSetCookie() was added in Node.js v19.7.0\n            (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(res.headers.getSetCookie());\n            return res;\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;AAUO,MAAM,cAAc,qPAAA,CAAA,UAAO;IAC9B,SAAS;QACL,IAAI,CAAC,MAAM,GACN,IAAI,CAAC,CAAC;YACP,IAAI,CAAC,IAAI,EAAE,EAAE;gBACT,OAAO,IAAI,CAAC,OAAO,CAAC,oBAAoB,IAAI,MAAM,EAAE;YACxD;YACA,IAAI,IAAI,GAAG,IAAI,CAAC,CAAC,OAAS,IAAI,CAAC,MAAM,CAAC;QAC1C,GACK,KAAK,CAAC,CAAC;YACR,IAAI,CAAC,OAAO,CAAC,oBAAoB;QACrC;IACJ;IACA,QAAQ,IAAI,EAAE,QAAQ,EAAE;QACpB,IAAI,CAAC,MAAM,CAAC,MACP,IAAI,CAAC,CAAC;YACP,IAAI,CAAC,IAAI,EAAE,EAAE;gBACT,OAAO,IAAI,CAAC,OAAO,CAAC,qBAAqB,IAAI,MAAM,EAAE;YACzD;YACA;QACJ,GACK,KAAK,CAAC,CAAC;YACR,IAAI,CAAC,OAAO,CAAC,qBAAqB;QACtC;IACJ;IACA,OAAO,IAAI,EAAE;QACT,IAAI;QACJ,MAAM,SAAS,SAAS;QACxB,MAAM,UAAU,IAAI,QAAQ,IAAI,CAAC,IAAI,CAAC,YAAY;QAClD,IAAI,QAAQ;YACR,QAAQ,GAAG,CAAC,gBAAgB;QAChC;QACA,CAAC,KAAK,IAAI,CAAC,MAAM,CAAC,UAAU,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,aAAa,CAAC;QACpF,OAAO,MAAM,IAAI,CAAC,GAAG,IAAI;YACrB,QAAQ,SAAS,SAAS;YAC1B,MAAM,SAAS,OAAO;YACtB;YACA,aAAa,IAAI,CAAC,IAAI,CAAC,eAAe,GAAG,YAAY;QACzD,GAAG,IAAI,CAAC,CAAC;YACL,IAAI;YACJ,yDAAyD;YACzD,CAAC,KAAK,IAAI,CAAC,MAAM,CAAC,UAAU,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,YAAY,CAAC,IAAI,OAAO,CAAC,YAAY;YAC3G,OAAO;QACX;IACJ;AACJ"}},
    {"offset": {"line": 6528, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6533, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/engine.io-client@6.6.3/node_modules/engine.io-client/build/esm/index.js"],"sourcesContent":["import { Socket } from \"./socket.js\";\nexport { Socket };\nexport { SocketWithoutUpgrade, SocketWithUpgrade, } from \"./socket.js\";\nexport const protocol = Socket.protocol;\nexport { Transport, TransportError } from \"./transport.js\";\nexport { transports } from \"./transports/index.js\";\nexport { installTimerFunctions } from \"./util.js\";\nexport { parse } from \"./contrib/parseuri.js\";\nexport { nextTick } from \"./globals.node.js\";\nexport { Fetch } from \"./transports/polling-fetch.js\";\nexport { XHR as NodeXHR } from \"./transports/polling-xhr.node.js\";\nexport { XHR } from \"./transports/polling-xhr.js\";\nexport { WS as NodeWebSocket } from \"./transports/websocket.node.js\";\nexport { WS as WebSocket } from \"./transports/websocket.js\";\nexport { WT as WebTransport } from \"./transports/webtransport.js\";\n"],"names":[],"mappings":";;;;;;;;AAGO,MAAM,WAAW,sOAAA,CAAA,SAAM,CAAC,QAAQ"}},
    {"offset": {"line": 6553, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6576, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/url.js"],"sourcesContent":["import { parse } from \"engine.io-client\";\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nexport function url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        obj = parse(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\n"],"names":[],"mappings":";;;;;;;AAUO,SAAS,IAAI,GAAG,EAAE,OAAO,EAAE,EAAE,GAAG;IACnC,IAAI,MAAM;IACV,6BAA6B;IAC7B,MAAM,OAAQ,OAAO,aAAa,eAAe;IACjD,IAAI,QAAQ,KACR,MAAM,IAAI,QAAQ,GAAG,OAAO,IAAI,IAAI;IACxC,wBAAwB;IACxB,IAAI,OAAO,QAAQ,UAAU;QACzB,IAAI,QAAQ,IAAI,MAAM,CAAC,IAAI;YACvB,IAAI,QAAQ,IAAI,MAAM,CAAC,IAAI;gBACvB,MAAM,IAAI,QAAQ,GAAG;YACzB,OACK;gBACD,MAAM,IAAI,IAAI,GAAG;YACrB;QACJ;QACA,IAAI,CAAC,sBAAsB,IAAI,CAAC,MAAM;YAClC,IAAI,gBAAgB,OAAO,KAAK;gBAC5B,MAAM,IAAI,QAAQ,GAAG,OAAO;YAChC,OACK;gBACD,MAAM,aAAa;YACvB;QACJ;QACA,QAAQ;QACR,MAAM,CAAA,GAAA,mPAAA,CAAA,QAAK,AAAD,EAAE;IAChB;IACA,4DAA4D;IAC5D,IAAI,CAAC,IAAI,IAAI,EAAE;QACX,IAAI,cAAc,IAAI,CAAC,IAAI,QAAQ,GAAG;YAClC,IAAI,IAAI,GAAG;QACf,OACK,IAAI,eAAe,IAAI,CAAC,IAAI,QAAQ,GAAG;YACxC,IAAI,IAAI,GAAG;QACf;IACJ;IACA,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI;IACvB,MAAM,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC;IACxC,MAAM,OAAO,OAAO,MAAM,IAAI,IAAI,GAAG,MAAM,IAAI,IAAI;IACnD,mBAAmB;IACnB,IAAI,EAAE,GAAG,IAAI,QAAQ,GAAG,QAAQ,OAAO,MAAM,IAAI,IAAI,GAAG;IACxD,cAAc;IACd,IAAI,IAAI,GACJ,IAAI,QAAQ,GACR,QACA,OACA,CAAC,OAAO,IAAI,IAAI,KAAK,IAAI,IAAI,GAAG,KAAK,MAAM,IAAI,IAAI;IAC3D,OAAO;AACX"}},
    {"offset": {"line": 6624, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6629, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/on.js"],"sourcesContent":["export function on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\n"],"names":[],"mappings":";;;AAAO,SAAS,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE;IAC1B,IAAI,EAAE,CAAC,IAAI;IACX,OAAO,SAAS;QACZ,IAAI,GAAG,CAAC,IAAI;IAChB;AACJ"}},
    {"offset": {"line": 6638, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6643, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/socket.js"],"sourcesContent":["import { PacketType } from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\n/**\n * A Socket is the fundamental class for interacting with the server.\n *\n * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n *\n * @example\n * const socket = io();\n *\n * socket.on(\"connect\", () => {\n *   console.log(\"connected\");\n * });\n *\n * // send an event to the server\n * socket.emit(\"foo\", \"bar\");\n *\n * socket.on(\"foobar\", () => {\n *   // an event was received from the server\n * });\n *\n * // upon disconnection\n * socket.on(\"disconnect\", (reason) => {\n *   console.log(`disconnected due to ${reason}`);\n * });\n */\nexport class Socket extends Emitter {\n    /**\n     * `Socket` constructor.\n     */\n    constructor(io, nsp, opts) {\n        super();\n        /**\n         * Whether the socket is currently connected to the server.\n         *\n         * @example\n         * const socket = io();\n         *\n         * socket.on(\"connect\", () => {\n         *   console.log(socket.connected); // true\n         * });\n         *\n         * socket.on(\"disconnect\", () => {\n         *   console.log(socket.connected); // false\n         * });\n         */\n        this.connected = false;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted by the server.\n         */\n        this.recovered = false;\n        /**\n         * Buffer for packets received before the CONNECT packet\n         */\n        this.receiveBuffer = [];\n        /**\n         * Buffer for packets that will be sent once the socket is connected\n         */\n        this.sendBuffer = [];\n        /**\n         * The queue of packets to be sent with retry in case of failure.\n         *\n         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n         * @private\n         */\n        this._queue = [];\n        /**\n         * A sequence to generate the ID of the {@link QueuedPacket}.\n         * @private\n         */\n        this._queueSeq = 0;\n        this.ids = 0;\n        /**\n         * A map containing acknowledgement handlers.\n         *\n         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:\n         *\n         * - `socket.emit(\"test\", (err, value) => { ... })` with `ackTimeout` option\n         * - `socket.timeout(5000).emit(\"test\", (err, value) => { ... })`\n         * - `const value = await socket.emitWithAck(\"test\")`\n         *\n         * From those that don't:\n         *\n         * - `socket.emit(\"test\", (value) => { ... });`\n         *\n         * In the first case, the handlers will be called with an error when:\n         *\n         * - the timeout is reached\n         * - the socket gets disconnected\n         *\n         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive\n         * an acknowledgement from the server.\n         *\n         * @private\n         */\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        this._opts = Object.assign({}, opts);\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on(io, \"open\", this.onopen.bind(this)),\n            on(io, \"packet\", this.onpacket.bind(this)),\n            on(io, \"error\", this.onerror.bind(this)),\n            on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n     *\n     * @example\n     * const socket = io();\n     *\n     * console.log(socket.active); // true\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   if (reason === \"io server disconnect\") {\n     *     // the disconnection was initiated by the server, you need to manually reconnect\n     *     console.log(socket.active); // false\n     *   }\n     *   // else the socket will automatically try to reconnect\n     *   console.log(socket.active); // true\n     * });\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @example\n     * const socket = io({\n     *   autoConnect: false\n     * });\n     *\n     * socket.connect();\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for {@link connect()}.\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * socket.send(\"hello\");\n     *\n     * // this is equivalent to\n     * socket.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @example\n     * socket.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the server\n     * socket.emit(\"hello\", \"world\", (val) => {\n     *   // ...\n     * });\n     *\n     * @return self\n     */\n    emit(ev, ...args) {\n        var _a, _b, _c;\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n            this._addToQueue(args);\n            return this;\n        }\n        const packet = {\n            type: PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            const id = this.ids++;\n            const ack = args.pop();\n            this._registerAckCallback(id, ack);\n            packet.id = id;\n        }\n        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;\n        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());\n        const discardPacket = this.flags.volatile && !isTransportWritable;\n        if (discardPacket) {\n        }\n        else if (isConnected) {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * @private\n     */\n    _registerAckCallback(id, ack) {\n        var _a;\n        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n        if (timeout === undefined) {\n            this.acks[id] = ack;\n            return;\n        }\n        // @ts-ignore\n        const timer = this.io.setTimeoutFn(() => {\n            delete this.acks[id];\n            for (let i = 0; i < this.sendBuffer.length; i++) {\n                if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                }\n            }\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        const fn = (...args) => {\n            // @ts-ignore\n            this.io.clearTimeoutFn(timer);\n            ack.apply(this, args);\n        };\n        fn.withError = true;\n        this.acks[id] = fn;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * // without timeout\n     * const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     * // with a specific timeout\n     * try {\n     *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     * } catch (err) {\n     *   // the server did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when the server acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject) => {\n            const fn = (arg1, arg2) => {\n                return arg1 ? reject(arg1) : resolve(arg2);\n            };\n            fn.withError = true;\n            args.push(fn);\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Add the packet to the queue.\n     * @param args\n     * @private\n     */\n    _addToQueue(args) {\n        let ack;\n        if (typeof args[args.length - 1] === \"function\") {\n            ack = args.pop();\n        }\n        const packet = {\n            id: this._queueSeq++,\n            tryCount: 0,\n            pending: false,\n            args,\n            flags: Object.assign({ fromQueue: true }, this.flags),\n        };\n        args.push((err, ...responseArgs) => {\n            if (packet !== this._queue[0]) {\n                // the packet has already been acknowledged\n                return;\n            }\n            const hasError = err !== null;\n            if (hasError) {\n                if (packet.tryCount > this._opts.retries) {\n                    this._queue.shift();\n                    if (ack) {\n                        ack(err);\n                    }\n                }\n            }\n            else {\n                this._queue.shift();\n                if (ack) {\n                    ack(null, ...responseArgs);\n                }\n            }\n            packet.pending = false;\n            return this._drainQueue();\n        });\n        this._queue.push(packet);\n        this._drainQueue();\n    }\n    /**\n     * Send the first packet of the queue, and wait for an acknowledgement from the server.\n     * @param force - whether to resend a packet that has not been acknowledged yet\n     *\n     * @private\n     */\n    _drainQueue(force = false) {\n        if (!this.connected || this._queue.length === 0) {\n            return;\n        }\n        const packet = this._queue[0];\n        if (packet.pending && !force) {\n            return;\n        }\n        packet.pending = true;\n        packet.tryCount++;\n        this.flags = packet.flags;\n        this.emit.apply(this, packet.args);\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this._sendConnectPacket(data);\n            });\n        }\n        else {\n            this._sendConnectPacket(this.auth);\n        }\n    }\n    /**\n     * Sends a CONNECT packet to initiate the Socket.IO session.\n     *\n     * @param data\n     * @private\n     */\n    _sendConnectPacket(data) {\n        this.packet({\n            type: PacketType.CONNECT,\n            data: this._pid\n                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)\n                : data,\n        });\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        this.connected = false;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason, description);\n        this._clearAcks();\n    }\n    /**\n     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from\n     * the server.\n     *\n     * @private\n     */\n    _clearAcks() {\n        Object.keys(this.acks).forEach((id) => {\n            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);\n            if (!isBuffered) {\n                // note: handlers that do not accept an error as first argument are ignored here\n                const ack = this.acks[id];\n                delete this.acks[id];\n                if (ack.withError) {\n                    ack.call(this, new Error(\"socket has been disconnected\"));\n                }\n            }\n        });\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case PacketType.CONNECT_ERROR:\n                this.destroy();\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        if (null != packet.id) {\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n            this._lastOffset = args[args.length - 1];\n        }\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            self.packet({\n                type: PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowledgement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (typeof ack !== \"function\") {\n            return;\n        }\n        delete this.acks[packet.id];\n        // @ts-ignore FIXME ack is incorrectly inferred as 'never'\n        if (ack.withError) {\n            packet.data.unshift(null);\n        }\n        // @ts-ignore\n        ack.apply(this, packet.data);\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id, pid) {\n        this.id = id;\n        this.recovered = pid && this._pid === pid;\n        this._pid = pid; // defined only if connection state recovery is enabled\n        this.connected = true;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n        this._drainQueue(true);\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        });\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n     *\n     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   // console.log(reason); prints \"io client disconnect\"\n     * });\n     *\n     * socket.disconnect();\n     *\n     * @return self\n     */\n    disconnect() {\n        if (this.connected) {\n            this.packet({ type: PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for {@link disconnect()}.\n     *\n     * @return self\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * socket.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @example\n     * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n     *\n     * @returns self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\n     *\n     * @example\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\n     *   if (err) {\n     *     // the server did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @example\n     * socket.onAny((event, ...args) => {\n     *   console.log(`got ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * socket.prependAny((event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * }\n     *\n     * socket.onAny(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAny(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAny();\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.onAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.prependAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * }\n     *\n     * socket.onAnyOutgoing(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAnyOutgoing(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAnyOutgoing();\n     *\n     * @param [listener] - the catch-all listener (optional)\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7449, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7454, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/contrib/backo2.js"],"sourcesContent":["/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\nexport function Backoff(opts) {\n    opts = opts || {};\n    this.ms = opts.min || 100;\n    this.max = opts.max || 10000;\n    this.factor = opts.factor || 2;\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n    this.attempts = 0;\n}\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\nBackoff.prototype.duration = function () {\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\n    if (this.jitter) {\n        var rand = Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n    }\n    return Math.min(ms, this.max) | 0;\n};\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\nBackoff.prototype.reset = function () {\n    this.attempts = 0;\n};\n/**\n * Set the minimum duration\n *\n * @api public\n */\nBackoff.prototype.setMin = function (min) {\n    this.ms = min;\n};\n/**\n * Set the maximum duration\n *\n * @api public\n */\nBackoff.prototype.setMax = function (max) {\n    this.max = max;\n};\n/**\n * Set the jitter\n *\n * @api public\n */\nBackoff.prototype.setJitter = function (jitter) {\n    this.jitter = jitter;\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;CAUC;;;AACM,SAAS,QAAQ,IAAI;IACxB,OAAO,QAAQ,CAAC;IAChB,IAAI,CAAC,EAAE,GAAG,KAAK,GAAG,IAAI;IACtB,IAAI,CAAC,GAAG,GAAG,KAAK,GAAG,IAAI;IACvB,IAAI,CAAC,MAAM,GAAG,KAAK,MAAM,IAAI;IAC7B,IAAI,CAAC,MAAM,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK,MAAM,IAAI,IAAI,KAAK,MAAM,GAAG;IAClE,IAAI,CAAC,QAAQ,GAAG;AACpB;AACA;;;;;CAKC,GACD,QAAQ,SAAS,CAAC,QAAQ,GAAG;IACzB,IAAI,KAAK,IAAI,CAAC,EAAE,GAAG,KAAK,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ;IACtD,IAAI,IAAI,CAAC,MAAM,EAAE;QACb,IAAI,OAAO,KAAK,MAAM;QACtB,IAAI,YAAY,KAAK,KAAK,CAAC,OAAO,IAAI,CAAC,MAAM,GAAG;QAChD,KAAK,CAAC,KAAK,KAAK,CAAC,OAAO,MAAM,CAAC,KAAK,IAAI,KAAK,YAAY,KAAK;IAClE;IACA,OAAO,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,IAAI;AACpC;AACA;;;;CAIC,GACD,QAAQ,SAAS,CAAC,KAAK,GAAG;IACtB,IAAI,CAAC,QAAQ,GAAG;AACpB;AACA;;;;CAIC,GACD,QAAQ,SAAS,CAAC,MAAM,GAAG,SAAU,GAAG;IACpC,IAAI,CAAC,EAAE,GAAG;AACd;AACA;;;;CAIC,GACD,QAAQ,SAAS,CAAC,MAAM,GAAG,SAAU,GAAG;IACpC,IAAI,CAAC,GAAG,GAAG;AACf;AACA;;;;CAIC,GACD,QAAQ,SAAS,CAAC,SAAS,GAAG,SAAU,MAAM;IAC1C,IAAI,CAAC,MAAM,GAAG;AAClB"}},
    {"offset": {"line": 7517, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7522, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/manager.js"],"sourcesContent":["import { Socket as Engine, installTimerFunctions, nextTick, } from \"engine.io-client\";\nimport { Socket } from \"./socket.js\";\nimport * as parser from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Backoff } from \"./contrib/backo2.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\nexport class Manager extends Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        installTimerFunctions(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        if (!v) {\n            this.skipReconnect = true;\n        }\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new Engine(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        const onError = (err) => {\n            this.cleanup();\n            this._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                this.maybeReconnectOnOpen();\n            }\n        };\n        // emit `error`\n        const errorSub = on(socket, \"error\", onError);\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                onError(new Error(\"timeout\"));\n                socket.close();\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), \n        // @ts-ignore\n        on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onclose(\"parse error\", e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        nextTick(() => {\n            this.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        else if (this._autoConnect && !socket.active) {\n            socket.connect();\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called when:\n     *\n     * - the low-level engine is closed\n     * - the parser encountered a badly formatted packet\n     * - all sockets are disconnected\n     *\n     * @private\n     */\n    onclose(reason, description) {\n        var _a;\n        this.cleanup();\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7866, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7871, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/index.js"],"sourcesContent":["import { url } from \"./url.js\";\nimport { Manager } from \"./manager.js\";\nimport { Socket } from \"./socket.js\";\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        io = new Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            cache[id] = new Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager,\n    Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\nexport { protocol } from \"socket.io-parser\";\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\nexport { Manager, Socket, lookup as io, lookup as connect, lookup as default, };\nexport { Fetch, NodeXHR, XHR, NodeWebSocket, WebSocket, WebTransport, } from \"engine.io-client\";\n"],"names":[],"mappings":";;;;;;;;;;;;AAGA;;CAEC,GACD,MAAM,QAAQ,CAAC;AACf,SAAS,OAAO,GAAG,EAAE,IAAI;IACrB,IAAI,OAAO,QAAQ,UAAU;QACzB,OAAO;QACP,MAAM;IACV;IACA,OAAO,QAAQ,CAAC;IAChB,MAAM,SAAS,CAAA,GAAA,mOAAA,CAAA,MAAG,AAAD,EAAE,KAAK,KAAK,IAAI,IAAI;IACrC,MAAM,SAAS,OAAO,MAAM;IAC5B,MAAM,KAAK,OAAO,EAAE;IACpB,MAAM,OAAO,OAAO,IAAI;IACxB,MAAM,gBAAgB,KAAK,CAAC,GAAG,IAAI,QAAQ,KAAK,CAAC,GAAG,CAAC,OAAO;IAC5D,MAAM,gBAAgB,KAAK,QAAQ,IAC/B,IAAI,CAAC,uBAAuB,IAC5B,UAAU,KAAK,SAAS,IACxB;IACJ,IAAI;IACJ,IAAI,eAAe;QACf,KAAK,IAAI,uOAAA,CAAA,UAAO,CAAC,QAAQ;IAC7B,OACK;QACD,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE;YACZ,KAAK,CAAC,GAAG,GAAG,IAAI,uOAAA,CAAA,UAAO,CAAC,QAAQ;QACpC;QACA,KAAK,KAAK,CAAC,GAAG;IAClB;IACA,IAAI,OAAO,KAAK,IAAI,CAAC,KAAK,KAAK,EAAE;QAC7B,KAAK,KAAK,GAAG,OAAO,QAAQ;IAChC;IACA,OAAO,GAAG,MAAM,CAAC,OAAO,IAAI,EAAE;AAClC;AACA,4EAA4E;AAC5E,iEAAiE;AACjE,OAAO,MAAM,CAAC,QAAQ;IAClB,SAAA,uOAAA,CAAA,UAAO;IACP,QAAA,sOAAA,CAAA,SAAM;IACN,IAAI;IACJ,SAAS;AACb"}},
    {"offset": {"line": 7923, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7941, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/esm/is-binary.js"],"sourcesContent":["const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nexport function isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nexport function hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,wBAAwB,OAAO,gBAAgB;AACrD,MAAM,SAAS,CAAC;IACZ,OAAO,OAAO,YAAY,MAAM,KAAK,aAC/B,YAAY,MAAM,CAAC,OACnB,IAAI,MAAM,YAAY;AAChC;AACA,MAAM,WAAW,OAAO,SAAS,CAAC,QAAQ;AAC1C,MAAM,iBAAiB,OAAO,SAAS,cAClC,OAAO,SAAS,eACb,SAAS,IAAI,CAAC,UAAU;AAChC,MAAM,iBAAiB,OAAO,SAAS,cAClC,OAAO,SAAS,eACb,SAAS,IAAI,CAAC,UAAU;AAMzB,SAAS,SAAS,GAAG;IACxB,OAAQ,AAAC,yBAAyB,CAAC,eAAe,eAAe,OAAO,IAAI,KACvE,kBAAkB,eAAe,QACjC,kBAAkB,eAAe;AAC1C;AACO,SAAS,UAAU,GAAG,EAAE,MAAM;IACjC,IAAI,CAAC,OAAO,OAAO,QAAQ,UAAU;QACjC,OAAO;IACX;IACA,IAAI,MAAM,OAAO,CAAC,MAAM;QACpB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAI,GAAG,IAAK;YACxC,IAAI,UAAU,GAAG,CAAC,EAAE,GAAG;gBACnB,OAAO;YACX;QACJ;QACA,OAAO;IACX;IACA,IAAI,SAAS,MAAM;QACf,OAAO;IACX;IACA,IAAI,IAAI,MAAM,IACV,OAAO,IAAI,MAAM,KAAK,cACtB,UAAU,MAAM,KAAK,GAAG;QACxB,OAAO,UAAU,IAAI,MAAM,IAAI;IACnC;IACA,IAAK,MAAM,OAAO,IAAK;QACnB,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,QAAQ,UAAU,GAAG,CAAC,IAAI,GAAG;YACvE,OAAO;QACX;IACJ;IACA,OAAO;AACX"}},
    {"offset": {"line": 7980, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7985, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/esm/binary.js"],"sourcesContent":["import { isBinary } from \"./is-binary.js\";\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nexport function deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (isBinary(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nexport function reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    delete packet.attachments; // no longer useful\n    return packet;\n}\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder === true) {\n        const isIndexValid = typeof data.num === \"number\" &&\n            data.num >= 0 &&\n            data.num < buffers.length;\n        if (isIndexValid) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n        }\n        else {\n            throw new Error(\"illegal attachments\");\n        }\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n"],"names":[],"mappings":";;;;;;;AAQO,SAAS,kBAAkB,MAAM;IACpC,MAAM,UAAU,EAAE;IAClB,MAAM,aAAa,OAAO,IAAI;IAC9B,MAAM,OAAO;IACb,KAAK,IAAI,GAAG,mBAAmB,YAAY;IAC3C,KAAK,WAAW,GAAG,QAAQ,MAAM,EAAE,iCAAiC;IACpE,OAAO;QAAE,QAAQ;QAAM,SAAS;IAAQ;AAC5C;AACA,SAAS,mBAAmB,IAAI,EAAE,OAAO;IACrC,IAAI,CAAC,MACD,OAAO;IACX,IAAI,CAAA,GAAA,4OAAA,CAAA,WAAQ,AAAD,EAAE,OAAO;QAChB,MAAM,cAAc;YAAE,cAAc;YAAM,KAAK,QAAQ,MAAM;QAAC;QAC9D,QAAQ,IAAI,CAAC;QACb,OAAO;IACX,OACK,IAAI,MAAM,OAAO,CAAC,OAAO;QAC1B,MAAM,UAAU,IAAI,MAAM,KAAK,MAAM;QACrC,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;YAClC,OAAO,CAAC,EAAE,GAAG,mBAAmB,IAAI,CAAC,EAAE,EAAE;QAC7C;QACA,OAAO;IACX,OACK,IAAI,OAAO,SAAS,YAAY,CAAC,CAAC,gBAAgB,IAAI,GAAG;QAC1D,MAAM,UAAU,CAAC;QACjB,IAAK,MAAM,OAAO,KAAM;YACpB,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,MAAM;gBACjD,OAAO,CAAC,IAAI,GAAG,mBAAmB,IAAI,CAAC,IAAI,EAAE;YACjD;QACJ;QACA,OAAO;IACX;IACA,OAAO;AACX;AASO,SAAS,kBAAkB,MAAM,EAAE,OAAO;IAC7C,OAAO,IAAI,GAAG,mBAAmB,OAAO,IAAI,EAAE;IAC9C,OAAO,OAAO,WAAW,EAAE,mBAAmB;IAC9C,OAAO;AACX;AACA,SAAS,mBAAmB,IAAI,EAAE,OAAO;IACrC,IAAI,CAAC,MACD,OAAO;IACX,IAAI,QAAQ,KAAK,YAAY,KAAK,MAAM;QACpC,MAAM,eAAe,OAAO,KAAK,GAAG,KAAK,YACrC,KAAK,GAAG,IAAI,KACZ,KAAK,GAAG,GAAG,QAAQ,MAAM;QAC7B,IAAI,cAAc;YACd,OAAO,OAAO,CAAC,KAAK,GAAG,CAAC,EAAE,sDAAsD;QACpF,OACK;YACD,MAAM,IAAI,MAAM;QACpB;IACJ,OACK,IAAI,MAAM,OAAO,CAAC,OAAO;QAC1B,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;YAClC,IAAI,CAAC,EAAE,GAAG,mBAAmB,IAAI,CAAC,EAAE,EAAE;QAC1C;IACJ,OACK,IAAI,OAAO,SAAS,UAAU;QAC/B,IAAK,MAAM,OAAO,KAAM;YACpB,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,MAAM;gBACjD,IAAI,CAAC,IAAI,GAAG,mBAAmB,IAAI,CAAC,IAAI,EAAE;YAC9C;QACJ;IACJ;IACA,OAAO;AACX"}},
    {"offset": {"line": 8056, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8061, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/esm/index.js"],"sourcesContent":["import { Emitter } from \"@socket.io/component-emitter\";\nimport { deconstructPacket, reconstructPacket } from \"./binary.js\";\nimport { isBinary, hasBinary } from \"./is-binary.js\";\n/**\n * These strings must not be used as event names, as they have a special meaning.\n */\nconst RESERVED_EVENTS = [\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\", // used by the Node.js EventEmitter\n];\n/**\n * Protocol version.\n *\n * @public\n */\nexport const protocol = 5;\nexport var PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nexport class Encoder {\n    /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */\n    constructor(replacer) {\n        this.replacer = replacer;\n    }\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if (hasBinary(obj)) {\n                return this.encodeAsBinary({\n                    type: obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK,\n                    nsp: obj.nsp,\n                    data: obj.data,\n                    id: obj.id,\n                });\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data, this.replacer);\n        }\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = deconstructPacket(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\n// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript\nfunction isObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n}\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nexport class Decoder extends Emitter {\n    /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */\n    constructor(reviver) {\n        super();\n        this.reviver = reviver;\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            if (this.reconstructor) {\n                throw new Error(\"got plaintext data when reconstructing a packet\");\n            }\n            packet = this.decodeString(obj);\n            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if (isBinary(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = this.tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        return p;\n    }\n    tryParse(str) {\n        try {\n            return JSON.parse(str, this.reviver);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return isObject(payload);\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || isObject(payload);\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return (Array.isArray(payload) &&\n                    (typeof payload[0] === \"number\" ||\n                        (typeof payload[0] === \"string\" &&\n                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n            this.reconstructor = null;\n        }\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = reconstructPacket(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8342, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8346, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.3.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"],"sourcesContent":["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n"],"names":[],"mappings":"AAAA;;;;;;;;CAQC;;AAED;AACA,oEACE,AAAC;IACC,SAAS,GAAG,CAAC,EAAE,CAAC;QACd,OAAO,AAAC,MAAM,KAAK,CAAC,MAAM,KAAK,IAAI,MAAM,IAAI,CAAC,KAAO,MAAM,KAAK,MAAM;IACxE;IACA,SAAS,uBAAuB,SAAS,EAAE,WAAW;QACpD,qBACE,KAAK,MAAM,MAAM,eAAe,IAChC,CAAC,AAAC,oBAAoB,CAAC,GACvB,QAAQ,KAAK,CACX,iMACD;QACH,IAAI,QAAQ;QACZ,IAAI,CAAC,4BAA4B;YAC/B,IAAI,cAAc;YAClB,SAAS,OAAO,gBACd,CAAC,QAAQ,KAAK,CACZ,yEAED,6BAA6B,CAAC,CAAE;QACrC;QACA,cAAc,SAAS;YACrB,MAAM;gBAAE,OAAO;gBAAO,aAAa;YAAY;QACjD;QACA,IAAI,OAAO,WAAW,CAAC,EAAE,CAAC,IAAI,EAC5B,cAAc,WAAW,CAAC,EAAE;QAC9B,gBACE;YACE,KAAK,KAAK,GAAG;YACb,KAAK,WAAW,GAAG;YACnB,uBAAuB,SAAS,YAAY;gBAAE,MAAM;YAAK;QAC3D,GACA;YAAC;YAAW;YAAO;SAAY;QAEjC,UACE;YACE,uBAAuB,SAAS,YAAY;gBAAE,MAAM;YAAK;YACzD,OAAO,UAAU;gBACf,uBAAuB,SAAS,YAAY;oBAAE,MAAM;gBAAK;YAC3D;QACF,GACA;YAAC;SAAU;QAEb,cAAc;QACd,OAAO;IACT;IACA,SAAS,uBAAuB,IAAI;QAClC,IAAI,oBAAoB,KAAK,WAAW;QACxC,OAAO,KAAK,KAAK;QACjB,IAAI;YACF,IAAI,YAAY;YAChB,OAAO,CAAC,SAAS,MAAM;QACzB,EAAE,OAAO,OAAO;YACd,OAAO,CAAC;QACV;IACF;IACA,SAAS,uBAAuB,SAAS,EAAE,WAAW;QACpD,OAAO;IACT;IACA,gBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,2BAA2B,IACnE,+BAA+B,2BAA2B,CAAC;IAC7D,IAAI,+NACF,WAAW,eAAe,OAAO,OAAO,EAAE,GAAG,OAAO,EAAE,GAAG,IACzD,WAAW,MAAM,QAAQ,EACzB,YAAY,MAAM,SAAS,EAC3B,kBAAkB,MAAM,eAAe,EACvC,gBAAgB,MAAM,aAAa,EACnC,oBAAoB,CAAC,GACrB,6BAA6B,CAAC,GAC9B,OACE,gBAAgB,OAAO,UACvB,gBAAgB,OAAO,OAAO,QAAQ,IACtC,gBAAgB,OAAO,OAAO,QAAQ,CAAC,aAAa,GAChD,yBACA;IACR,QAAQ,oBAAoB,GAC1B,KAAK,MAAM,MAAM,oBAAoB,GAAG,MAAM,oBAAoB,GAAG;IACvE,gBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,0BAA0B,IAClE,+BAA+B,0BAA0B,CAAC;AAC9D"}},
    {"offset": {"line": 8419, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8423, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.3.1/node_modules/use-sync-external-store/shim/index.js"],"sourcesContent":["'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n"],"names":[],"mappings":";;AAAA;AAEA;;OAEO;IACL,OAAO,OAAO;AAChB"}},
    {"offset": {"line": 8431, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8435, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.3.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"],"sourcesContent":["/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      shim = require(\"use-sync-external-store/shim\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = shim.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n"],"names":[],"mappings":"AAAA;;;;;;;;CAQC;;AAED;AACA,oEACE,AAAC;IACC,SAAS,GAAG,CAAC,EAAE,CAAC;QACd,OAAO,AAAC,MAAM,KAAK,CAAC,MAAM,KAAK,IAAI,MAAM,IAAI,CAAC,KAAO,MAAM,KAAK,MAAM;IACxE;IACA,gBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,2BAA2B,IACnE,+BAA+B,2BAA2B,CAAC;IAC7D,IAAI,+NACF,sLACA,WAAW,eAAe,OAAO,OAAO,EAAE,GAAG,OAAO,EAAE,GAAG,IACzD,uBAAuB,KAAK,oBAAoB,EAChD,SAAS,MAAM,MAAM,EACrB,YAAY,MAAM,SAAS,EAC3B,UAAU,MAAM,OAAO,EACvB,gBAAgB,MAAM,aAAa;IACrC,QAAQ,gCAAgC,GAAG,SACzC,SAAS,EACT,WAAW,EACX,iBAAiB,EACjB,QAAQ,EACR,OAAO;QAEP,IAAI,UAAU,OAAO;QACrB,IAAI,SAAS,QAAQ,OAAO,EAAE;YAC5B,IAAI,OAAO;gBAAE,UAAU,CAAC;gBAAG,OAAO;YAAK;YACvC,QAAQ,OAAO,GAAG;QACpB,OAAO,OAAO,QAAQ,OAAO;QAC7B,UAAU,QACR;YACE,SAAS,iBAAiB,YAAY;gBACpC,IAAI,CAAC,SAAS;oBACZ,UAAU,CAAC;oBACX,mBAAmB;oBACnB,eAAe,SAAS;oBACxB,IAAI,KAAK,MAAM,WAAW,KAAK,QAAQ,EAAE;wBACvC,IAAI,mBAAmB,KAAK,KAAK;wBACjC,IAAI,QAAQ,kBAAkB,eAC5B,OAAQ,oBAAoB;oBAChC;oBACA,OAAQ,oBAAoB;gBAC9B;gBACA,mBAAmB;gBACnB,IAAI,SAAS,kBAAkB,eAC7B,OAAO;gBACT,IAAI,gBAAgB,SAAS;gBAC7B,IAAI,KAAK,MAAM,WAAW,QAAQ,kBAAkB,gBAClD,OAAO,AAAC,mBAAmB,cAAe;gBAC5C,mBAAmB;gBACnB,OAAQ,oBAAoB;YAC9B;YACA,IAAI,UAAU,CAAC,GACb,kBACA,mBACA,yBACE,KAAK,MAAM,oBAAoB,OAAO;YAC1C,OAAO;gBACL;oBACE,OAAO,iBAAiB;gBAC1B;gBACA,SAAS,yBACL,KAAK,IACL;oBACE,OAAO,iBAAiB;gBAC1B;aACL;QACH,GACA;YAAC;YAAa;YAAmB;YAAU;SAAQ;QAErD,IAAI,QAAQ,qBAAqB,WAAW,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE;QAClE,UACE;YACE,KAAK,QAAQ,GAAG,CAAC;YACjB,KAAK,KAAK,GAAG;QACf,GACA;YAAC;SAAM;QAET,cAAc;QACd,OAAO;IACT;IACA,gBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,0BAA0B,IAClE,+BAA+B,0BAA0B,CAAC;AAC9D"}},
    {"offset": {"line": 8507, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8511, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/use-sync-external-store@1.5.0_react@18.3.1/node_modules/use-sync-external-store/shim/with-selector.js"],"sourcesContent":["'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n"],"names":[],"mappings":";;AAAA;AAEA;;OAEO;IACL,OAAO,OAAO;AAChB"}},
    {"offset": {"line": 8519, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8524, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/zustand@4.5.7_@types+react@18.3.23_react@18.3.1/node_modules/zustand/esm/vanilla.mjs"],"sourcesContent":["const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n"],"names":[],"mappings":";;;;;;;;;;AAAA,MAAM,kBAAkB,CAAC;IACvB,IAAI;IACJ,MAAM,YAAY,aAAa,GAAG,IAAI;IACtC,MAAM,WAAW,CAAC,SAAS;QACzB,MAAM,YAAY,OAAO,YAAY,aAAa,QAAQ,SAAS;QACnE,IAAI,CAAC,OAAO,EAAE,CAAC,WAAW,QAAQ;YAChC,MAAM,gBAAgB;YACtB,QAAQ,CAAC,WAAW,OAAO,UAAU,OAAO,cAAc,YAAY,cAAc,IAAI,IAAI,YAAY,OAAO,MAAM,CAAC,CAAC,GAAG,OAAO;YACjI,UAAU,OAAO,CAAC,CAAC,WAAa,SAAS,OAAO;QAClD;IACF;IACA,MAAM,WAAW,IAAM;IACvB,MAAM,kBAAkB,IAAM;IAC9B,MAAM,YAAY,CAAC;QACjB,UAAU,GAAG,CAAC;QACd,OAAO,IAAM,UAAU,MAAM,CAAC;IAChC;IACA,MAAM,UAAU;QACd,IAAI,CAAC,8BAAY,GAAG,GAAG,8BAAY,GAAG,CAAC,IAAI,GAAG,KAAK,CAAC,MAAM,cAAc;YACtE,QAAQ,IAAI,CACV;QAEJ;QACA,UAAU,KAAK;IACjB;IACA,MAAM,MAAM;QAAE;QAAU;QAAU;QAAiB;QAAW;IAAQ;IACtE,MAAM,eAAe,QAAQ,YAAY,UAAU,UAAU;IAC7D,OAAO;AACT;AACA,MAAM,cAAc,CAAC,cAAgB,cAAc,gBAAgB,eAAe;AAClF,IAAI,UAAU,CAAC;IACb,IAAI,CAAC,8BAAY,GAAG,GAAG,8BAAY,GAAG,CAAC,IAAI,GAAG,KAAK,CAAC,MAAM,cAAc;QACtE,QAAQ,IAAI,CACV;IAEJ;IACA,OAAO,YAAY;AACrB"}},
    {"offset": {"line": 8575, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8580, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/zustand@4.5.7_@types+react@18.3.23_react@18.3.1/node_modules/zustand/esm/index.mjs"],"sourcesContent":["import { createStore } from 'zustand/vanilla';\nexport * from 'zustand/vanilla';\nimport ReactExports from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\n\nconst { useDebugValue } = ReactExports;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nlet didWarnAboutEqualityFn = false;\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity, equalityFn) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && equalityFn && !didWarnAboutEqualityFn) {\n    console.warn(\n      \"[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937\"\n    );\n    didWarnAboutEqualityFn = true;\n  }\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\nexport { create, react as default, useStore };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAKA,MAAM,EAAE,aAAa,EAAE,GAAG,6UAAA,CAAA,UAAY;AACtC,MAAM,EAAE,gCAAgC,EAAE,GAAG,kRAAA,CAAA,UAA2B;AACxE,IAAI,yBAAyB;AAC7B,MAAM,WAAW,CAAC,MAAQ;AAC1B,SAAS,SAAS,GAAG,EAAE,WAAW,QAAQ,EAAE,UAAU;IACpD,IAAI,CAAC,8BAAY,GAAG,GAAG,8BAAY,GAAG,CAAC,IAAI,GAAG,KAAK,CAAC,MAAM,gBAAgB,cAAc,CAAC,wBAAwB;QAC/G,QAAQ,IAAI,CACV;QAEF,yBAAyB;IAC3B;IACA,MAAM,QAAQ,iCACZ,IAAI,SAAS,EACb,IAAI,QAAQ,EACZ,IAAI,cAAc,IAAI,IAAI,eAAe,EACzC,UACA;IAEF,cAAc;IACd,OAAO;AACT;AACA,MAAM,aAAa,CAAC;IAClB,IAAI,CAAC,8BAAY,GAAG,GAAG,8BAAY,GAAG,CAAC,IAAI,GAAG,KAAK,CAAC,MAAM,gBAAgB,OAAO,gBAAgB,YAAY;QAC3G,QAAQ,IAAI,CACV;IAEJ;IACA,MAAM,MAAM,OAAO,gBAAgB,aAAa,CAAA,GAAA,2PAAA,CAAA,cAAW,AAAD,EAAE,eAAe;IAC3E,MAAM,gBAAgB,CAAC,UAAU,aAAe,SAAS,KAAK,UAAU;IACxE,OAAO,MAAM,CAAC,eAAe;IAC7B,OAAO;AACT;AACA,MAAM,SAAS,CAAC,cAAgB,cAAc,WAAW,eAAe;AACxE,IAAI,QAAQ,CAAC;IACX,IAAI,CAAC,8BAAY,GAAG,GAAG,8BAAY,GAAG,CAAC,IAAI,GAAG,KAAK,CAAC,MAAM,cAAc;QACtE,QAAQ,IAAI,CACV;IAEJ;IACA,OAAO,OAAO;AAChB"}},
    {"offset": {"line": 8628, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8633, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/zustand@4.5.7_@types+react@18.3.23_react@18.3.1/node_modules/zustand/esm/middleware.mjs"],"sourcesContent":["const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (_e) {\n  }\n  if (!extensionConnector) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState) return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0) f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (_e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst oldImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (_e) {\n  }\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst newImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return [\n              true,\n              options.migrate(\n                deserializedStorageValue.state,\n                deserializedStorageValue.version\n              )\n            ];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, void 0];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persistImpl = (config, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.\"\n      );\n    }\n    return oldImpl(config, baseOptions);\n  }\n  return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9186, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}